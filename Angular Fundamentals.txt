Course Overview
Course Overview
Hey there. This is Jim Cooper. ‑And this is Joe Eames. ‑Welcome to our Pluralsight course, Angular 2 Fundamentals. Joe and I have been developers for a long time, and we've been building large‑scale Angular applications ever since Angular 1's official release. And we're excited to share with you what we've learned about Angular 2. This course will give you all the fundamental knowledge you need in order to start building your own Angular applications, whether for small, fun personal projects or for large enterprise applications. In this course, you'll gain a high‑level understanding of the architecture of Angular applications in addition to a detailed understanding of building applications with Angular. Once we introduce you to the high‑level concepts, we'll spend most of this course actually writing code for a demo application that models real‑world applications. This intermediate‑level course has been designed to help you learn Angular from the ground up. If you feel like things are moving a little too quickly, you can check out one of the beginner‑level courses, but we've tried to make this a course that will teach you the fundamentals, even if you've had no prior experience with Angular. In this course, you'll learn about the following: the architecture of an Angular application and how to bootstrap a new application, Angular components and template syntax, including pipes and directives, creating reusable services and how dependency injection works in Angular, working with forms and validation, making API calls with HTTP and observables, and how to unit test and end‑to‑end test your application, and finally, how to package it all together for production. When you have finished this course, you will know enough about Angular to start building real‑world applications using Angular best practices. The only real prerequisite for this course is that you have some knowledge of JavaScript and HTML, but you certainly don't need to be an expert. So join us as we explore the exciting world of Angular.

Getting Started with Angular
Introduction
Hi. This is Jim Cooper, and welcome to this Angular Fundamentals module on getting started with Angular. In this module, you'll develop a high‑level conceptual understanding of Angular applications, and you'll create your first Angular Hello World app. We'll also cover some of the prerequisites for this course and give a brief introduction to some of the technologies that it will be helpful to know a little bit about for this course. We'll make this as quick and instructive as possible so that we can dive right into coding. Before we get started, let's talk a little bit about some prerequisites. First of all, you'll definitely need some fundamental JavaScript knowledge. We won't be doing anything too complex, so if you feel like you have a decent grasp of basic JavaScript fundamentals, you'll be just fine. If you want to brush up on your JavaScript, choose a course or two from the Beginner JavaScript Learning Path. You'll also want to have a basic understanding of HTML. As long as you can build a simple web page, that's really all you'll need to know. If you're fairly new to HTML, you may miss some concepts, but it shouldn't distract too much from learning how to create Angular applications. There's also an HTML Learning Path if you want to learn a little bit more. Now let's take a look at a few things that will be helpful to know, but not necessarily required. Don't let this list worry you, you'll be just fine without knowing them. This is just a heads up on some of the technologies that we'll be using. First up is Node and npm. We'll be using Node and npm to get up and running, and you'll need to get Node installed and functional if you're going to follow along. We'll show you how to do that, but having a little bit of background will make things easier. Joe Eames has a great Npm Playbook course to help you along there. We'll also be using some ES2015, or ES6, syntax in this course. We won't be using a lot of this, but we will be using some. And Joe Eames and Scott Allen have a great JavaScript Fundamentals with ECMAScript 6 course that you can watch if you want to dig deeper into that. And then we'll also be using TypeScript in this course. You aren't required to use TypeScript to write Angular 2 apps, but it is by far the most mainstream approach, so it's what we'll be using in this course. Dan Wahlin and John Papa have a great course to help you learn TypeScript. Again, if you don't know TypeScript, don't worry, most of the code we'll be using is just plain JavaScript and the TypeScript pieces shouldn't throw you off too much. None of the items listed here are required before you watch this course. If you're not familiar with them, you could certainly wait to brush up on these things until after this course and be just fine. We'll guide you through the Node and npm pieces in the course and we'll actually introduce you to the key concepts of TypeScript in just a moment. But first, we'd like to introduce you to the practice exercises that we've provided for this course.

Practice Exercises
To help facilitate your learning, Joe and I have created practice exercises for a lot of the concepts taught in this course. When we learn a new technology, it's always helpful to be able to practice what we're learning. While it's certainly helpful to your learning to follow along and create the demo application that's demonstrated in this course, there is a lot of valuable learning that can come from trying to do something without having all of the answers provided beforehand. We seem to really cement our learning when we have to figure out why something we've done isn't working like we'd expect. It helps to break down misconceptions in our learning. So, for many of the clips in this course, we've created related practice exercises on Plunker. The's practice exercises are all available on my website at this URL, and we'll let you know at the end of each clip if that clip has a corresponding practice exercise. You can then find the practice exercise on this page, which is organized by course module and then by clip. For each exercise, you'll find a link to the clip in the course, a link to the Plunker exercise, and a link to the finished example for you to compare against when you're done or for you to use to get clues from. So if I click on one of these practice exercises, notice that it takes me to Plunker, and the instructions for this exercise can be found here. Read these carefully, and you should be able to finish the exercise with what you just learned in the course. And you can get back to these instructions at any time by clicking this button over here. If you're not familiar with Plunker, here's how it works. Here are all the files for this Plunk. You can just click on these files to edit them or add new files in order to complete the exercise. Notice that to put a file into a subfolder, you just name that file with the folder name followed by a slash. Then to try out your project, you just click Run. Notice when I run this that Plunker just displays my running site here, starting with the index.html like a normal web server would. And depending on the exercise, you'll see something different here, and the app may be broken and you'll have to fix it. Or it may be working, and you'll just need to change something about it to finish the exercise. And if you get stuck or just want to compare your solution to our solution, you can come back to the list of exercises and click on this finished link to see our finished version of this exercise. We hope you'll enjoy these fun little exercises, and hopefully they'll help you cement what you're learning in this course.

Introduction to TypeScript
We'll be doing very little TypeScript in this course, but we will be using some, and it will be helpful for you to understand a few TypeScript concepts. Let's take a look at a high‑level overview of what TypeScript is. First of all, TypeScript is a superset of JavaScript. That means anything that you can do in JavaScript, you can also do in TypeScript using the exact same syntax. But it also means that there are additional features that are available for use. So how is this accomplished? It is accomplished using transpilation. So when you write your TypeScript code, you're using a mixture of plain JavaScript plus TypeScript features. Then your build process runs the TypeScript compiler and transpiles all the TypeScript code into plain JavaScript code. That's an important part about TypeScript. Your TypeScript code is only a development environment construct. TypeScript doesn't give you anything in production that you couldn't have accomplished with plain old JavaScript. It simply gives you more options for how you want to code and think about your code. It is basically syntactic sugar that is enforced via a transpilation process. So there is a TypeScript compiler that you run that handles this transpilation, and if you write any code that violates the rules of TypeScript, the compiler will emit an error and fail to do the transpilation. So it gives you some development time or build time checking that helps to prevent some runtime errors. One nice thing about TypeScript is you can use as little or as much TypeScript as you want. Really, you could write all JavaScript and pass it through a TypeScript compiler, and it would work just fine, but of course there's no point in using the TypeScript compiler at that point. Again, we won't be using a lot of TypeScript in this course, so let's just take a quick look at the few TypeScript features that we'll be using. This includes static typing, interfaces, class properties, and accessibility levels such as public and private. So let's look first at static typing. Static typing allows us to specify data types for variables, properties, and parameters, etc. In plain JavaScript, we declare variables like this. Adding typing with TypeScript is as simple as adding data types to the variable declarations like this. With this in place, if you were to try to set any of these to an invalid value, for example, setting age to a string value, your TypeScript compiler would throw on error and fail to transpile, catching potential bugs earlier in the process. And that's all there is to typing in TypeScript, and you can use as much or as little as you'd like. Taking typing a little bit further, you can actually define interfaces for entire objects, and that will enforce the shape of objects. So if we wanted to ensure that all cats had a string name property and a numeric age property, we could create an interface like this. And then you could declare variables of this type like this. Given this declaration, we will get compile time safety if we try to assign an object to fluffy that does not include these fields with these types. So let's take a look at some examples that would fail to compile. First there's this example. This one would fail because age is set to a string value instead of to a number. Let's take a look at another example. This example would fail to compile because we have not provided an age property. If we want the age property to be optional, we could add a question mark to the interface declaration for the age property like this, and now this example would work just fine. And, again, you can choose whether to use interfaces or not when doing Angular development, but we will be using a few of them in our course. Now let's take a look at TypeScript class properties. Given a simple ES2015 class like this, we can initialize the name of a cat in the constructor like this. This is just plain ES2015, not TypeScript, but we can make it more explicit that we have a name property by declaring it here. Adding this didn't really change any functionality, but it's more explicit. We can more easily see that our cat has a name property. We could also define properties that are not initialized in the constructor like this, and actually the types are not required. I could just declare these properties like this, and that works just fine. We just don't get any compile time type safety on those properties. Now that we have these properties, you may wonder where these properties are accessible from. For that, let's take a look at our final TypeScript topic, public and private accessibility. Take a look at this class. We basically have three members on this class, the name property, the color property, and the speak function. Of course, we can access all of these internally in the class, so I could access the name property in the speak function like this. I could also access the speak function from other functions in this class. However, as defined here, these three members are also accessible outside of the Cat class. That's because class members are public by default in both ES2015 and TypeScript. I'm going to simplify this class a little bit just to give us a little more room to type. So let's say I create a new Cat here, I can now access the class members outside of the class like this. So what if I wanted any of these members to be private, meaning I want to be able to access them from within the class, but not externally? Well, I can just preface them with the private keyword like this. Now I'll get compile time errors if I try to access them here. And that's all there is to making things private. Remember, class members are public by default, and you have to explicitly mark them as private if you want them to be accessible only within the class. Now let's take a look at one last use case for private members that's pretty common. Consider this class, it's pretty common to receive values as parameters in the constructor like this, and then set corresponding private member properties to the values passed in like this. Since this is so common, TypeScript has created a shortcut for all of this that looks like this. Notice how much this simplifies this common practice. There's not even any assignment code in the constructor. The TypeScript transpilation is going to just generate code for us based on the fact that we marked these parameters is private. We'd call this constructor the same way like this. So it's not that these constructor parameters are actually private, obviously we can still access them externally to pass values in, it's just a shorthand for creating private properties that are initialized via the constructor. We'll use this a number of places in the course. And that covers pretty much everything that we'll be doing with TypeScript in this course.

Comparing Angular to AngularJS
When the Angular team released Angular 2, it was a dramatic shift from Angular 1, and now they have different product names. All Angular 1.x versions are now referred to as AngularJS, and all versions starting at Angular 2 and above are referred to as Angular. Let's take a quick look at a couple of high‑level differences between AngularJS and Angular. Angular 1 was pretty much an MVC, or model‑view‑controller, framework. Angular 2 and above kind of departs a little bit from that, although it's not difficult to relate the concepts together. In AngularJS, you had a view or a template, and the view would refer to a controller, and your controller would expose models or objects that represented your data. In Angular, you have a component, and that component has an associated template. And, as with Angular 1, you have models that represent your data. So at a glance, you can kind of relate these together. However, in Angular 1, the template was kind of in control. Your template would identify one or more controllers that controlled sections of your page, whereas in Angular, components and templates really are one to one. In fact, you can kind of consider the template to be a part of the component, and you can actually write your code like this and have your HTML right inside your component if you choose. In this way, a component in Angular is actually more comparable to a directive in Angular 1. In Angular 1, you could define a directive that allowed you to basically create custom HTML elements, which encapsulated both display and functionality in a more cohesive unit. If you wanted a sortable list component that let you display an array in a stylized table with sortable columns, you could just create a directive that gave you a sortable list element. And the directive contained all the logic and HTML to make it all come together. Something about the directive bringing it all together made it feel very cohesive. That's basically what components are, except it feels a lot smoother. As awesome as directives were, they often felt clunky, and you'd run into weird edge cases that were quite difficult to solve. Components feel much more smooth.

A Conceptual Overview of Angular
Okay, we're going to dive into code real quick here. But first, let's take a high‑level look at Angular. Once we understand the conceptual model of how Angular works, it will be easier to understand each of the pieces as we start coding them. So let's take a graphical look at an Angular application. When you navigate to the URL of an Angular application, there is always a root application component that is loaded first. And then the Angular router takes a look at the URL and says oh, I have a component that matches that route, and it loads that component. The component's template is then displayed in the browser, and the component may then load some data from the server and give it to the template to be displayed. Of course, if this page is very complex, it's likely to be composed of lots of smaller components. And those components may be composed of other components. And so this kind of ends up creating a tree‑like structure. It's helpful sometimes to think about your Angular app in this way. So here's the tree view of our imaginary application. Now imagine what happens if a user navigates to another URL. Well, then basically, you start a new tree, except that your app component remains. The router sees the new route and loads the corresponding component and all of its subcomponents. And this repeats for all of your routes. As your application gets bigger and bigger, this can become a lot of stuff to load into memory. This is where Angular modules come in. Don't confuse Angular modules or NgModule with ES2015 modules that we've been talking about before. Angular modules are meant to be containers that group all of these routes or component trees and their corresponding bits of code into modules that can be loaded independently of each other. That way, if a user only ends up visiting this section of the site, only these files will get loaded, and the browser will only load these other files if the user navigates over into this section of the site. This is one of the main purposes behind Angular modules. You don't have to use multiple modules in your app, but as your app gets larger, you may consider it. One more high‑level concept regarding modules that is important to mention is how modules are used to make components, services, and directives available to the rest of your application. When you create a component, service, directive, or pipe, you register it within a module. That makes that object available for use by everything else in that module. And with all of these, except for services, they are now only available in that module. If you want to use them in another module, you must register them with that module also. That's true for all of these, except for services. Services or providers get registered in the root injector, so they're available across Angular modules. So that's kind of our high‑level view of Angular applications. Let's take a look at what we'll actually be building in this course.

Here's What We'll Be Building
Okay, let's take a quick look at the demo app we'll be building in this course. We'll build an application that displays and allows users to create technology events or conferences. The starting page is this page that lists all of the upcoming events. From here, we'll add the ability for users to create new events using this Create Event form, complete with validation. And then we'll wire things up so that users can click on one of these events to see more detailed information about that event. This page displays sessions for the event, and users can vote on the sessions that they like. You can even create a new session for the event. And we'll even add the ability to sort and filter the sessions to find what you're looking for. We'll also add in some basic authentication and edit profile features. If this app looks familiar to you, you may have watched the Angular 1 Fundamentals course. This is the same application that we built in that course, which gives you the ability to compare how things used to be done with Angular JS and how they're now done with Angular. So without further ado, let's start writing some code.

Installing Git and Node
We're going to need a few tools installed to get going. First, we'll need Git installed. I'm on Windows, so I'm going to use Git for Windows, which can be downloaded from here. If you're on a Mac, you can install SCM Git from here. And if you're on Linux, you can just run a command like this one from the terminal. I'll go ahead and download and install Git for Windows, and then I'll run that and I'll just use the defaults throughout the install. And now that that's installed, I have this new Git Bash console that I can run. So we'll use that in a minute. And actually, while I prefer to use this Bash console, sometimes Windows users have issues with it, so if you're getting weird errors, try using the Windows console window instead. The next thing I need is Node. I prefer to install Node using Node Version Manager just because it makes it easier to switch between versions of Node as I develop different applications. On Windows, I can download that from here. For Linux and Mac, you can just run this command from the terminal. Of course, these each have their own README with instructions about installing them, so you may want to read through those for your environment first, but I'm going to go ahead and install this on my system. And I'll just use all the default options here, too. Okay, now that that's installed, I'm going to open my Git Bash console. On Windows, be sure to open it as administrator. Okay, now that I have nvm installed, I can just run nvm install and then the version of Node that you want to install. It's recommended that you use this version for this course if you're following along to avoid any compatibility issues. And now I can just tell nvm to use this version of Node. Okay, we're good to go with Git and Node now. If you have problems using nvm to install Node, you can try installing it directly from here, just choose the correct installer for your system. Okay, let's get coding.

Getting Started with the Angular CLI
Okay, so here's the Git Bash console that we just installed. The best way to get started with a new Angular project is to use the Angular CLI. The Angular CLI is a command line interface that we can use to create a new project, complete with webpack config and tools for packaging up your app for production, plus a host of other features. It's highly recommended that you always start your projects with the CLI. So to get started, let's install the Angular CLI. We can do that with npm, like this. This will install the Angular CLI globally so that we can use it to create new projects. And in order to avoid any issues for those who are following along, we're going to install a specific version of the CLI, like this. We recommend that you use this version of the CLI if you're following along just to avoid any surprises with new versions. Okay, now that that's installed, we can create our new project, like this. So this will create a new folder named ng‑fundamentals, and it will generate a new Angular project with webpack and everything we need to build for production. So let's go ahead and do that. Now, depending on your environment and due to an apparent bug in the CLI, you may or may not be presented with a couple of questions, like these here. If you are, just say no to adding Angular routing and choose CSS for the stylesheet format. We'll add those things later. As you can see though, in my environment, I didn't even get prompted, which is fine. Okay, now that that's complete, let's go take a look at what it generated. So I've opened up that new folder in Visual Studio Code here, and here's the project the CLI created for us. So notice that it created a number of things, including a package.json file and this angular.json file. This file is used for configuring a number of settings for our project that the CLI will use for various things, including its webpack builds, and it created this end‑to‑end testing folder and installed some npm packages for us. And then if we look at this src folder that it also created, you can see that it created this app folder. This is where you'll do most of your coding in an Angular project. And it also created this assets folder. This is where you put static assets like images and site‑wide CSS files, etc. We'll take a look at this in a minute. For now, let's go make some small changes to this package.json file. You can see we're installing approximate versions of our dependencies. For the purposes of this course only, I want to pin these exact dependency versions so that anyone following along won't get surprised by any dependency version changes. So I've already created a package.json file with the exact pinned versions that were installed by npm at the time this course was written. In order to make this easy, we've created a little GitHub repo for this course where we can grab a few files like this throughout the course. It's available at this URL here. So you can see down here that we have this package.json file. So I'll click on that and then look at the raw version here and then copy everything out of here. And then, I'm just going to paste that in here. Okay, so you can see that the versions here are now specific versions and we're not using the carets and tildes anymore so that we'll always install these specific versions. Now we just want to do one more thing to ensure that you're definitely working with the same package versions that we are in this course. Over here, you can see that we also have a package‑lock.json file. Let's grab that, too. So let's look at the raw version and then copy that, and then we'll come over here and we'll open up our package‑lock.json file here and select everything and then paste over the top of it. Now, there's just one last thing that we need to do in order to make sure that you're using the same package versions. If we come back over to our terminal window where we created our project with the CLI, let's go ahead and move into the folder that it created. And now, we're going to delete the npm packages from our node_modules folder and then we'll reinstall them. Again, all of this that we're doing with the package.json files and reinstalling the npm packages isn't necessary for normal development. This is just to make sure that those that are following along with this course don't get hung up if some dependency makes a breaking change. Okay, so now that we've deleted those packages, let's go ahead and reinstall them. Okay, excellent. So now we're back at the point where we've generated a project with the CLI and our package versions are locked in. So now all we need to do is run it. We can do that like this. Okay, so you can see that this is now running at port 4200, so let's go check that out. So over here my browser, I'm just going to navigate to localhost:4200, and here you can see that we have a fully functioning app and it just generated this default boilerplate HTML. Now let's go take a deeper look at what the CLI did to get our new Angular app bootstrapped.

Bootstrapping an Angular App
As we saw in our last clip, the Angular CLI created a fully‑functioning Angular app, including everything needed to Bootstrap this app. But it's really helpful to understand how an Angular app is Bootstrapped, so let's dig into that a little bit. We talked earlier about the hierarchical component tree, and at the top of that component tree is the app.component. And as you can see, the CLI created our app.component for us here. Notice that the component is composed of three files, the component, its template, and its styles. We'll talk in depth about components in the next model. Just be aware that the template from this app.component is what's being displayed when we load our site. So let's look at how that's wired up. The Bootstrapping of our app begins with this main.ts file. And if we look over here in our angular.json file, you can see that this main property is pointing to our main.ts file. This is used by the webpack.config for our site, and it causes this main.ts file to be loaded when our app first loads. And you can see right here that we are Bootstrapping our app with our AppModule. if you remember from earlier, Angular applications are grouped into models, and every Angular application has an AppModule. That module is defined here, and you can see that the AppModule is Bootstrapped with the AppComponent. So that's how Angular knows about our AppComponent. But there's one more piece. This makes Angular aware of our component, but we haven't seen yet where we tell Angular to actually display this component. If we look at our AppComponent, you can see that it has this app‑root selector. This selector defines the HTML tag to use in order to display this component. And if we look over here in this index.html file, you can see that we're using that app‑root selector right here. This index.html file is what is first displayed when our app loads, and it is loading our AppComponent. So that's how this all comes together. Now to show that there's nothing magical about the naming of this AppComponent, let's just rename this to eventsapp.component. Remember our app that we're building is a website that will allow users to find technology events. So we'll call this the eventsapp.component. And instead of renaming its template and CSS files, we can just inline them. We'll talk more about this later, but let's just delete this template file and this CSS file. There wasn't anything in here anyhow. And then here in the component, let's just change this selector to events‑app, and then we'll change templateUrl to just template, and hard code some basic HTML here. And then since we're not applying any styles to this component, we'll just delete the styles. The CLI also created this specs file, but Joe will talk about testing later in the course. And so for now, we'll just delete that. And finally, let's just rename the Component class to events EventsAppComponent. Okay, now that that's done, we just need to go update a few places that reference this component. So first in the app.module,, we need to fix this import, so this will be EventsAppComponent, and we'll import that from events‑app.component, and then we need to declare that and Bootstrap our app with it. So notice there's nothing convention based about the name of the AppComponent. It's really here that we tell Angular which component is our main top‑level AppComponent. And then one last place we need to update is over here in our index.html because we changed the selector. So this is going to be events‑app. Okay, cool. So now if we go check out our site, you can see that it's still working, and now it's using our new template. So to recap the whole bootstrap process, the main.ts file is loaded by webpack via the angular.json file. Then the main.ts file loads our app.module, and that makes Angular aware of our AppComponent. Then our index.html file is loaded in our browser, and it loads our app.component,, which uses this template here, and that's it. So that's the basics of how to Bootstrap an Angular app. Next, we'll take a look at how to pull in some static resources into our site.

A Brief Look at the App Module
You'll get some more experience with modules as we add different components, services, directives, and pipes to our app throughout this course. But since the CLI created an AppModule for us, let's take a brief look at it. We talked in an earlier clip about the purpose of modules. This is our first chance to see what one actually looks like. Specifically, I just want to mention these three sections, declarations, imports, and providers. When you want to add a component pipe or directive, you must declare them here like we're doing with the EventsAppComponent. Services, however, are added as providers here, and this imports array is used for importing other modules. Importing a module makes all of its exported declarations and providers available to this module. So you can see we're importing Angular's BrowserModule here. This makes a number of core Angular services and directives available to us that are commonly used throughout the Angular app. Pretty much every Angular app will import this in the AppModule. If you create a service component pipe or directive, you need to be sure to add it to a module before you try to use it. You'll get some experience with this and with creating other modules like feature models as you explore this course. I also explore, in depth, the different types of modules you can create in my Angular Best Practices course. So feel free to check that out if you find yourself wanting to learn more about modules after this course. For now, let's delete this providers array since we don't currently have any services. We'll add this back later. And I kind of like to have imports at the top here since declarations and other things depend on those imports. There's no real technical reason for doing this. This is just a personal preference. Okay, cool, so that's our AppModule. Now let's go take a look at how to use static assets in our site.

Accessing Static Files
Now that we have a basic site set up and running, let's take a look at how to access some static files like images and site‑wide CSS files. Then we'll be ready to really jump into building our Angular app. Let's start by looking at how we'd access an image file. The Angular CLI has created this assets folder, and this is where we put our static files. So let's create an images folder. Okay, now we need some images. For those who are following along with building this project, we've created a GitHub repo where we'll grab some files from throughout this course. It's available here at this URL. So inside this source folder, you can see that we have this assets/images folder. We just need to click on each one of these, and then click Download, and then Save image as. And then we'll just save that in this assets/images folder. And then I'll go ahead and download the rest of these files off camera. If you're following along, go ahead and download each one of these. Okay, so now I have all of these images downloaded here and put in this assets/images folder. So let's go ahead and add one of those to our app component. So over here in app in our events‑app.component, and let's change this to a template string so we can add a new line, and we'll just add an image tag. And we'll go ahead and set the source to the assets folder, /images/basic‑shield.png. And if we go look at our site, there we go, we can see that that image is showing there. Now, it's important to understand what exactly happened here. First of all, if we take a look at our image source, what is this path relative to? Well, it's relative to the index.html file, but you can't statically access any file that is relative to the index.html file. Webpack needs to know which files to bundle up when it builds the app. So the only reason why this is working is because if you look in our angular.json file, by default, the assets folder is included in our assets array. This array is an array of paths that we'd like webpack to include in our app bundle, and these paths are relative to our angular.json file, or the root of our site, and that's how you make files statically available to your app. This makes sense for static files like images, but for static, CSS, and JavaScript files, there's a different convention. Notice down here that we have styles and scripts arrays. This is a place to reference styles and scripts that you'd like loaded with your app. Notice that by default it is loading this styles.css file. If we go take a look at that file, you can see it's empty, but we do have some site‑wide styles we want. To avoid typing those in, let's go grab them from our helper repo. So in this src folder, we have this styles.css file. If we click on that and then click on Raw, we can copy all of that out, and we'll just paste that in here. So these are some styles that we'll be using throughout the course. Okay, cool. So since this styles.css file is referenced from our styles array in our Angular CLI JSON file, these styles will now be loaded globally. So notice if I change the background color to black for the body and then go over and refresh my app, there we go, we can see that the background color is now black. All right, cool. Let's go and remove that. And now let's take a look at how to load some third party vendor styles and scripts. We've actually created an npm package for use with this course that will give us some Twitter Bootstrap CSS styling. Twitter Bootstrap is a CSS library, and we've created an npm module that has some specific styles that we want for this course. So if we go over to our terminal and stop our server here, we can install that like this. So this is an npm package that we created. Okay, cool. Now, if we go look in our node_modules folder, in addition to that ngf‑bootstrap folder, we also have a bootstrap folder. So that was a dependency of ngf‑bootstrap. And we have a jQuery folder. So, jQuery is also a dependency of that. I want to be clear here that jQuery is not required for Angular development. This is just part of that ngf‑bootstrap package that we pulled in. So there are a few files from here that we want to use, so go ahead and start up our server and come back over to Visual Studio Code. We want to load some things from those directories that we just installed. So if we go back over to our Angular CLI JSON file, then let's add above our styles.css, let's add node_modules ngf‑bootstrap. Then in the dist folder, there is a bootstrap.min.css. Okay, so this will load that CSS file. And then we want a script file from Bootstrap, and that's also in the dist folder, and in the js folder, there's a bootstrap.js file. And then Bootstrap uses jQuery for some of its menus, so let's grab that also. Okay, and since this is a change to our webpack config, which is a server‑side thing, we need to stop and restart our server. And then if we go look at our app, cool, you can see that the background color of our site has changed. This is because we're now getting our Bootstrap styling. And let's add a little bit of padding to our site. We can do that by adding a Bootstrap container. So, over here in our index.html, we can just on the body add a class container. So that's a Bootstrap class. Okay, now if we go look at our site, there we go, now our site has some nice padding. So now you know how to load static files in your Angular apps. Now, let's get to the real fun. Let's go create our first component.

Summary
In this module, we explored some of the prerequisites for this course, and then we took a look at a conceptual overview of how Angular apps are architected. We then looked at the Angular CLI and how to use it to create new Angular apps. We also explored the app component created by the CLI and how the CLI Bootstrapped our Angular app. And finally, we learned how to pull static assets into our app. All of this sets us up really well to get started building our demo app and exploring Angular. In the next module, we'll learn the fundamentals of Angular components as we start creating our own components, and explore a host of concepts related to creating, styling, and communicating between components.

Creating and Communicating Between Angular Components
Introduction
In this module, we're really going to get into the meat of components. This is where working with Angular really starts to get interesting. We'll start by creating a component with an inline template and data binding, and then we'll take a look at how to optionally move that template into an external HTML file. Next, we'll explore the various ways to communicate between components, and then we'll see how easy it is to apply CSS styling to our components. And finally, we'll explore how Angular provides built‑in encapsulation of CSS styles to prevent them from bleeding out to other components. So let's jump right in.

Creating Your First Data-bound Component
Okay, so we've created our first Hello World component, but that isn't a terribly interesting component. In this module, we'll really start having some fun as we get into the meat of using components. In just a few minutes, we will have created a component that starts to demonstrate the power of Angular. To demonstrate this, we're going to create a page in our app that displays all of the upcoming events. So let's get started. Okay, so I'm going to create an events folder in my app folder. And this will hold everything used to display and work with events in our app. And then let's create our events‑list.component. Eventually, this will display all of our events, but to get started, let's just get it displaying a single event. This will be a great canvas to demonstrate some really cool, basic, Angular functionality. So just like we did with our last component, we will need a class that will eventually contain all of the business logic for this component. We'll call this our EventLstComponent. And of course, we're going to need to import our Component decorator and decorator class with it, okay, and this will just have a selector of events‑list. Now we just need to define the HTML content for this component. To get started, let's just display a title, we could do that like this. But that HTML is really hard to read, so to make our HTML easier to read, we're going to change this into a JavaScript string literal like this. We'll change these apostrophes to back ticks, and now we can have multi‑line HTML. If you're not familiar with string literals, they were added to JavaScript in the ES6 specification, and in addition to some other functionality, they allow you to define multi‑line strings like we have here. This allows us to create a much more legible HTML in our components. Okay, so now we have this basic component that we can start adding some interesting functionality to. Let's just wire this up so that we can see it working. To do that, let's open up our events‑app.component, and instead of displaying Hello World, let's pull in our component. So we've created our component, and we're pulling it into this page, or this other component, and it feels like that would be enough, but really we're missing one step. Let's go take a look at our page real quick. First, we'll make sure that our server is running, and that will compile our TypeScript for us. And now let's go take a look at our site. So if I refresh, notice that Hello World is gone, but our new component isn't showing up. This can be a kind of frustrating state. It seems like we've done everything right, but if we look at our console, you can see that there is an error here saying that events‑list is not a known element. Remember, we have to register all of our components with our module, and we haven't done that yet, so let's go do that. So over here in our module, we need to add our new component to our list of declarations, and of course we'll have to import that. Okay, let's save everything here and take a look at that. So if I refresh here, there we go, now are EventsAppComponent is referencing our EventsListComponent, and that EventsListComponent is being displayed here. Cool. Now let's go make it do something more interesting. First, let's create some sample data that will represent the data that we'll eventually get from an API. For now, we'll just add that data as a field to our class like this. Okay, so now we have an events object that has fields like name, date, price, etc. Now we just need to update our HTML to access that data, and we'll do that right here in our inline template. Let's start by displaying the name of the event. First, I'll add a little divider after our heading, and then we'll display the event name like this. Those of you who have done development in Angular 1 will immediately recognize this double braces notation, this is interpolation, and it represents a one‑way binding. When you put something inside these double braces, Angular will look for that object on the component. So in this case, Angular is going to look for the EventsListComponent class and expect to find an object named event. And it will find one because we've created it here. And then it's going to expect to find a property called name on that object, and it should find that here. So let's take a look at that. Awesome, you can see here that we're now binding to our event and displaying the event name. Now let's display the rest of the properties like this. So we're just going to use some Bootstrap classes here to give our event a little bit of styling, and then we're just going to start displaying each of the properties on the event. So let's move this down here, and actually we don't need two of these, and then we'll just display the rest of this data. And then we need to escape this dollar sign because we're using a string literal, and dollar sign curly brace is a syntax that's specific to string literals, and so we have to escape that dollar sign. Okay, now, if we go refresh our page, you can see that we're displaying all of our event data. That was easy. Hopefully you're already beginning to see how quickly you can build applications with Angular. There's a lot more to learn, but Angular really does make building applications easy. So we're starting to get a fair amount of HTML in our template here, and we had to do something weird here where we had to escape the dollar sign. In a later part of the course, Joe will talk about Angular pipes, and that will take care of our currency formatting, and we won't need this dollar sign here. But still, this template's starting to feel like it's getting a little bit bigger, and you may want to move this HTML out of your component. In the next clip, we'll take a look at how we can have our template files separate from our component files. And there's a practice exercise for this clip, so go check that out.

Using External Templates
Okay, now let's see how we can move our template HTML out into its own file. For very simple components, it's really nice to have the HTML right in the component, but often there's enough HTML that it's easier to have it in its own file. So let's create an events‑list.component.html file right here next to the component. Then, we'll copy this HTML out of here and into our HTML file. And since this is no longer in a string literal, we don't need to escape our dollar sign anymore. Now in our component, instead of using template, we just need to do use templateUrl, and then we just provide the URL here to our template. And notice, this URL is relative to our component. And now if we go take a look, our app should look the same. There we go. It looks exactly the same, except now we're loading our HTML from a separate template file.

Communicating with Child Components Using @Input
Okay, so you can see how creating little components like this is pretty easy. Breaking our app up into lots of little components will make our application well organized and easy to maintain, but it won't be very useful unless we know how to communicate between them by passing data and events back and forth. In this clip, we'll learn how to pass data from one component into a child component. Before we jump into this, I want to call out a small inconsistency you might be noticing starting with this clip. If you take a look at the File Explorer over here, you may notice that the files here look a little different from the last clip and they don't match what was generated from the CLI. For example, this app directory is not nested inside a source directory. This is because when this course was first created, the Angular CLI was still in its infancy and we've since updated the course. Since all of our development for the rest of this course will pretty much all happen inside this app folder, there is no real need for us to update this file tree for the rest of the clips. Don't worry much about that inconsistency. If you're following along, stick with the file structure you've already built up from the CLI. Okay, so let's take a look at component communication. Right now, our events‑list.component is only displaying a single event, but we'll eventually change this to display multiple events. So to make things a little more organized, let's create a new event thumbnail component that will encapsulate all the display logic for a single event like this. And then our events‑list.component can just worry about showing multiple of these event thumbnail components. Okay, so let's create that event‑thumbnail.component. And now let's add the basic component code. Okay, so there is our basic component, and since this HTML is pretty straightforward, let's just put it inline in the component, and then we'll have to escape this dollar sign again. Okay, so now we have this component, and it's all built to bind to an event object, but the question is, where is this event object going to come from? Our events‑list.component is going to eventually contain a list of events, and it will want to create one of these components for every event. That means that the event data is going to come from the events‑list.component. So how do we pass that data in? Well, first of all, we need an event object in our class that our template can bind to. With TypeScript, we can declare that as a public property of our component like this. This is just creating a property called event and telling TypeScript that it is of type any, which is really just saying we don't care what data type it is. Later in the course, we'll start giving our variables data types so that we can take advantage of TypeScript's type safety and IntelliSense, but for now, any will suffice. So now we have this variable here, but there is nothing here that tells Angular to expect a value to be passed into our component. That's where the input decorator comes in. So let's import that and that comes from Angular Core 2. And now we can just add that decorator to our Event property like this. So this input decorator tells Angular that this event will be passed in from another component, and don't confuse the word event with JavaScript events. Again, this is just an event like a technology event or a conference. So let's go see how we pass in this event to our component. So we'll go back over to our event‑list.component and let's just take this HTML out of here and put it back in line in our component because it's very basic. Okay, so we don't need this empty HTML file anymore so let's delete that. And now our event‑list.component needs to display an event‑thumbnail component and we can just do that like this. So that matches the selector that we added to our thumbnail component. And again right now, this is still just displaying a single event, but we'll update this later to show multiple events. But we still aren't passing the event data into this component. Well, that's super easy. All we have to do is add an attribute like this. Okay, so we have too many things called event here and it's going to be hard to talk about, so let's rename one of our events to event1, so I'll rename this here to event1, which means we have to rename this 1 to event1. So these two values correspond to each other, and this event corresponds to our Input property over here. So when we add brackets around an HTML element like this, what we're saying is that this event thumbnail has an input parameter named event and we want to pass the value of event1 from this component into that component. So it's important that this matches the name of an input parameter and that this matches the name of a member in our component. You may think it's odd to have an HTML attribute that has brackets in it, but this is actually valid HTML. The HTML spec does allow for special characters like brackets in attribute names. We'll talk more about these brackets and lots of others syntax items in the next module on template syntax. But for now, that pretty much covers wiring up these two components with each other, except that we've forgotten to declare our new subcomponent as a component in our module declarations, so let's go do that now. So we need to import it, okay, and then we just need to add that to our list of declarations down here. Okay, so we're all wired up. Let's go take a look. First, let's go take a look at our batch console where we're running our server. So notice that our server is running in watch mode, so it is constantly watching for any changes and recompiling our TypeScript for us. If I scroll up, you can see it has recompiled multiple times as I've been saving changes. So let's go take a look at our app now. If I refresh this, there we go. So it looks exactly how it did before, but now this event thumbnail is coming from a different component, and it's getting its data passed into it from its parent's component through an input parameter. So it's pretty easy to pass data from one component to another. You simply create an input parameter or property on a component, and then in your HTML, you pass that in using the square bracket binding. Alright, in the next clip, we'll see how to pass data out of our child component back to the parent. And there is a practice exercise for this clip, so go check that out.

Communicating with Parent Components Using @Output
Okay, so you've seen how to pass data into a child component, but what if you want to pass data back out to the parent? We'll demonstrate how to do that here, and then you'll get some good opportunities to use component input and output throughout the course. When you think about component input and output, it's pretty common that input parameters are used when constructing a child component in order to give that child component its data. Output, on the other hand, is quite often used in response to some event within a child component so that the parent can receive some information when some event, like a click, occurs within the child component. At this point in our application, there's not much for our child component to do, but we'll demonstrate here the basics of how to use output parameters, and then you'll get more practice with some examples later in the course. Okay, to demonstrate this, we'll just add a button on the thumbnail component, and we'll add a click handler to this. Okay, we haven't talked about this type of binding, and we'll talk about it more in a later clip, but basically, this is just wiring up the click on a button to a function called handleClickMe on our component that we haven't created yet. Okay, so let's just go add that function to our component. And for now, let's just console.log something. All right, let's just go take a look at this so you can see that that click handler works. If I open my console and click on my button, there, it says clicked! Okay, that's working. But we're still not doing anything to tell our parent component that anything happened. In order to do that, we're going to have to add an Output property to our child component, like this. Okay, so we've decorated this eventClick property with the Output decorator, and we're setting it to a new EventEmitter. This is a very common pattern you'll see with Output parameters since typically Output parameters are used to convey some event that has occurred. Don't confuse the word Event here with our events application. The word Event here is about JavaScript events, and this EventEmitter is an Angular thing. So let's import the Output decorator and the EventEmitter, and now let's emit an event with this EventEmitter each time the button is clicked. And then we can pass a bit of data along with this event too. For now, let's just emit the string foo. All right, so this component is now outputting this data when the button is clicked. Let's go make our parent listen to that. We just do that by adding another event handler to the child component's element in our parent component, like this. So this eventClick binding has to match the eventClick Output property that we created on our child component here. Basically, we're saying that when the eventClick event is fired on our event‑thumbnail component, call this handleEventClicked method on my component. This $event refers to the data emitted with our event. And remember, in this case, it is the string foo. You can only pass along a single value with an event emitter, so if you need to send multiple values, you can just wrap them in an object first. So let's go ahead and add this handleEventClicked method, and we'll just console.log the data that we received. Okay, let's go save our files here, and then let's go take a look at it. So if I refresh and open the console, now if I click my button, there we go. Notice it says received: foo. So that value foo is what we emitted from our child component, and then we console.log that out in our parent component by binding to the eventClick Output property. We can make this a little bit more interesting by emitting some actual data from our child component, such as the name of the technology event that's being displayed in the event‑thumbnail. So let's come over here, and here we're receiving in our conference event, and that has a name property on it. So let's just love that out. All right, let's take a look at that. So if I refresh this now, now if I click on this, notice it says received: Angular Connect, which is the name of our event that we're displaying in our event‑thumbnail component. Okay, so that's all there is to passing data back to the parent component from a child component, and you'll get some great opportunities to practice using this later in the course with some real data that makes more sense. For now, we're not going to need this demo code, so let's get rid of this handleClickMe event handler and the Output parameter. And we'll get rid of the button. And then over in our parent component, we'll stop handling the event and get rid of the event handler down here. Okay, so that's all cleaned up. And again, you'll get a chance to practice this a little bit more later in the course. And there's a practice exercise for this clip, so go check that out.

Using Template Variables to Interact with Child Components
Okay, so we've covered how to communicate in and out of components using input and output properties, but there's one more way that we can use to access public properties and methods of a child component, and that can be quite useful for different use cases. This approach can be used to call methods on a child component or to bind to data in a child component. And we can accomplish this using template reference variables. Template reference variables allow you to specify a variable name that points to a component, and then you can access any public properties or methods on that component using that variable. So let's check this out. Let's add a variable name to our event thumbnail component, and we'll just call it a thumbnail, like this. Now this variable is available for us to use anywhere else in our template. So let's go create a public method on our child component that we can call. So over here in our thumbnail component, we'll just create a method called logFoo. And, of course, that will just log foo. Alright, now back in our parent component, let's just add a button that when we click on, it can call this new method on our child component. We'll just add that right here. And then we're going to wire up our click event to our thumbnail local variable, which is a pointer to a component, and so we can call the logFoo method on that component. Okay, let's save everything. And then let's go check that out. I'll refresh and there's my button, and this is on my parent component. If I open up the console and then click this button, you can see that it logged the word foo. And so we were able to call thumbnail.logFoo and thumbnail is pointing to our event thumbnail component, and over in our EventThumbnailComponent, this is where we actually logged foo. So you can see, this is actually a public method on our EventThumbnailComponent, and you can see how we're able to access that using a reference variable. I really like how straightforward that is. In some ways, this is more simple than input and output parameters, and there's another use case where we can use this template variable, and that is if we want the parent to bind to a public property on our child component. So let's add a property on the thumbnail component. We'll just add that right here and we'll just call it someProperty. And let's just set that to a string. And now we can access that someProperty property over in our parent component using our template variable. So let's add an h3 here, and then we'll just bind directly to this with interpolation. So again, here we're using our thumbnail local variable, and we're going to access some property. Okay, let's go check this out. Alright, you can see that some value is being written out here to our parent component, even though that value is in our child component, and we can access that using our thumbnail template variable. Okay, so those are the three different ways that you can handle inter‑component communication; input properties, output properties, and template variables. And we're not going to need this template variable stuff. So let's just go ahead and clean that up and we'll clean it up over here in our child component, too. Okay, that's all there is to local variables. And there's a practice exercise for this clip so go check that out.

Styling Components
Let's take a look at how we can apply CSS styles to a component. Typically, when you want to apply styles to a web app, you'll create CSS files that contain your styles, and there are lots of different approaches to doing this in a maintainable way. With Angular, you can still handle CSS as you would with any other app, but Angular components have some built‑in functionality for applying styles to your component that can be very useful. First, let's look at applying some simple styling to our event‑thumbnail component. If we take a look at our template, you can see here that we're using a non‑breaking space to add some blank space between the address and the city. Let's use a class to style that instead. So let's delete that non‑breaking space and add a pad‑left class to the city span. Now in our component, we'll add a styles array to the component config. The styles array takes an array of strings, but typically you'll just provide a single string with all the styles for your component. So let's add our pad‑left class here. Cool! Let's go take a look at that. Okay, here's the current padding with the non‑breaking space. If we refresh, there, you can see we're getting a little bit more padding, but we no longer have that non‑breaking space in there, so the padding is coming from our class. All right. Now let's add some styling to our text. We'll slightly change the color of the event details, but we'll leave the event name alone. So we want to style all these divs inside this well, so we'll just add this class, and let's see what that does. Okay, now the text is a little darker. So it's kind of cool that you can put your styles and your HTML and your component all together like this in one cohesive piece. It's really that easy to just add styles to your component. It's worth noting here that just like we can put our HTML template in a separate file, we can also put our CSS in separate files and refer to them here. We just use style URLs instead of styles and provide an array of URL strings for our style sheets. There's a little bit more that we're getting for free with our styles here, and we'll talk about that in our next clip. And there's a practice exercise for this clip, so go check that out.

Exploring Angular's CSS Encapsulation
Now if you've done much work with CSS, you may be thinking we're headed for big trouble because we just added a fairly broad CSS selector. Typically, if you add broad CSS selectors like this, you run the risk of changing the style of every div within a well across your entire site. In order to avoid this, it's becoming common to use some sort of namespacing type standard such as BEM or SMACSS, where your class names have the names of components or pages appended to them, or there is some higher level class that contains all of your code. Then when you apply styles to your elements, you style them using very specific class names. This can become cumbersome, and can really interfere with the semantics of your code. Fortunately, this is all taken care of with Angular. Let's take a look at how this works. Just to make it a little more obvious, let's change the color of this class to red. Now let's go over to our events‑list component, which contains our thumbnail component, and add some content to demonstrate this. Before we show our event‑thumbnail, just above our event‑thumbnail let's add a div within a well like this. So this matches this CSS selector here. In a traditional HTML app, a style like this would get applied to the whole site once the style is loaded. But if we go look at our site now, I'll just refresh this, you can see the style only got applied to our child component where we added the style. It did not affect elements in the parent that matched that same CSS selector, so Angular is taking care of encapsulating our CSS styles and causing them to affect only the component where they're added. You might think that this is working this way simply because we've added it to a child component. What if we add this style to a parent component instead? Will it affect the child components? Let's take a look. So let's move this style over to the parent component, so we'll need a style attribute. Okay, let's go take a look at this. Okay, notice here that it is only now affecting the parent and it is not affecting the child. So Angular really is just scoping this to the component where we've added it. So what exactly is going on here? This is Angular's built‑in view encapsulation. If we take a look at this element in the HTML, you can see that Angular is applying attributes to all of these elements. Notice that our parent component has this attribute applied to it ending in ety‑2, but the child component, its elements have an attribute that ends in ety‑3. And then if you look at the styling or the classes that are being applied, here is our selector we created, .well space div. But angular has added this attribute ngcontent‑ety‑2. This is a randomly generated string, so Angular has modified the CSS selector to say only apply it to wells that have an attribute of this ngcontent ety‑2 and to divs that have that same attribute, and this is how Angular targets only the elements from that component. So this CSS was made very specific, without us even having to think about it. This is great. We get safe namespace to CSS without any thought on our own part. Now, one thing to note is that we are getting global styles applied across our site, or in other words, styles from our styles.css and our Bootstrap styles. To demonstrate this, let's go over to our styles.css and add a style that targets h2 elements. Okay, so now all h2's across our site should be green. Let's go take a look. Okay, sure enough, you can see that this h2 element turned green, and so you can use global styles that apply across your site, and you could even use BEM or SMACSS or something else in order to organize your global CSS, but when you want your CSS to be very specific and tied only to your component, which is actually quite often, Angular just takes care of it for you, and you can mix global styles with component‑specific styles, which we will be doing throughout this course. So that's a good demonstration of how CSS encapsulation works with Angular. Let's go clean up some of this stuff that we don't need anymore. So we'll get rid of this h2 styling, and we'll move our style back over to our thumbnail component and change it back to its normal color. And then we can get rid of this Hello world div over here. And then one last thing that I wanted to mention that we're not really going to cover in this course is that there is a way to get around this CSS encapsulation if you want to apply styles to a child component. All you have to do is apply the deep selector. That's fairly well documented, so if you find you have a need for it, go check that out.

Adding a Site Header
Okay, just to demonstrate that the app component is no different from other components and to get a little more practice creating components, let's add a site header with some navigation elements to our app component. So right now, in our app component, our template is just displaying this events‑list component. Eventually, when we add routing to our application, this component will be replaced with a router‑outlet component, and as we navigate around the site, each top‑level page component will be displayed here. So we want to add our navigation component above this. The nice thing about this is that this navigation element will be displayed on every page, since it's in our top‑level component. This will make more sense later when we had routing. For now, let's just get the navigation element showing up. Okay, so first, let's create our component. This component will be mostly used for navigation, so let's create a new folder for it called nav. All right, now let's create the component. All right, and then let's create our basic shell for our component. Okay, there's our basic component. Now the HTML for this component will be a little lengthy, so let's use a separate template file. Okay, now, let's go create that file. All right, since the HTML is a little long for this component, and typing it in isn't too helpful to learning Angular, we've added a GitHub repo over here. And this is where we'll share a few helper files for this course. So let's just grab that HTML from here. So it's in src/app/nav, and it's this navbar.component.html. So let's just go to raw view, and we'll copy that out of here, and then we'll just go paste that into our template file. All right, cool. Now I'm not going to spend any time explaining this HTML. It's all just simple HTML, and there's no Angular code in here. And all of the CSS classes currently used here come from Bootstrap. So this component is basically ready to go. So let's just go add it to our main app component, and again, we'll add this above the events‑list component. So let's change this to a string literal and then we'll add it here. Remember, nav‑bar is the selector that we gave to our new component. Okay, cool, now we have this nav bar that will show up at the top of our application, and then the page components will show up underneath that. Okay, let's not forget to add our new component to our module, so we'll just import it here and then add it to our declarations. Okay, that's all there is to adding this component, so let's save everything, and then let's go make sure our web server's running. You might have it running already. If not, go ahead and start it up. All right, let's go refresh our app. So if I refresh here, cool, now we have this nice nav bar up here. But we have some strange font issues going on here, and we'd like a little bit more spacing over here to the right of our search component. So let's go add some styles to our component. So I'll add styles right here. So first, let's address the font size for everything in the nav bar, and then let's add some margin to the right of our search form. Okay, and then we need to hide our search form that's in our nav bar if the browser window gets too small, so let's make that happen. Okay, let's check that out. All right, that looks a lot better. Okay, so now we have this new component, and hopefully that helped you see what the flow is like to add a new component to an app. Okay, that's it for components. In our next module we'll take a look at some more Angular syntax.

Summary
In this module, we created our first date‑bound component, and we saw how to use an external template for our components. We also learned about a few ways to communicate between components and how to style our components. And finally, we learned how Angular keeps our styles encapsulated to just the component where they're defined.

Exploring the Angular Template Syntax
Introduction
In this module, we're going to explore all the fundamentals of template syntax in Angular. We'll start off by looking at interpolation and expressions, which allow us to bind to and display data in our templates. We'll explore what is and what is not allowed in expressions and the types of behaviors that are discouraged in expressions. We'll then take a look at the syntax for binding to DOM events and the statements that accompany them. Then we'll look at how we display repeating data with ngFor. To do this, we'll display a list of events on the Events List page instead of just a single event. In this module, we'll also take a look at how to optionally remove elements with ngIf and how to do that in more complex cases with ngSwitch. We'll also look at how to hide DOM elements by binding to their hidden property and when you might want to do this versus removing them with ngIf. And finally, we're going to take a look at various ways to programmatically add and remove CSS classes and styles to and from DOM elements. So let's go take a look.

Interpolation, Property Bindings, and Expressions
Okay, consider this block of code. We have a component here with an inline template, and our component has a user property and I doSomething function. Let's take a closer look at our template. This is interpolation, and this is a property binding. Both of these are used to bind data from the component to the template. Interpolation is used when you just need to display that data, such as when displaying the username in an h2 like we are here; whereas, a property binding is used when you want to bind the data to the property of a DOM element. In this case, we're binding the user's image URL to the src property of this image tag. Interpolation and property bindings both use expressions to specify the data from the component to bind to. As you can see, to use interpolation, you enclose an expression in double braces. But to bind to a property, you put the property in square brackets and the expression in quotes. Expressions are interpreted by Angular and typically reference a property on the component. In both of these cases, we are referring to the user property on the profile component. However, expressions aren't restricted to just component property bindings. You can actually use a JavaScript‑like expression. For example, instead of using user.name here, we could use an expression like 2 + 2, and Angular would evaluate this expression and display the value 4. I could even call a function on my component like this, but you can't use any expression here, and there are some recommendations on the types of expressions you should use, so let's take a look at those. First, let's look at the expression restrictions. Expressions cannot use assignment operators, such as equals, plus equals, plus plus, etc. They also cannot use the new keyword to create new objects. You are also restricted from chaining multiple expressions together in a single expression using semicolons. And finally, you can't access anything on the global namespace, such as console, window, etc. These are the most notable restrictions. Now let's take a look at some recommendations for expressions. Perhaps most importantly, expressions should have no side effects. This means that calling an expression should not change any data or the state of the application in any way. Angular applications should have a unit directional data flow, and changing the state of the application, while evaluating expressions, can have some nasty consequences. Next, expressions should be fast. Expressions can get called more frequently than we realize, and so it's important that they be fast. Expressions also should be simple. You don't want a lot of business logic in your templates. That really belongs in your components. And finally, expressions should be idempotent. Or in other words, each time you call an expression, it should return the same result. This is largely maintained by making your functions have no side effects.

Event Bindings and Statements
Okay, so we've looked at interpolation, property bindings, and expressions. Now let's take a look at event bindings and statements. This event binding is binding the button's click event to the doSomething function on our profile component, so that will be called when this button is clicked. Notice that event bindings use parentheses around the element event to bind to, versus property bindings that use square brackets. And notice that statements follow an event binding and are put in quotes. Let's take a look at the guidelines for template statements. Template statements have similar restrictions to template expressions, with a couple of exceptions. Statements actually do allow you to make assignments using equals, but assignment operators other than equals are still prohibited. And then you actually are allowed to chain expression statements. But these other restrictions still remain for statements. And as far as recommendations for statements, they actually can have side effects. In fact, they often do. It's pretty much the norm for statements to make changes to the state of the application, so therefore, they are also not required to be idempotent. And while you never want any part of your application to actually be slow, statements typically will end up calling a function or something that makes an AJAX call or something that's slower, so there isn't quite the same requirement for them to be fast. So the only real recommendation for statements is that they should still be simple. Again, you shouldn't be doing a lot of business logic in your templates. They can, however, call a function on the component that is more complex. So really, this is the only recommendation that remains for statements.

Repeating Data with ngFor
Before we jump in, I just wanted to remind you that we've made changes to this course to keep it up to date. This course was originally created without the CLI since it was still in beta. Because of these updates, you may notice some inconsistencies in the File Explorer over here. Mainly, this app folder is now nested inside a src folder, and these files at the root of the project have changed. However, almost everything we'll be working on will be inside of this app folder, and everything inside of that folder will be consistent other than that this assets folder has been moved out. So don't worry about the inconsistencies you may see outside of this folder. Okay, the events application that we've been writing has been desperately waiting for us to demonstrate ngFor. So far, this Events List page has been listing only a single event. Let's update our application so that it can display multiple events. NgFor is going to make this very easy for us, and the fact that we've encapsulated all of the display logic for an event into this event thumbnail component is going to help. So first, let's update our data to have more events. Currently, we just have this one event object here. Eventually, we'll have this data come from an API call, but for now, we'll just leave it right here. This is going to be a lot of data, so we're not going to want to type all of this in. So this is another file that we've provided in our helper repo and GitHub. So in this repo under the misc directory, there's this event‑data.js file. So let's look at the raw view for that. And we'll copy all of this, and then we're just going to paste it all in right here in place of this event object. Okay, so you can see, this is now an array called events. And that array now contains multiple event objects. And the event objects are the same shape as they were except that they have a little bit more data. You can see that we've added sessions to the events. Don't worry about that right now. We'll use that data later. All of this data is really obnoxious in our controller. We'll move that out of here when we talk about services in the services module, and eventually it'll come from an API. But for now, it'll just stay here. So our page will be broken right now because we were binding to an event object that was singular. And now we have an events plural array. And so up here, we just need to use ngFor to bind to our new events array. So we just want to put the ngFor directive on the element that we want to repeat for each item in the array, so that's our event‑thumbnail element, so we'll add it here. Okay, and then we'll leave this binding here, except that it's going to bind to event instead of event1. And that is the same event as this one right here. So we'll come back and dissect this statement in a minute. But for now, let's go over and take a look at our web page. So if I refresh this page here, you can see that I'm now displaying multiple events. That was really easy. Okay, so let's take a closer look at this ngFor statement. The first thing that stands out is this asterisk. That indicates that this ngFor directive is a structural directive. Structural directives are different from other directives because structural directives actually change the shape of the DOM. They actually add or remove HTML elements from the HTML document. They don't just hide them. They actually remove them or add them. NgFor is a structural directive because it will add an HTML element for each item in the array. And so it is prefaced with an asterisk like this. Okay next, let's take a look at the expression that's being passed in to the ngFor directive. Looking at the first part of this expression, it does just what you think. It is declaring a variable. So we're defining a variable called event, and then you can see we're accessing that variable in our template binding here. So this is creating a local variable, just like we did with the hashtag syntax when we were talking about component communication using local variables. And the rest of this syntax is something specific to ngFor. This just tells Angular that events is the array to loop over, and for each item in the array, ngFor is going to duplicate this event‑thumbnail element and assign the value of each array element to this local variable. We can then use that local variable anywhere inside the element that's being repeated. To demonstrate this a little bit further, let's move this ngFor statement up to a higher element. So we'll put it on this div here. So now this entire div is going to be repeated, and you'll see that event is still accessible down here. But now we're going to get a lot of extra stuff repeated too. So let's go see what this does. Okay, you can see that this heading is now being repeated also. So ngFor will repeat the element that it's put on plus all of the elements inside of it. Let's go ahead and move this back down. Okay, now let's just style this a little bit. We're going to use bootstrap to add a row class on a containing div around this event‑thumbnail, and then we're going to create a column class div element, and that will also contain our thumbnail‑element. And then let's move our ngFor up to this div element. Okay, so this is just going to take advantage of bootstrap's grid classes in order to build a grid of these elements. And so this div with a class of column 5 is going to be repeated for each event. Let's go take a look at that. Alright, cool. So now we have each event showing as a little thumbnail on our page, and all we needed was that simple ngFor statement. Let's just go fix the styling on this so that these are all the same height. So we'll come over to our event‑thumbnail, and we'll just add a style right here. Okay, let's see how that looks now. Alright, cool. So now they're all nice and uniform. It's really nice to be able to think about styling a component and to know we'll just go to that component to add the styles instead of trying to think about a separate hierarchy of CSS files and thinking about where to go find those files. Okay, cool. So that's all there is to using ngFor. And there's a practice exercise for this clip, so go check that out.

Handling Null Values with the Safe-Navigation Operator
So far, we haven't had any problems with null or undefined values in our data, but we need to be aware of issues that missing data can cause us when we're binding to objects with interpolation like we are here in the event‑thumbnail. What if this event object we're binding to is undefined? If you've done development with Angular 1, you may expect this to work just fine, but in order to avoid hidden runtime bugs, Angular isn't quite as forgiving as it used to be. Let's just see what happens if this event is undefined. That's easy enough to do. Over here where we're calling our event‑thumbnail component, we just won't pass in this event, so that will cause the event to be undefined in the event‑thumbnail component. So if we go look at our site, okay, looking at this, at first glance you might think that it's working without errors and just not displaying the data. But if we look at our console, you can see that our app is broken and displaying errors here. And if we scroll up to the top, you can see this error, Cannot read property 'name' of undefined. And up here, you can see that the error occurred in our inline template on line 2. So if we go take a look at that template, you can see on line 2 we tried to bind to the name property of this event object that was undefined. Just like you would expect in any JavaScript code, this throws an error. So what do you do if the event might be null? That's where the safe navigation operator comes in. We can just put a question mark after the event, like this, and we'll have to add that everywhere where we use the event in this template. Okay, let's go take a look at that. First we'll clear our console, and then refresh. Okay, you can see that we're not getting errors anymore because it's safely handling that undefined object. One thing that's interesting to take note of here is that we handled the case where event is null, but notice down here where we have event?.location.address that we didn't blow up even though location is essentially undefined because event was undefined. That's because the safe navigation operator short circuits the evaluation of the expression so that you don't have to put question marks throughout your entire expressions if you know that, for example, location won't ever be undefined if the event is defined. So that's working, but what if our location object can be undefined, even for a valid event? Let's change our data a little bit so that we have another use case for this. So down here in our data on our second event, we'll collapse these sessions here, so in our second event here that is for ng‑netherlands, what if this event had no physical address, but was online only? So we'll change this like this. Okay, so now this doesn't have a location and does have an online URL. So let's put this binding back that we removed earlier. And now if we go back over to our app and refresh, you can see it's broken again because we now need a safe navigator on the location object. So event was defined, but location was undefined. So let's add a safe navigation operator here. And while we're here, let's go ahead and add support for Online URL. Okay, let's have a look. So we'll clear our console again and refresh, okay, we're no longer getting errors, and you can see that this is working, so we're not getting a location here and we are getting an Online URL. But this is kind of ugly how the location is showing up empty here, and then we have these empty Online URL fields on all the other events. It would be nice if we could just hide that data when it's blank. In the next clip, we'll see how to do that using the ngIf directive. And there's a practice exercise for this clip, so go check that out.

Hiding and Showing Content with ngIf
All right, let's take a look at how we'd hide these fields when they're empty on these events. ngIf is a built‑in structural directive that allows us to show content only when an expression evaluates to true, so hiding these fields is easy. Let's start by showing the location section only if the location is not null or undefined. We can do that using ngIf like this. Okay, so this is just checking to see if location is truthy. So if the location is set, then the ngIf directive will do nothing. But if the location is not set, then this expression will evaluate to false, and the ngIf directive will remove this element completely from the DOM. So let's take a look at how this is working. I'm going to refresh my page. Great, now you can see that Location is hidden on our ng‑nl event, but it is visible on the others. Now let's hide all these empty online URL lines in all these other events. We'll just do the same sort of thing down here. Okay, let's check that out. All right, this is looking a lot better now. And if we take a look at the HTML, you can see that Angular didn't just hide them with CSS. They're actually commented out here, which means they're not even being rendered in the DOM. This can be a great performance saver if you know that you're not going to need this element again for a while, especially if this element is something that's costly to render or to generate. Our case is really simple, but what if this was an actual component that we were hiding, and that component would actually go and fetch data from the server? In that case, it's nice to not even render the component in the DOM so that it doesn't have to go do all that work. On the other hand, what if we were going to show and hide this section frequently, say, based on a button click or a mouse hover that toggles its visibility? If we completely removed this and added it back each time, Angular would have to do all that work to render it every time we show it. In that case, completely removing it from the DOM can be expensive. It would be better if we can just hide those elements. Let's take a look at that next. And there's a practice exercise for this clip, so go check that out.

Hiding Content with the [Hidden] Binding
We just demonstrated how to remove these Location and Online URL elements from the DOM completely using ngIf, and we talked about how that's great if you know you're not going to need them, but if you're going to show and hide them frequently, simply hiding them is better from a performance standpoint. So how do you hide an element in Angular? Well, the same way you would do it with HTML. You just add the hidden attribute to the element. That's not an Angular thing, that's just HTML. But Angular's ability to bind to DOM properties makes it easy for us. Remember, we talked earlier about how you can bind to any DOM property on any element. Well, hidden is a DOM property, so we can just bind to that, like this. Instead of using ngIf here, we could bind to the hidden property, and then we're just going to set that to a Boolean value so that hidden will show up if this expression returns true and it will not show up if it returns faults. So we want something like this, but that will hide it if the location exists. We want to hide them if they don't exist, so let's not that. Okay, cool. And let's do the same thing down here for Online URL. Okay, let's go take a look at that. I'll refresh. Okay, now it's still hiding Location and Online URL when they're not present, but now it's actually hiding them. If we take a look at the HTML, you can see that the location object here is still in our DOM, but it's hidden. So you can see that Angular applied the hidden attribute to this element. And the same is true for the Online URL elements in the other events. So you can see these approaches are different from the standpoint of what gets rendered in the browser. Even though from the user standpoint it looks the same, it's good to keep these two options in mind when you're deciding to hide things in your DOM and to consider the performance benefits of each approach. In our case, these are going to stay hidden, and so we want to put this back to just ngIf. Okay, that'll do. And there's a practice exercise for this clip, so go check that out.

Hiding and Showing Content with ngSwitch
Okay, so we've shown how to change the visibility of elements using ngIf and by binding to the hidden property of a DOM element. But what if there is a part of our document that we want to change based on multiple possible values of an expression? That's where ngSwitch comes in. So let's add something to our event that will tell us whether the conference starts earlier or later based on the event time. So we're going to add a div right here, and inside that div we'll have three spans, one that says Early Start, one that says Late Start, and then another one that says Normal Start. Okay, and then we want to show and hide these based upon the event time. So I'm going to add an ngSwitch up here, and that will just get bound to the event?.time. And notice for ngIf and ngSwitch and other things that we also have to use the safe navigation operator to guard against nulls. Okay, so now I have an ngSwitch that is bound to my event?.time. Now on my spans, I just need to add ngSwitchCase statements, and then I set this to the value that should allow Early Start to be displayed. So in this case, I'm going to bind this to the value of 8:00 am. Okay, so this span has an ngSwitchCase directive that is bound to the string value 8:00 am. Let's do the same thing for these others. So for Late Start, we will bind it to the value 10:00 am. And then for Normal Start, this will be our default case. So if 8:00 am doesn't match and 10:00 am doesn't match, then this will be displayed. And we do that with ngSwitchDefault. Okay, so now we have this div that's bound to our event?.time using ngSwitch, and the cases are Early Start, Late Start, and Normal Start with Normal Start being the default. Okay, so let's go take a look at this. So I'm going to refresh my page here. Okay, cool. So you can see this one that starts at 10:00 am says Late Start, this one that starts at 9:00 am says Normal Start, and this one that starts at 8:00 am says Early Start. Okay, cool. That was easy. Now we would like these values to show up right after the time, so let's go over and take a look at our HTML here. So they're showing on a new line because this is a div, not a span. Really, we want this to just show up right after the time up here on the same line. So just to demonstrate that there's nothing special about this ngSwitch, it doesn't have to be on its own div. We could take this and move that up here, like this, and then we can move these spans up here and delete this div. And since this will be displaying right after the time, let's add some parentheses around it. Okay, let's go take a look at that. All right, cool. So now that's showing up on the same line. Now, our ngSwitch example here is using event?.time, which is a string, and so the ngSwitchCase values are also strings. Notice that they are wrapped in apostrophes. But ngSwitch doesn't have to work with strings. It can be any data type, and then the ngSwitchCase statement expressions should also return the same data type. And that's all there is to using ngSwitch. And there's a practice exercise for this clip, so go check that out.

Styling Components with ngClass
There are a couple of ways to conditionally add CSS classes to elements with Angular, and they're both pretty easy. Class bindings are good if you're wanting to toggle a single class, and the ngClass directive is better if you're wanting to toggle multiple classes. So let's take a look at class bindings first. Let's make it so that the start time of an event turns green if it is an early start event, meaning it starts at 8 a.m. So on this div that surrounds the event time, we're going to add a binding that looks like this. So this looks a lot like a property binding, but there is no property class.green on a div. So what is this? This is a special type of binding called a class binding, and it is parsed by Angular. And it's basically saying that if this expression, event.time, equals 8 a.m. returns true, then add the green class to this div. So let's add that class to our styles and then take a look at it. I'm using !important here because, otherwise, this style will get overridden by another one. This has nothing to do with the fact that we're using a class binding. It's just the nature of the CSS that exists in our app. And I could make this CSS binding a little more specific and not use !important. But we'll just do it this way for now. So let's go take a look at this over in our app. Okay, Cool! You can see that time is green only for the 8 a.m. event and not for the others. So this is working great. But what if we also wanted to add a second class, say, a bold class, to this element? That's where ngClass comes in. So let's create a bold class, and then we'll use ngClass to add both the green class and the bold class. We can do that with an ngClass expression like this. So instead of a class binding, we'll use ngClass, and then here we'll return an object, and that object will have two properties on it, one for each class we want to apply. So the first one will be green, and then it will have an expression that looks like this. So this ngClass expression would apply the green class if the event time equals 8 a.m. And then let's just apply a second class, and we'll use the same expression here, but we could use a different one. So the ngClass binding is going to expect an object where the object keys are the names of the classes you want to add. And the values are a Boolean expression that determines whether or not that class should be shown. So this will add the green class and the bold class if the event time is 8 a.m. So this should be working. Let's take a look. Okay, Cool! So now both the green and the bold classes are being applied to this element. If we come back over to our code, and we look at this expression that we've applied for ngClass, it's starting to be a lot of logic to exist in our template. So instead of this, let's actually call a function on our component. Now let's add that class to our component or that function. And then rather than running the calculation twice, let's run it once and assign it to a constant. Now we can just return our object. Okay, Cool! This should be working the same. And it is. And then I had said earlier that ngClass expects an object to be returned. That isn't exactly the whole truth. You can actually return an object like this, or you can return a string, which is a space‑separated list of the classes you want applied. Or you can return on array of strings which represent the classes you want to apply. So let's see how this would look if we were going to return a string. So, basically, we would replace this with an if statement, and then inside here, we will return a string with the classes that we want applied if this is true. And, otherwise, we'll return an empty string. All right, cool! So this should be working too. Great! And then the last thing that we could do is instead of returning a string, we could return an array or an empty array. And that should work just fine too. Cool! So you have various different approaches that you can use here depending on your needs of your application and your particular style. And then one last thing that I want to mention here. What if on the element that you're adding ngClass to or doing a class binding on, what if this already had a class applied to it? Something like this? Well, that's okay, actually. So what would happen here is the well class would always be applied to this div. And then any classes that are applied conditionally with ngClass will be added in addition to this class. And that's true for both class bindings and ngClass. And so that's the two different ways that you can use to apply classes to elements. And there's a practice exercise for this clip. So go check that out.

Styling Components with ngStyle
And just like you can apply a single class to an element with a class binding, you can also apply a single style to an element using a style binding. To demonstrate, let's replace this ngClass with a style binding. We'll just make the font green again If it's an early start event like this. Okay, so this is going to set the color based on this ternary statement. If the event time is 8:00 am, then the color will be green; otherwise, it will be this gray color. So this should behave the same as the previous ngClass binding, except that we're not applying the bold font weight, so let's take a look. If I refresh, there, you can see it's green but is not bold. Okay, So if we want to apply that bold class, we'll need to use ngStyle. And to do that inline, it'll look like this. Okay, so this is a lot like ngClass where we're returning an object, only in this case, the keys of the object, or the property names of the object, are styles like color and font‑weight, and the values are a ternary statement that will set those values based on whether the ternary is true or false, And this will work like this, but this is a really convoluted statement to have in a template. So let's go ahead and break this out into a function like we did with ngClass. So we'll replace this with getStartTimeStyle, and that will actually help us make our logic a little more simple. So let's come over here and we're going to replace this with getStartTimeStyle. And our if statement's going to be the same, but what we return is an object like this. Okay, so this is just returning an object with the styles we want, and font‑weight had to be put in quotes because it has a dash in its name. And then down here, we'll just return an empty object if the start time is not 8:00 am. Okay, and because these two objects that we're returning are different shapes, we have to set the return type of our function to any like this, just to satisfy TypeScript. Okay, let's go take a look at this. Okay, there we go, so we're now getting both of our styles applied through that function. And just like with ngClass, if we were to add a style directly to this element like this, then the styles applied with ngStyle are additive, so this style would always be applied and ngStyle would optionally apply any styles from that function. So let's delete this, and since we're using ngStyle now, we don't need these classes. And of course, we could have left ngClass in and used that instead of ngStyle, but either one works fine. And there's a practice exercise for this clip, so go check that out.

Summary
In this module, we learned about interpolation, property bindings, and expressions, and we learned about event bindings and statements, and what is legal and recommended for each of these. We also learned how to repeat data using ngFor, how to remove elements with ngIf and ngSwitch, and how to hide elements using the hidden property binding. And finally, we learned how to add classes and styles using class bindings, or ngClass, and style bindings, or ngStyle. In the next model, we'll take a look at creating our own reusable services.

Creating Reusable Angular Services
Introduction
In this module, we'll take a look at how to create reusable services and how that helps us keep our components and our app clean. First, we'll explore why services are necessary in the first place, and then we'll talk briefly about what dependency injection is and what it means in an Angular app, and then we'll dive into creating our first service with Angular, which will finally get all that ugly JSON out of our events list component. And then, finally, we'll talk about how to wrap third party libraries in Angular services so that they can be injected and used in your Angular apps just like any other service. Cool. Let's go take a look.

Why We Need Services and Dependency Injection
Okay, let's talk for a minute about why services are necessary. Imagine an old‑fashioned record player. The record player had an arm with a needle at the end that would move across the album as the album spun around on the turntable. It was a brilliant device for its time that allowed an unlimited number of artists to produce albums, which we would then buy and play on our oh‑so‑cool turntable. But the record player had one responsibility, to run the needle over the album and translate that into sound. What if the record player had attempted to also be responsible for the music? What if the albums were embedded into the player itself? Whenever a new album came out, you'd have to sell your old player and buy a new one. Not very practical. It was good that the record player was only responsible for playing the music, not for producing or storing the music itself. We want the pieces of our application to be like our record player, and we've made a good start. Our events‑list.component is responsible for listing events, but not responsible for what each event looks like. That's the responsibility of our event‑thumbnail.component. But our events‑list.component is currently doing more than it should. It's not only responsible for listing the events, it's also currently responsible for defining and supplying the event data. That really should be the responsibility of some other part of our application, especially once we start adding in logic to make a request to an HTTP endpoint. This is where services come in. Services allow you to define business logic in a separate file and then inject whatever service we need whenever we need it, kind of like choosing which record to put on our turntable. And this is where dependency injection comes in. Our record player doesn't get to determine which album is placed on to, or injected, if you will, on to its turntable. The same should be true of our events‑list.component. So we could do something like this in our EventsListComponent. Here we've created a new EventsService, and we're using it to get our events. So this is one step better. At least now our EventsListComponent doesn't have to worry about how to get the event data, but there is a problem here. The EventsListComponent is mandating that events come from an EventsService. In fact, it's this very specific new EventsService. What if elsewhere in our application we decided in some cases we should get the data from an AJAX call and in other cases we should get them from the local browser storage? We'd have no way to use a different type of event service. It's like a record player is saying, sure, I'll let you give me the albums to play, but they all have to be Elvis Presley albums. So we'd like to be able to pass in the instance of the event service to use. That way the EventsListComponent isn't mandating where they come from. This is dependency injection, and it looks more like this. Notice here that we're injecting the EventService as a parameter into the EventsListComponent's constructor. We're then calling getEvents on the service that is passed in. This code is a little oversimplified. We really shouldn't be doing a potentially long‑running call like getEvents from a component constructor, but this gives you the general idea. The point is that someone else is deciding what instance of the EventService we're using, So let's go write some code to make this a reality.

Creating Your First Service
Before we jump in. I just wanted to remind you that we've made changes to this course to keep it up to date. This course was originally created without the CLI since it was still in beta. Because of these updates, you may notice some inconsistencies in the File Explorer over here. Those inconsistencies have been explained previously. Okay, so as we've seen, our events‑list component has all of our data hard‑coded right here. Eventually, we'll be getting this data from an API, and we could just add that API call right here in our component, but then our component starts to take on too many responsibilities. We'd really like to just let another service take care of the details of making that HTTP call. It would be nice if we could just call a function here and not worry about the implementation here in our component. So let's create a service that will take care of that for us. Alright, so inside our events folder, we'll create a new folder called shared where we can put some shared elements, and then in that folder we'll create a new TypeScript file for our service. Okay, so in here we're going to create and export an EventService class, and it will have a method on it to retrieve the events. Alright, so eventually this getEvents method will be the thing that will make the Ajax call to fetch the events from a server, but we'll get into that later. For now, let's just hard‑code the events and return them directly. So let's grab them out of our events‑list.component. So we'll just copy this array out here, and delete this, and then over here in our service, we'll just add it as a constant down here, Okay, and then we'll just go ahead and collapse that so it's not distracting. And then we'll just have our getEvents method returning those events. Okay, so here we have our service; it's just a class, and technically, this is all we really need. We could now inject this service into our component or other services, but it's always a good practice to mark services as injectable like this. Adding this Injectable decorator is important for any service that you're going to inject into your components or another service, and it's important that you don't forget to put parentheses on the end of here like this. That's an easy thing to forget. This Injectable decorator isn't really required for this service, because this decorator is only required when you inject a service which also injects other services as dependencies of its own. Just to clarify what I mean by injecting a service, I don't mean imports. I mean, if you have a constructor that injects services like this. So now that this EventService injects the HTTP service, this Injectable decorator is required, and since you never really know if a service is going to take a dependency later, it's just a best practice to always add it. We don't need this HTTP dependency yet, so let's undo that, but we'll leave the Injectable decorator even though it's not technically required yet. So now we just need to let our app know that this service exists. We do that by registering it in our app.module. First, let's fix this spelling error. Then we'll come over to our app.module and we'll import it, and then we'll add it as a provider down here. Okay, now that it's registered as a provider, Angular's injector is aware of this, and so whenever we request it in another component or service, Angular will know where to go to get this service. Alright, so now Angular knows how to inject this, let's go ahead and inject it into our events list component. So we just do that in our constructor like this. Okay, cool. So we'll just have to go ahead and import the event service. Okay, and that's all there is to injecting a service once it's registered. Remember this private syntax right here is shorthand for saying essentially that we have a property on our class like this, and like we're saying this.eventService = eventService. This is shorthand for that syntax essentially. So Angular will look at the constructor for this component and see that we want an event service and it will go out and construct that or grab it from the injector and inject it in right here. So now all we have to do is use it, and we'll just do it in our constructor for now, which is a bad idea, but we'll come back to that and fix it later. For now, let's just add it right here. Okay, and we need to declare this events variable, and we'll just declare it as an array of any data type. Okay, cool. So let's go take a look at this. First, let's make sure our server's running. Okay, now, let's come over to our app and refresh, and this should still work just fine. So this is working great. Now back in our component, remember, I said it's not a good idea to put this in our constructor. It's really not a good idea to put things in your constructor that are potentially long running, and eventually this will be an Ajax call, and so this will take a little while to fetch those events. So we really shouldn't do it in our constructor, and yet we need to have this happen when our component first loads. So where can we do this if not in the constructor? Well, components have lifecycle hooks that you can hook into, and one of those is the ngOnInit method. So that lifecycle event is called when the component is being loaded. So let's create an ngOnInit method, and then let's move this code into there. Okay, and we still need our constructor, even though it's not doing anything in the body, because that's where our service gets injected. But then we can access the service elsewhere in our class, like we are here in ngOnInit, and this will work just fine. If we go over and take a look and refresh here. This is still working great, only it actually fetched that data in the ngOnInit event. And then just a side note, we can also take advantage of some Angular TypeScript declarations and let TypeScript know that this component implements ngOnInit like this, and then we just need to import OnInit. Okay, cool. Now, if we were to remove our ngOnInit here, we would get a warning indicating that it should be implemented, because we're implementing it here on our class. So we can just add that implementation, and then we're getting a little bit of TypeScript compilation safety. Okay, cool. Now we have a functioning events service, and there's a practice exercise for this clip. So go check that out.

Wrapping Third Party Services
It's pretty common in web applications that we'll want to use third‑party libraries or components. Let's take a look at how we might take something like that and turn it into an injectable service in Angular. To demonstrate that, we'll use toastr. Toastr is a JavaScript library that allows you to create pop‑up notification messages like this. Notice this message here. So let's see how we would use this in our application. First, we'll need to npm install toastr, so we'll come over to our bash console, and stop our server, and then we'll just run this npm install command. Okay, so that npm module that we just installed gives us a style sheet and a JavaScript file that we need to import. So let's go import that. So over here in our angular.json file, right here at the top of the styles, we'll import the toastr styles. And then down here in the scripts, we'll import the toastr JavaScript file. Okay, so now toastr will be loaded with our app, but the question is, how do we make this consumable as an Angular service and use it in our components? So let's make it so that when you click on this event thumbnail, we display a toast message that shows the name of the event that was clicked. So first, let's wire up the click event. Okay, so we have this event available to us here because we're looping over all the events in this ngFor. So this will appropriately wire up this click event for each event thumbnail and pass in the appropriate event.name when you click on the thumbnail. Now let's add this method to our component. Okay, so that click handler is now wired up to this handleThumbnailClick method. So now we just need to display the toast message inside this method. So when we load a toastr in the Angular CLI config, that made it globally available. So we could just call it right here like this. Now you can see here that our IDE is complaining because it knows that TypeScript is not going to compile this. That's because even though toastr is available globally, TypeScript doesn't know about it, and so it thinks that this is an undeclared variable. So we just need to declare that up here like this. This just lets TypeScript know that this variable is in scope already declared somewhere else. So we come over here and refresh this. When I click on one of these, you can see I get a toast with the name of that event. So that's working, but there are a couple of problems here. First of all, we're using a global reference for this toastr object, and using global objects is never a good idea. And then finally, another problem is that this is not testable. Since we're not injecting toastr into our component, we can't mock it, and so that makes it difficult to test this component. So let's take a look at how we would create an Angular service around this that we can inject. Alright, so we'll create a ToastrService, and it really doesn't belong in this events folder. So let's create a common folder for items that will be shared commonly throughout the app, and then we'll create our service here. Alright, so in here, let's create a Toastr class, and let's make that injectable so that Angular knows about it. And, as always, don't forget these parentheses here. Okay, now we basically want to wrap each of toastrs methods. It has four methods that we're interested in. The first method is called success, and you call that like this. So you pass in a message and the title. Let's create a method on our service to wrap that like this. Okay, so now we have a success method on our new ToastrService. We didn't have to name this success, of course. We could call it anything. The important part is that we're calling success on the toastr object. But we still have a problem here. Our compiler still doesn't know what this toastr object is. We're just going to tell TypeScript not to worry about that, and you can do that by declaring a variable like this. So this will tell our TypeScript compiler that toastr is an object that we know about. And in this case, it's something on the global scope. But now at least accessing our global scope is limited to this class and we won't be using it all over our application. Okay, now let's go ahead and wrap the other toastr methods. Okay, cool, so now we have an injectable ToastrService. Alright, so this service is ready to use. Let's go back over to our events‑list.component. We're going to have to import it, and now we can just simply inject it down here. And then down here, we'll use our injected ToastrService. And now the step that's easy to forget. We need to add our ToastrService to our AppModule. So we'll declare it as a provider here, and then we'll have to import it. Okay, that should do it. Let's see if that's working. Let's refresh, and click on our events, and there we go. We're getting our toast messages. That's working great. So now we aren't using a global variable in our code anymore. TypeScript is happy, and our code is much more testable than it was.

Summary
In this module, we learned why services are necessary and what dependency injection is and why it's important. We then saw how to create our own reusable services and even how to wrap third‑party libraries in reusable Angular services. There's one more use for services that we haven't shown here, and that is to use services to hold state that is accessible throughout your application. We'll do this in the Forms module when we create our authentication service, which will hold information about the currently logged‑in user. In the next module, we'll explore routing and navigation.

Routing and Navigating Pages
Introduction
In this module on routing and navigation, we'll explore how to define URLs for pages and navigate between them in our app. We'll talk briefly in this introduction about why routing is necessary, and then in this module we'll see how to define routes for various pages in our site. And then we'll see how to add links that activate those routes and how to navigate to those pages from code. We'll also learn how to prevent routes from being activated or deactivated using route guards, basically preventing users from navigating to or away from pages. And we'll look at how to preload the data for a page using the resolve route handler. We'll also demonstrate how to style links based on whether their corresponding route is currently active. And finally, we'll see how to lazily load different sections of our site so they're not loaded into memory until we need them. So let's just talk quickly about why routing is necessary. In a traditional website before the advent of single page apps, each page was completely separate and distinct from others, and every page was served independently from the server. When you went to index.html, the browser would ask the server for the index.html file, which the server would then return to the browser and then display. And if you went to foo.html, it would ask the server for that file, and the file would be returned and then displayed. And the entire page would be replaced, even if 60% of the page was the same as the prior page. Modern web applications,, however, load an app into memory by loading just a single page, typically index.html, and then all other pages are actually loaded via JavaScript. But they're not really full pages. Your initial index.html is the only full page load. And then only portions of that page are replaced as you navigate from page to page around the site. To the user, it seems like new pages are being loaded. They even see the URL changing in their browser, and the back and forward buttons even work despite the fact that only one index.html page has ever actually been loaded from the server. There's a lot that goes into making this work, but frameworks like Angular have abstracted a lot of that away and made it very simple. So let's take a look at how we can make this happen in our app.

Adding Multiple Pages to Your App
Before we can demonstrate routing, we need to have multiple pages in our app to route to. Currently, we're displaying a thumbnail for each of our events here, but we'd like to have a page where we can show more details about each individual event. So let's create an event details page, and then we'll see how to navigate to that page when we click on one of these events. Before we jump in, I just wanted to remind you that we've made changes to this course to keep it up to date. This course was originally created without the CLI since it was still in beta. Because of these updates, you may notice some inconsistencies in the File Explorer over here. Those inconsistencies have been explained previously. Okay, so there's going to be a number of things in this event details section of our site, so let's create a folder for this component. And then in here, we'll create our component. Okay, and let's create the basic shell for our component. Okay, now let's add the properties for our component here. And typically, we've added a selector here so that our component can be used from within an HTML page, but this component isn't going to be used as a child component from another page. It's going to be routed to directly, so we don't need a selector. But we're going to put our HTML in a separate file, so we're going to want a template URL, and that I'll go here. Okay, let's go ahead and create that template file. Okay, and then we're just going to want some HTML here to show some basic information about this component. We don't want to have to type this all in, so this is also available over in our GitHub repo. So let's jump over there, and it's inside this app folder in this events/event‑details folder, and it's this HTML right here. So I'm going to click on Raw here. Okay, and here's our HTML. Let's just go ahead and copy of that, and we'll paste it in right here. Okay, so this is just some basic HTML with some bindings to an event property on our component. Alright, and we're going to want a little bit of styling here, so let's at a class on this outer div here, and then we'll add that style to our component. This will just add some padding around the whole thing. Okay, and one more style to add. We're going to want to limit the size of this image here. Okay, so let's add that style over here. Okay, so as we saw in our HTML, we're binding to an event object here, but our component doesn't have that property. So where's that going to come from? Well, this page is going to be navigated to directly, and the ID of the event that we want to view will be in the URL. So when we navigate to this page, it'll be a URL like this, so that 1 will represent the event ID for this page. Okay, so when this page is loaded, we're going to want to make a call to the event service to fetch the event for this page. And remember, we don't want to do that in the constructor because that's going to be a longer‑running AJAX call. So let's create an ngOnInit method here, and we'll do it in here. Okay, and we'll pull this from our event service. If we go over and look at our event service, it only has a method right now for retrieving all of the events. We just want to retrieve a single event. So let's add a new method here called getEvent, and that will take in an ID. That will be a number. And then we'll just pull that out of the events array. And again, we'll have this make an AJAX call later. But for now, we'll just pull it off of the array like this. Okay, so now let's go call that from our new EventDetailsComponent. So first, we're going to have to import that service. Okay, now we just need to inject it. Okay, now we can just make that call from ngOnInit. Okay, and remember, we're going to be passing the ID of the event in on the URL. And we're going to want to pass that ID in here. But for now, let's just hardcode this to event 1. Okay, and we have to declare that as a property. Alright, now this component is ready for use, but we need to register it in our app module. Okay, and then we'll just register it down here. Okay, so now we have another page to route to. But the question is, how do we get to it? Let's add our first route.

Adding Your First Route
Alright, so now we have this event‑details component, but how do we get to it? First, let's remind ourselves how we're currently displaying our events‑list component. Over here in our index.html file, you can see that we're loading our events‑app component. And if we go look at that component, you can see that in its HTML, it has two child components, a nav‑bar component and an events‑list component. So this events‑app component is the top‑level app component for our entire app, and it gets loaded during our app's bootstrap process. And so it loads and is displayed when we first navigate to our app, and then it loads these nav‑bar and events‑list components. And so that's how our events‑list component is currently being displayed, and right now there's really no way to change that. What we really want to do is to always show the nav‑bar component, but instead of this events‑list component always being shown, we want to show whatever route‑level component matches our URL. This is where routing comes in. So instead of putting this events‑list component here, we'll replace it with Angular's router‑outlet component. And then somehow we need to tell Angular when a user requests a particular URL, display its corresponding component here. We do that by defining routes. So let's go create a routes file at the root of our app where we can define those. Okay, so the routes that we define for an application are going to basically be an array of route objects. It will look something like this. And right now, we need two routes. First, we need one for our Events List page. Okay, so this basically says if the URL matches /events, then show this EventsListComponent wherever our router‑outlet component is. And remember, we just added that router‑outlet component right here in our AppComponent. And now we need another route for our Event Details page. Okay, this route looks a little different because it has this :id on the end of it. That's basically a parameter placeholder where we expect a value to be passed in on the route. We'll talk more about this in the next clip, but this route will match things like /events/1 or /events/foo. And when it sees a route like that, we will display the event‑details component. And then we want a default route so that if the user navigates to the root of our site, it will take them also to the Events List page. So that will look like this. Okay, so this path is a little bit different. It's saying when the path is empty or when we're at the root of our site, then redirect to the route/events. And redirect routes need this pathMatch property, and there are two options for that, either prefix or full. Prefix means redirect if the URL starts with the specified path string, and full means redirect if it fully matches the specified path string. In our case, we just want to use full. Okay, now we just need to import our components. Okay, there's one more thing that we can do here. This actually would work as is, but Angular provides a TypeScript definition for this router config that will give us some extra IntelliSense and compile‑time safety if we add it. So let's import that, and then we'll just add that type definition to our array like this. Okay, cool. Now you can see as I add a new path, if I hit Ctrl+space in VS Code, you can see it gives me some extra information about properties that I can add to this route. And we'll talk more about a lot of these properties in a little bit, but it's nice that we get this IntelliSense here so that as we add a path, we know we're doing the right thing. And if we were to misspell something, we would get some compile‑time safety and warnings in our editor. Okay, so now we've defined our routes. We just need to tell Angular to load this config over in our app.module. So first, let's import our routes, and then we just need to add it as an import using Angular's RouterModule like this. Okay, and we need to import RouterModule. Okay, so down here, we just use RouterModule forRoot to import our route into our app. Alright, one more thing that we need to do when we add routing to our app is we need to tell Angular where on our web server our app is hosted. For example, our app is actually hosted right at the root of our web server. But what if our app was hosted here? Angular needs to know this so that it knows what it's routes are relative to so that it can parse the URL. So we do that by providing a base tag in our index.html. And you can see right here in the head, the Angular CLI has already created a base tag for us. And since our app is just hosted at the root of our website, the href is just a slash. If it was hosted somewhere other than the root, we would just indicate that here. Okay, so we now have three routes defined, and our old Events List page is now being routed to directly instead of hardcoded into the HTMl of our app component. So that means over in our events‑list component, we really don't need this selector anymore since we'll be routing directly to it. Okay, cool. We've been jumping around a little bit, so let's just recap what we actually did here related to routing. First, we added a router‑outlet component to our EventsAppComponent here. And then we defined our routes for each of our pages, including a default route. And then we loaded our routes into our event module using the RouterModule. And finally, we added our base tag to our index.html page. Okay, cool. That's pretty simple really. Let's go check this out. So you can see, our Events page is loading here. And the interesting thing is notice that our URL is now /events. If I delete this and navigate directly to the root of the site, notice that it's redirecting me to /events. That's because of that redirect route that we added. And if I add a /1 on the end of this, then I get my Event Details page. Awesome, this is working great. There's just one exception here. If I navigate to event number 2, I still get event number 1 regardless of what I put in here. That's because when we created our event‑details component, we just hardcoded the event ID 1. We really want to get that event ID off of the URL here. So let's take a look in the next clip at how we do that. And there's a practice exercise for this clip, so go check that out

Accessing Route Parameters
Okay, so when we navigate to our event details page, this event ID is always being ignored. So no matter what event ID we put in here, it always loads Angular Connect, which is the event with ID 1. And that's because in our event‑details.component, when we call the getEvent here, we're always passing in event ID 1. So let's see how we can pull that event ID off of the URL and use it in our component. Remember that over here in our routes, we added this id parameter. That colon in front of the id is a cue to Angular that this is a parameter in the URL. Angular will take whatever value is passed into that location in the URL and will create a parameter named id for that route, and that parameter will be set to the value that's passed in at that point in the URL. And then we can access that in our component. So if we navigate to events/4, then the id parameter for this route will be set to 4. So if we come over to our component, we can import ActivatedRoute from Angular. And then let's just inject that into our constructor, and we'll just call it route. And then down here, we can just use that to get the event id like this. Okay, so on this ActivatedRoute service, we're calling snapshot.params.id. That will give us the parameters off of the current route that was used to access this component. And then this is wrapping a little bit funny, but we're passing this in as a parameter to getEvent, and getEvent takes a number. So let's just cast this to a number. Okay, so now we are passing in the event id as a number into getEvent. And notice that this id here matches this id over here in the route. Okay, let's check that out. So let's refresh our page here. Notice that we went to events/4, and it loaded a different event. And if we go to events/3, we get NG CONF. And that NG CONF image is a little crazy. Looks like we might have a typo in our styles. Let's go take a look at that. Okay, yeah. Here, we have a colon here that shouldn't be here. Let's refresh that. Okay, that looks better. So now as we navigate around, that image is going to be a little better. And you can see that we're loading a different event that matches the event id that we're passing in. So that's how you pull parameters off of the URL using the ActivatedRoute service. And there's a practice exercise for this clip, so go check that out.

Linking to Routes
All right, so now we have our two pages working with routing, but we have no way to navigate between them other than just changing the URL. We'd like to make it so that when you click on each of these event thumbnails that it takes you to the event details page for that event. So let's go over to our event‑thumbnail.component. Up here In the HTML, we're going to add a routerLink to the main container div like this. So that's going to turn this div into a link, and when you click on it, it's going to navigate to /events and add the event.id to the route. And that's all we need to do to add a link to the new route, so let's go check that out. If we refresh over here, now if I click on Angular Connect, notice that it loaded the Angular Connect event so it navigated to events/1. And if we go back and click on ng‑nl, then it loads that event, so that's working great. So that's really easy to add router links. But now how do we get back to the events list page? We'd like to make it so this All Events link takes us back there. So let's go over to our nav component, which is in here. Okay, so here's the HTML, and here's our All Events link. You can see it's already got an anchor tag around it. And we can add the routerLink to an anchor tag, just like we did with the div in our thumbnail component, so it'll look like this. Okay, and notice that the expression for our routerLink takes in an array. That array is basically a list of path segments followed by the parameters. And there's no parameters for this route, so it's just /events. The link for the event thumbnail that linked to the event details was slash‑‑‑we passed in /events and we passed in the event.id. Okay, so this should be working. Let's go take a look. If I refresh over here, I can now click on All Events, and I can go back and forth between the events list and the event details. Cool. And there's a practice exercise for this clip, so go check that out.

Navigating from Code
Okay, we've just seen how to link to our routes from our HTML. Now let's take a look at how we would navigate to a page from within our code. For that, let's create a real simple component. This will become the page that we use to create new events, but for now we'll just make it a real simple page. So we'll add that in our Events folder, and it'll be a real simple component for now. And for now, we'll just use an inline template. Okay, so this page isn't going to do much right now, but we'll expand this page out in the module on forms, but we'll use it right now to demonstrate how to navigate back to the All Events page from code when the user clicks this Cancel button. So first, let's get this page wired up so that we can see it. We need to add our new component to our module, so we'll import it here, and then we'll just add it to our declarations down here. And then let's just add a route for this page. Okay, and import that component. Okay, and the placement of this route is kind of important, and actually, we have it in the wrong place right here. Problem is that this path actually matches the path above it. So Angular doesn't have a way to differentiate between whether we're trying to pass in the id new to the events id path or whether we're trying to hit the events/new path. And so, actually, let's move this up here. That way it will get processed first. So, if Angular sees events/new in the URL, it will hit that first and will send us to this route. Otherwise, it will keep looking for a matching path. Okay, so this is all wired up. So if we come over here, we can go to /new, and that will take us to this page. So let's just add a link to this Create Event element in our nav. So back over in our nav component, right here where this Create Event is let's add a routerLink. All right, now I should be able to click on this. Okay. There we go. All right, now, this Cancel button doesn't do anything right now. What we want to do is when we click Cancel, we want it to just take us back to the events list page. So let's go wire that up. So over here in our Create Event component, let's just add a click handler on our Cancel button. Okay, and that's wrapping kind of funny, but you can see when we call click here, we're going to call cancel on our component, so let's go add that method. Okay, now to navigate from code, all we have to do is inject Angular's router service. So let's import it and inject it. Okay, now all we need to do is call navigate on the router and pass in the route that we want to navigate to. And that should do it. Let's take a look. I refresh here. Now if a hit Cancel, there, it takes us back to our All Events page. That was easy. All we needed to do was inject the router and call navigate. And there's a practice exercise for this clip, so go check that out.

Guarding Against Route Activation
Sometimes we want to prevent a user from going to a particular page or discourage them from leaving a page. That's what route guards are designed to do. If we take a look at the IntelliSense for one of these route objects, I can do that in VS Code by hitting Ctrl+space, then you can see all the different properties available on our route thanks to TypeScript. Two of these properties are canActivate and canDeactivate. CanActivate allows us to determine whether or not a user can navigate to a route. Let's take a look at how canActivate works. And there are a couple different ways that we could do this. We can either use a function or we can define and use a service. We're going to use a service here because it gives us flexibility and the ability to inject other services, and we're going to need that. So right now, if we go take a look at the site, I can navigate to an event details page with a URL like this, and that works fine. But if I navigate to the event details page using an invalid event ID like this, the page actually loads, but it sure doesn't look very good because there's no data here. We'd like to put a route guard in here to redirect them to a 404 page if the event ID is not valid. So let's create that 404 page first. This will be quick. First, let's add an errors folder, and then we'll add a 404.component. Okay, and let's grab that component out of our GitHub helper repo. So over here in the app folder, there's an errors folder, and it's this 404.component. So let's grab the component out of there, and we will paste it into here. Okay, now we just need to add that to our module and add it as a declaration, and then we just need to add a route for it. Okay, let's just import that. Okay, now should be able to hit that page. Come over here and navigate to 404. Okay, good. So now we have a 404 page that we can redirect to. Okay, so we're going to add a route guard that sends us to that 404 page. So let's go create a service called event‑route‑activator. We'll add that in the event‑details folder. Okay, and the shell of our route guard service will look like this. Okay, so we just have our basic Injectable service here, and then we're going to make this implement this CanActivate TypeScript interface. Okay, so that requires us to implement the canActivate method. All right, so we want to just check to see if the ID passed in is a valid event. So we need to inject our EventService, and we'll inject that here. And then in our canActivate method, we'll look up the event, so we'll need to grab the event ID off of the route. This will be easy since the current route is passed in to the canActivate method as the first parameter, so we can grab it like this. Okay, lets import that. Okay, now we can get our event off of the EventService using the ID from the route like this. Okay, now if this doesn't return a valid event, we want to redirect to our new 404 page. So let's just set a Boolean variable based on whether this call returns a valid event, and then we'll just cast the result of this call to a Boolean. Okay, and then we can just right here check to see if the event exists. And if it does not, then we will navigate to our 404 page. Okay, and we'll need to inject that router. Okay, so here we're loading our event. If it does not return a valid event, then we redirect to our 404 page, and then our canActivate method needs to return a Boolean. So we'll return here whether the eventExists. Okay, so it will return true, meaning the route can be activated if the event exists; otherwise it'll return false. Okay, that's all there is to creating a route guard. Now, we just need to go add this as a provider to our module. So we'll import it up here, and then we'll just add it as a provider. Okay, so now we have this route guard. We just need to go attach it to the route that we want to add a guard to. So over in our routes we have our event details route right here. And then we're just going to add CanActivate and pass in our EventRouteActivator. Okay, cool. So that's all wired up. Let's go check it out. So now if I go to events/1, that's not working, actually. I think there must be something wrong with our call to getEvent. Oh, yes, we need to cast the event ID to a number here. I think that should fix it. So let's try this again. Okay, cool, that works. But if we go to event 42, then it does not work. It sends us to the 404 page. So that's exactly what we're wanting. Okay, so that was pretty easy. Now you know how to prevent routes using a route guard. And there's a practice exercise for this clip, so go check that out.

Guarding Against Route De-activation
Just like we used canActivate to prevent the user from navigating to a page, we can use canDeactivate to prevent a user from leaving a page. This is often helpful if, for example, you want to warn a user if they try to navigate away from a page before saving their data. So let's add a route guard to the Create Event page that warns the user if they try to cancel before saving their event. So we'll start by adding a canDeactivate property to our create event route. And remember, we said that there are two ways to add route guards. You can either use a function or a service. In our canActivate example, we used a service, but we don't need something that involved for our canDeactivate, so let's just use a function. So to use a function, you just add the function name here, so we'll create a new function called canDeactivateCreateEvent. So the question is, where do you define this function? Well, we just need to register this as a provider in our module. Let's go over to our module, and then down here in our providers, we've been defining providers using this shorthand approach. If we take a look at this EventService provider, another way we could provide this is using the longhand approach, like this. So this is the longhand form that says when this is requested, used this to fulfill it, and it just makes a lot more sense to use the shorthand form in the cases where we're using services. But in this case, we're going to be requesting a string, canDeactivateCreateEvent, and for that, we want to provide a function. So we'll put that here. And then for useValue, we'll create a function called checkDirtyState. Okay, let's just put these on their own line. Okay, so now we need to define that function. We could define that over in another file. For ease of use, let's just define it right here. All right, just to demonstrate this, let's just have this return false right now. Okay, let's go check this out. If I refresh our Create Event page here and try to hit Cancel, you can see it no longer works. The Cancel button, remember, is wired up to send us back to the All Events page, and it's being prevented by our route guard. And not only is it being prevented here, but also if I click on anything that would take me away from this page, it prevents me from doing that. So that's pretty awesome how easy that is to just disable all navigation in your application using a route guard. Okay, so let's make this a little more interesting. What we really want to do is prevent them from leaving this page only if they haven't saved their event. So the question is, how will this checkDirtyState function know the state of that component? We have to have a way to know if they've saved the event or not. Well, that's actually really easy. The very first parameter that is passed in to your canDeactivate function is the component itself. So let's go take a look at our CreateEventComponent. If we were to define a property on this component that represented the component state, we could access that property in our canDeactivate function. For now, let's just add an isDirty property on the component like this. Okay, so we've created this isDirty property and it's defaulted to true, and this is essentially a public property. So over in our checkDirtyState function, if we grab that component that's being passed in, then we can check that isDirty property like this. All right, and if the component is dirty, let's call the HTML confirm dialog and return the result like this. And then if the component is not dirty we can just return true. Okay, cool, let's go check that out. So let's refresh this page. Now if I hit Cancel, okay, cool, now I'm getting this confirmation dialog that says, You have not saved this event, do you really want to cancel? And if I say Cancel, it will not. And if I say OK, it will. And then just to show that this is really based on the state of that component, let's go make that component return true, or return false. So now it's not considered dirty. So now if I hit Cancel, it will just work. Of course, we'll want this to do something more than just return true or false, and we'll come back to this when we wire up our create event form and make this return something reasonable. All right, cool, that's all there is to adding a canDeactivate route guard. And there's a practice exercise for this clip, so go check that out.

Pre-loading Data for Components
So we've taken a look at the canActivate and canDeactivate route handlers. But we haven't looked yet at the resolve route handler. Resolve allows you to prefetch the necessary data for a component or to do other checks prior to loading a component. We haven't really felt the need for this in our app yet because the data is all being provided synchronously from local variables. But this isn't very representative of the real world. Let's change our event service so that getEvents acts a synchronously like it would if we're making an AJAX call. In order to make this asynchronous, we're going to use an RxJs observable. Don't worry too much about the syntax we're going to use here. Joe will talk a lot more about observables in his module on HTTP and observables. But for now, we're just going to go ahead and import Subject from rxjs. And then inside our getEvents method, we'll just create a new Rx observable Subject like this. And then in order to make our getEvents method act like it's asynchronous, we're going to use JavaScript's setTimeout method like this, and then we'll just return our observable. Okay, just to explain this a little bit. Observables are like streams of data. They are kind of like arrays where the data arrives over time. Angular is designed to work very well with both observables and promises, so we're going to take advantage of that. So basically, Subject is a type of observable. And right here, we're adding data to this observable stream, and we're doing it inside of setTimeout to simulate asynchrony. So after 100 milliseconds, we'll add data to the stream. And then you can see right here that we're returning the observable. We were previously returning the data directly. So we're going to have to go adjust the consumer of this data. That's over here in this events‑list component. So right here, getEvents is going to return on observable, and you get the data out of an observable by subscribing to it like this. And that's going to eventually return instead of immediately. So instead of setting this.events to the return value of getEvents, we're going to set it only when data is received, which happens inside our subscription, so we can set that like this. And to get TypeScript to stop complaining, let's just change this to any for now. Now let's go refresh our page. Okay, you can see that's still working. But now we're getting our data somewhat a synchronously, and it's happening through an observable. Again, we'll touch on observables more later. Okay, so let's go add in a little bit more of a delay in our asynchronous method. So let's make this wait for 2 full seconds. Now if we refresh, you can see the page partially loads, waits for 2 seconds, and then finishes loading. This doesn't look so bad on this page, but on some pages, this looks really bad if the page partially loads and then the data pops in afterwards. So let's add a resolve route handler to this route so that we can wait for the data to load before displaying the component at all. To do that, let's go add a events‑list‑resolver service, and let's add our basic shell. Okay, so this is an injectable service that implements resolve. In the resolve method, we will typically make an asynchronous method call like an AJAX call. And then when it returns, we'll return that data. So we're going to do that like this. Alright, and we'll have to inject our event service. Alright, and let's fix our typo over here. So this is a very basic implementation. We're calling getEvents, which returns an observable. And then we're calling map on that observable, which gives us access to the events that are passed in on that stream. And then we just return those events. So we're receiving events in to this function, and then we're just returning them right back out. Okay, and we need to import this map function. Okay, and one more thing to clarify about what we've done here. Typically, when you listen to an observable, you would call subscribe here. But because this is in a resolver, we need to actually return the observable to Angular so that Angular can watch the observable and see when it finishes. If we were to call subscribe here, the value that would be returned would not be the observable. Subscribe returns a subscription, not an observable. And so we use map, which kind of does the same thing as subscription in this case, and it returns the observable. So then, because we're returning the events inside our map expression, these events will then get passed along to the component defined in our route. Okay, so this resolver is finished now. So let's go consume this resolver, and hopefully it will all start to come together and make sense. So let's add this as a provider in our module so we don't forget. Alright, and we'll add it down here as a provider. Okay, and then we need to add this as a resolver to the route on the events‑list route. So let's come over here. Okay, so here is our events‑list route, and this is where we want to add a resolver so it will look like this. Alright, let's import that, and then we'll talk about this. Okay, so if we take a look at what we're doing down here where we're adding this resolve handler, notice that we're passing in an object, and that object has a property, events, and that property value is set to the EventListResolver. Okay, so basically what this is saying is before resolving this route, call this EventListResolver. And when that resolver finishes and returns us some data, add this data to the route as a property named events. So it's going to take the events that are returned from the resolver and put them in a property named events on the route. Okay, so now let's go over to our component and consume that. Okay, so in our ngOnInit, we were calling getEvents and subscribing to that. We don't need to do that anymore because we're doing that in our resolver. Instead, that data is now put on the route for us, and we can just get that data right off the route. So let's go inject the route. Inject that here. Okay, now our onInit is just going to look like this. Okay, so just to tie this all together, notice that this events right here matches this events over here on the route. So that's how that's all wired up. The resolver gets the events from the event service, the route takes that and puts it on the route, and then we can access it in our component. Cool, let's check that out. So now I'm going to refresh this, Okay, notice it's still taking 2 seconds, but this Upcoming Angular Events that is part of the Events List page does not show up until all the data's been loaded. Okay, that's pretty cool. And the great thing is, we only have to load our data once. Notice that our resolver loaded our data for us and put it on the route. So we didn't have to wait for the data to be loaded in the resolver and then load it again in that component. Okay, and just to clean up here, let's go over to our events service and change this timeout back to just 100 milliseconds. And there's a practice exercise for this clip, so go check that out.

Styling Active Links
Typically, when you have a navigation header in your site like this one, you want to highlight the currently active link so that users can see from the nav bar which section of the site they're on. So let's go make it so these All Events and Create Event links are highlighted when we're on those pages. All we have to do is add a routerLinkActive directive to each of these links like this. So this is basically saying when this link is active, apply this active CSS class, and we'll add that class here in just a second. Let's go ahead and add this routerLinkActive directive to this link also. Okay, cool. Now let's come over to our component and add that CSS class. Okay, cool. So we're just going to add this orange color whenever the active class is applied. And we had to add the extra li prefix to our styling here so that is specific enough that our styles don't get overwritten by Bootstrap. Okay, so let's go check this out. If I refresh the site now, cool, you can see that All Events turned orange because I'm on the events list page. And if I click on Create Event, you can see it gets turned orange also, but the All Events link should not be orange here. This is happening because the routerLinkActive binding will do a starts with match. So if we take a look at our routerLinks over here in our HTML, you can see the events route will get the active link whenever the route starts with /events. So that is also matching when the route is /events/new. But we can change this to be less greedy by setting the routerLink options to require an exact match like this. Okay, so this will make it so that the active class only gets applied if the route exactly matches /events. So let's go take a look at that. Let's refresh here. Okay, cool. Now you can see we're on the Create Event page and only it is highlighted. If I cancel and go back to All Events, you can see it turns orange and only it is orange, so this is working better now. Cool, that was super easy, and it's cool to see something like this work with so little effort.

Lazily Loading Feature Modules
So far, our application has only one Angular module; it's our main app module. Let's take a look at adding multiple modules and some of the performance benefits that we get from that. Typically, larger sites can be broken down into smaller sections. Imagine we had a section of our site for creating and managing user profiles. Let's go ahead and create the shell of an edit profile page that will be part of a new module. So we'll create a new user folder, and inside that folder we'll create a profile component. Okay, let's just grab the basic starting point for this component from our GitHub helper repo So over here we have an app folder, and in our app folder we have a user folder, and then we have this profile component. So let's just grab the raw contents of that, copy it, and paste it into here. Okay, so now we have this user profile component that will update later for adding a profile. Right now, it just has two buttons and an empty spot where we'll put a form later. So, the pattern that we've seen so far is that at this point we would go and add this to the module and to the routes. And we still want to do that, but the user portion of our site is very different from the rest of our site, so we'd like to make this a totally separate module and feature section of our site. So let's go create a new user module. In the user folder we'll create a module. All right, and a basic lazy loadable module will look like this. Okay, so we'll declare our module like we normally do. Okay. And it will have imports, declarations, and providers. All right, this looks similar to our app module except for our imports are going to be a little bit different here. We're going to use CommonModule, and in our app component we actually import browser module here. So that's one key difference between the app module and a feature module, or a lazy loadable module. And then the other difference is for our RouterModule, we'll call forChild. In our AppModule, we used forRoot here. And then we'll just pass in the routes for this module. Okay. We haven't created those. Let's go ahead and create the import and then we'll go create them. Okay, so we've already created a profile component that we want to import into our new user module. Okay, so let's declare that down here. All right, now let's go ahead and go create our routes. So we'll create a new routes file, and it will look like this. Okay, so there's nothing different with this route; however, I do want to make note of one thing. It looks from this like the route for this would be /profile, but when we're done with everything, the route is actually going to be /user/profile, and you'll see why in a second here. But just keep that in mind. Okay, so this new feature module is ready to go. Now we need to go tell our main app module when this module should be lazily loaded. We actually define that in the main module's routing config, so let's open that up. And then right here we're going to create a new route, and its path is going to be user. So this is where that prefix to our user feature routes is going to come from. So anything inside the user feature module is going to have a route prefixed with user. And then to load that module in its routes, we use loadChildren. And then it used to be that you would supply a string here that's parsed by Angular that has two parts. The first part is the path to the file where your new module is, so that's here, and then the second part follows a hash sign. And the second part here is the name of the module. So if we go over to our user module, you can see what's being exported here is the class UserModule, and actually that should be in uppercase, and then that's what we'll put as the second part of this string. But this syntax was deprecated in Angular 8. This was basically a polypill from before dynamic imports became mainstream. Now that dynamic imports are widely supported and supported in Angular, we can use them for our lazily loaded content. I'll need a little extra room here, so let's move these down onto their own line. And now instead of setting loadChildren to a string, we'll set it to a function. And in that function, we'll use a dynamic import to load this module. So we're now loading the user module using a dynamic import. And dynamic imports return a promise that contains the module to be imported, and we need to return the UserModule class from that import. So we'll add a .then here, and that contains the imported module. And from that module we will return the UserModule class. Okay, so this is basically saying when a route starts with /user, load the UserModule from this path. All right, now let's go add a link to our new profile page. So over in our navbar HTML, right here we're displaying Welcome John up in the upper right‑hand corner. And let's add a routerLink to this anchor tag, and that will link to our new user profile page. Okay, so this is all wired up. Let's go take a look. So I'll refresh here. Okay, so now notice if I click on Welcome John here that it loads our new user profile, and notice the URL up here is /user/profile. And one thing that's really cool here, let's open up our debug tools to the Network tab, and I'm going to refresh my app here. And first let's put a filter in here, /user. So let's see what requests are made for /user when I first load this app. All right, notice nothing is loaded here, but when I click on the user profile and go to the user profile page, notice that only then did it load the user module and the routes and the component. In a bigger application, this could be really helpful if a module is composed of a lot of files. It would avoid loading those until the user actually goes to that section of the site. Okay, cool. So that's how you add new feature modules to your application and lazily load them.

Organizing Your Exports with Barrels
We just demonstrated how to organize our code into modules. Let's take a look at another way to clean up our code a bit. If we take a look at our app.module, it has quite a long list of imports, and most of them are coming from the events folder. We can simplify this a little bit by exposing all of the imports inside the events directory from a single index file that we can then just import with a single import line. This is referred to as creating barrels. So let's start by creating a barrel in our events directory. So we'll create an index file right here, and then we'll simply import each of the components in this directory and re‑export them like this. Now we can do this for all of our subdirectories, and we'll even do it for our shared folder for consistency, even though it only has a single file inside it. So let's go ahead and create that now, and it'll just export the event.service. Now we can actually add this barrel to our outer barrel like this. Now we'll do the same thing for the event‑details folder, and we'll export the two things that are in this folder. And we need to add that to our outer barrel too. Now that we have these barrels created, and they're all rolled up into this one barrel, we can now go simplify our imports in our app.module file by creating a single import. So we do that like this. So there's our one barrel that has everything exported from it. Now we can move up everything from the events directory like this. Now we can delete all these extra import lines. That looks much better. Now we can go simplify our routes file too because it has a lot of imports in here from the events folder. So we'll make a single import for those and move each of these up. And then let's clean this up. That feels a lot better too. And so this will make things a lot more simple each time we need to add something to these imports. So let's just go take a look at our site and make sure that everything is still working. So we'll refresh. There we go. Everything's still loading just fine.

Summary
In this module, we learned why routing is necessary, how to define routes for pages, and how to link to those routes from HTML and navigate to those routes from code. We also learned how to create route guards to prevent routes from being activated and deactivated, and how to preload data for a component using resolve. We also learned how to style our links based on whether the routes for those links are currently active. And lastly, we learned how to create feature modules and lazily load them. In the next module, we'll take a look at how to collect data using forms and validation.

Collecting Data with Angular Forms and Validation
Introduction
In this module on Collecting Data with Forms and Validation, we'll cover everything you need to know about collecting and editing data in your applications. First, we'll take a look at how to create data models that we can use to help ensure type safety for the data we're collecting. Then we'll take a look at creating and validating template‑based forms, and then how to create and validate model‑driven forms and the pros and cons of each approach. Next, we'll take a look at using two‑way data bindings to display and edit existing data. And finally, we'll take a look at how to create custom validators that use custom business logic to validate fields. Okay, let's get started.

Using Models for Type Safety
Before we jump in, I just wanted to remind you that we've made changes to this course to keep it up to date. This course was originally created without the CLI since it was still in beta. Because of these updates, you may notice some inconsistencies in the File Explorer over here. Those inconsistencies have been explained previously. So far everywhere where we've needed an event object, like here in the event thumbnail component, we've just been working with plain old JavaScript objects and we've been using the any type or not specifying a type at all. That is completely acceptable if you don't care to use much TypeScript, and we haven't really had a need for it since our data has all been hard coded. But now that we're going to be creating new events, it might be nice to add some typing information to our application that will help us see data type errors in our code editor and will give us some compiled time type safety. Let's actually create an event model that we can use here to tell TypeScript exactly what data shape to expect. We'll use this in a number of places, so let's create it in our shared folder. So right here we'll create an event model. Okay, and we can either use an interface here or a class. It really doesn't matter which one you choose. So we'll just use an interface to define each of the fields on an event like this. Okay, so here are the basic fields and all of these are required. We now have a location and onlineUrl field that can be null. So we'll define them like this. So that question mark indicates that this field can be null, and this one's actually an object. And if location is defined, we want all of its fields to be provided, so we will not make them nullable. Okay, and then we have our onlineUrl field that's also nullable. Okay, and each event also has an array of sessions. We haven't talked much about sessions yet, but we will be using these later in the app. Okay, so we'll have a sessions property and it will be an array of ISession. Let's go ahead and define ISession here. Okay, Cool. Now we have event and session models to work with. Let's go ahead and add these to the shared barrel. All right, now, let's go put this model to use. First, let's come over to our event.service, and this is where we are currently hard coding our event data. So let's define the data type for this list of events. So here we'll specify that this is of type IEvent array. All right, we need to go import that. Okay, now let's come back down here. Okay, and right away we're seeing some benefits from having this be typed. Notice that our editor is giving us an error, and if we hover over it, it says down here, type string is not assign able to type Date. And we can also see this error over in our console. So this is where our real time TypeScript compilation is happening, and you can see that it's getting the same error down here. And all of this is because down here, when we're defining our event data, we're actually assigning strings to our date field. So let's fix that. We'll change these to be dates like this. And then we'll do that for all of these sessions. So I'll just search for this date field and replace each of these. Okay, cool. So now our data matches our model and you can see we're not getting an error anymore. And now we can go specify the return type of our getEvent method to say that this is going to return and IEvent, and then we want to specify the return type for our getEvents method also. Now, you might think that the return type for the getEvents method is an array of IEvents, but we're actually using observables here and we're returning a subject not an IEvent array. So we could specify that the type is Subject and then subject is generic, so it wants to know what data types it's going to contain inside it, which is an IEvent array. And then we'd specify here that this is a subject of type IEvent array also. Okay, so this works. But actually subject is a little too specific. We're going to be changing this to an observable later instead of a subject. And subject is a type of observable, and in fact, it implements observable. So we can go ahead and change this to type Observable and we'll need to import that from RXJS. Okay, cool. This works. So we're returning a subject which is a type of observable. So our return type now for our getEvents method is Observable of type IEvent array. Okay, cool. So this service now specifies the data type that it returns. Let's go take advantage of this model in a few more places. So over here in our event‑thumbnail.component, let's import our new event model. And now let's define our input variable to be of type IEvent. All right, and we can add the typing to our events list component too. So down here we can say that our events properties of type IEvent array, and we can specify the type in our event‑details.component. So this is an IEvent. All right, and we could keep going and update everywhere where we use events, like in our route guards and our resolvers and other places. But let's call this good for now. This is a good example of the fact that you can use as much or as little TypeScript as you want in your app. But now you know how to create and use data models in your application if you choose to. Again, it's not required if you prefer not to, but is available if you like the type safety. And if we go over to our site and refresh, we can see our site is still working now that we've added these data models.

Creating Your First Template-based Form
Okay, let's create our first form. This will be a simple template‑based login form. Angular allows you to choose from two options when you create a form, template‑based or model‑based, which is also called reactive forms. Template‑based forms allow you to build your form completely in your HTML template. It's simple and easy, and it works great for simple use cases, but it has some limitations. For complex forms, you end up with a lot of logic in your HTML if you're using template‑based forms, and things like cross‑field validation are more difficult. Another limitation is that you can't unit test all your form and validation logic if you use template‑based forms. But for simple forms, template‑based forms are great. Model‑based or reactive forms allow you to build your form and put a lot of your logic in your component instead of in the template, and this has some other advantages that we'll talk about later. So let's create our first template‑based form. For this, we'll create a new login component. We'll put that in our user module. And here's the basic shell for our component. Okay, and this is going to have enough HTML that we we'll want it in a separate template, so let's add a templateUrl. All right, and let's create that template file. And let's grab the HTML for that template from our GitHub helper repo. So over here in our app folder, in the user folder, there's this login.component.html. So let's grab the raw version of that and paste that in here. All right, there's nothing Angular‑specific here. This is all just plain HTML. And you can see here that we have two inputs, a userName and a password. And then we just have these Login and Cancel buttons. Okay, lets go declare this component in our module and add a route for it. So in our user.module, we'll import it and add it as a declaration. All right, now let's add the route. All right, let's go take a look at this. So if I change my URL here to user/login, there we go. We have a login component now. So let's go wire up this form. Okay, so we're going to be using a few forms‑related directives. And all of the forms directives are in their own modules, so we need to go import the forms module. And since this form is in our user module, we'll need to import it here. So up here with our Angular imports, we'll add import FormsModule, and that comes from angular/forms. Okay, now we just need to add this as an import. Okay, so that gives us access to a number of different template‑based forms features. So let's go wire up our form so that we can log in. So when a user enters data into these fields, we need to get that data into our components so we can use it. Based on what we learned earlier about data binding, we could just bind to the input element's input event like this. Okay, so this expression would make it so that when input is entered into this input box, an event is fired, and that event updates the userName property of our component to be the value of this input box. But that's difficult to remember the syntax for and cumbersome, especially on a form with lots of elements where you'd have to add this over and over. For that reason and others, Angular provides the ngModel directive that will allow us to bind input fields like this. ngModel gives us some extra forms‑related functionality that we'll explore shortly. Oftentimes, when you see ngModel, you'll actually see it declared like this. This is commonly referred to as the banana‑in‑a‑box syntax, and it represents a two‑way binding. If you remember the syntax module, parentheses are used to bind in the HTML‑to‑component direction, and it's typically used for responding to events; whereas, the square brackets are used to bind in the component‑to‑HTML direction and is typically used for displaying data from the component on the page. The reason why you'll often see the banana‑in‑a‑box style binding is that often forms are used for editing existing data. And so you'll want to display the existing data, and as you type, you want to update the data in the component, thus the need for both types of bindings. But for a login form, there is really nothing initially to display. So we just need a one‑way binding. It's always best to use just a one‑way binding when that's all you need. So we'll update it back to how it was. Okay, an ngModel requires us to define a name attribute, so let's add that. You'll notice that we're setting ngModel and name to the same value, userName. This is typical, but it's not always the case. We'll explore this more later. For now, we'll just set them both to userName. All right, let's add this to the password field too. Okay, now we just need to add these fields to the components model for ngModel to bind to. So over here in our component, we'll just add the userName and password fields here. We're not actually going to use these fields directly in our component, but Angular requires us to add them for the ngModel data binding that we just added. Instead of using these fields directly, we're going to access these values from the submitted form. We do that by adding a local variable on the form element like this. And we'll use that loginForm variable in our submit handler. We could just bind to the form's submit event like this, and technically this would work. When we submit the form, the login method on our component would be called, and it would pass in the loginForm. But Angular provides a directive called ngSubmit, and we'll use that because that handles a few extra things like preventing the form from submitting to the server, for example. So it's best to use this binding instead. And then over here, we're using the loginForm local variable that we defined, but there's a lot of info on a form object. But all were really interested in right now is the value, so we'll just pass that in. Okay, now let's go add this login method on our component. And for now, let's just log this out and see what this looks like. Okay, let's check this out. So let's come over here and refresh our Login form and type in a username and a password. All right, now let's open up our console log and click Login. Okay, so if you remember, we passed in, in our HTML, loginForm.value to our login method. And then here, we just console logged it out. And so the loginForm's value is this object that has a userName property and a password. This is actually a really convenient shape. It is simply an object with each of our form fields as properties. So now we can just use these values to log our user in. So in the next clip, we'll take a look at how to consume these values that are provided by our template‑based form. And there's a practice exercise for this clip, so go check that out.

Using the Data from Your Template-based Form
Okay, so our login form is now providing the data that we need, so let's use that data to log the user in. But first, we'll need a service that we can call that will do that for us. So let's create an AuthService in our user.module. So right here, we'll add a new file, auth.service. And just like every other service, this will just import an injectable class. Okay, and the service will have a loginUser method that will look like this. All right, and this service will keep track of the current user. So let's create a user.model that we can use here also. And that will just look like this. All right, now let's just import that model into our service. Okay, now we can create a currentUser property on our class that will be of type IUser. Okay, now when we call loginUser, we'll make a call to the server and log the user in, and then we'll set this currentUser property. But we don't want to deal with all of that right now, so we're just going to fake it out and set the currentUser to be John Papa. Okay, and it looks like we might have a problem with our interface. Let's come over here. Yep, this should be capitalized. It's really neat how using TypeScript allows you to see errors like that. Okay, so we're not really authenticating the user here. We'll wire that up in a later module. What we'll eventually do is pass the userName and password to the server, let the server authenticate the user, and return the user's information that we will then set as the current user. But for now, this fake implementation will work, and it gives us a service that we can call, and we can worry about the implementation details later. For now, when you call loginUser, it will just log you in and always set the currentUser to John Papa. All right, while we're in here, our app is going to want to know if we are logged in. So let's add an isAuthenticated method that just returns true if the currentUser is set. Okay, that will do for our service. Let's not forget to register it, however, as a provider. This is going to be a little bit interesting. Remember over in our user.module, when we needed the FormsModule, we imported it here as an import in our user.module. Now we have a service that we need to register as a provider, but we don't want to register it as a provider here in our user.module. We want to do that in our app.module. That's because we're also going to be using it in components that are in our app.module, so we'll use it in both modules. And that might make you wonder, why don't we need to register it in both modules? Well, that's because providers are shared across Angular modules. So if we add it in our app.module, it will be available for us to use here without having to register it as a provider in this module. It's worth noting that while this is true for providers, it is not true for imports and declarations. So you need to import those in whichever modules need them. Anyhow, let's go ahead and add the AuthService as a provider in our app.module. Okay, so we'll import it, and then let's add it as a provider. Okay, now back over to our login.component. When the login method is called here, we'll call our new AuthService. Let's import it and inject it. And then we'll call it like this when login is called. Okay, so if you remember over in our HTML, when we submit the form, we pass in the formsValue, which has these two properties on it. And then they're available here, and we can pass them into the service. Okay, now let's just update our app so that we can tell when we're logged in, and then this will all come together. So over in the HTML for our nav component, instead of just displaying Welcome John here, let's display a Login link if the user is not authenticated and a welcome message if they are. So first, over in our nav component, let's import our AuthService and then inject it down here. And then back over here in our navbar HTML, let's add a new Login link right here. And that will link to our login route, so let's add a routerLink. Okay, so that links to our new login form. And then we only want to show this if the user is not authenticated. So let's add an ngIf to this, and then we can access that AuthService that we just injected right here like this. Okay, cool. So that will only show now if the user is not authenticated. Now let's update this profile link to only show when the user is logged in. And then right here, we'll just update it to show the current user's name. Okay, now if we go over to our app, and let's refresh, and then you can see up here we have a Login link. So if I click on that and then log in. Okay, now if I log in, cool. Now you can see we're logged in. All right, cool. So this is our first form, and you can see how the data from our input boxes was wired up with ngModel and then how we pass that in with ngSubmit to our login method. And then in our login method, we called our AuthService and passed in the userName and password that logged the user in. Next, we'll take a look at some validation, but let's just finish up a couple of loose ends here. First of all, when we log in, it is logging us in, but it's leaving us on the Login page. So let's get it so that it redirects us back to the All Events page. And then also if you hit Cancel, it'll send us to the All Events page. So let's import our router and inject it. And then in our login method after we authenticate the user, we will route them back to the Events page. Okay, and then let's wire up the Cancel button. So let's provide a method here, and this will also navigate to the Events page. Okay, lets go wire that up on our button. So when we click on this button, we'll call our cancel method. Okay, so that should be working now. If I refresh here and now if I log in, then it logs me in. You can see I'm logged in now. And it takes me to the Events page. And if I click Cancel, it also takes me back. Okay, cool. Now let's go add some validation.

Validating Template-based Forms
As it is now, we have a bit of a problem with our login form. I can actually login without entering anything. This is partly due to the fact that we have faked our auth service so we're not actually checking the user credentials on the server yet. But we should be able to catch this before the call to the auth service. The user shouldn't be able to submit this form without populating these fields. So let's add some validation that will prevent that. To start with, let's add required attributes to both of our input fields. Okay, one quick note about some fairly old versions of Angular. Prior to Angular version 4, you would see the default browser validation like I'm showing here. This isn't Angular validation. This is just default HTML5 validation. You used to be required to add this novalidate attribute to the form to disable HTML5 validation, but that was changed way back in Angular version 4. Angular now disables this by default, but it doesn't hurt to leave this attribute here. Okay, let's go take a look now. If I refresh this and click Login without populating the fields, you can see that the required field validation hasn't stopped us from submitting the form. But Angular is providing us with some validation information, and that information is available on this loginForm. So I'm just going to paste in a bunch of temporary code here that'll allow us to learn a lot about the state of this loginForm. Don't bother to type all of this in. I'm just going to delete it here in a second anyhow, but this will show us a lot of information about this form. Okay, so you can see here that I'm going to be displaying a bunch of information about the loginForm and the controls on the loginForm. So if we go back over and refresh our app and go to the loginForm, you can see I'm displaying a bunch of information about the form here, such as whether the form is valid, whether it's dirty or pristine, whether it's submitted, or whether it's been touched. And you can see that currently valid is false. And also, I'm displaying information about the User Name and Password fields. Notice that these touched fields, when I click on User Name, as soon as I type something in here and leave it that a bunch of these values changed. So the touched field changed as soon as I left the field, and dirty also changed. And notice that the User Name field is now valid, but the Password field is not valid and neither is the form. If I put a value in the Password field, okay, now the Password field is valid and so is the form. So while Angular didn't prevent us from submitting the form, it did tell us whether the form in various fields are valid or not. And there's a wealth of information here about the different states of the form so you know if somebody has even attempted to type something in a field and whether those fields are valid. And that all bubbles up to the form so that the form is only valid once all of its fields are valid. Okay, so let's go utilize some of these values. So first, we'll delete all that HTML that we put in here, and now let's disable the Login button if the loginForm is not valid. So right here, we're going to bind to this button's disabled property, and we're going to set it to disabled if the loginForm is invalid. So now if I come over here, you can see that the Login button is disabled, and so now the user can no longer log in. But we're not giving much info to the user about what's wrong with the form. Notice if I type in my user name and password that the Login button becomes available, and I could submit the form here. But we do need to give the user more information about this empty state and why they can't submit the form. So let's add a little validation message that shows up right after the labels. So we'll just add a little emphasis element here that says Required, and we'll do that for the password too. And then we only want to show this if the User Name field is invalid, and then we'll do the same for the Password field. And then we need to make sure that we use the safe navigator here because these fields are not always available on the loginForm controls. Okay, now let's just add a little bit of styling for these error messages. Okay, let's go check this out. So if we refresh our app and go to the Login page, okay, you can see immediately our form cannot be submitted, and we are being told that these fields are required. Okay, so technically, this is accurate. These fields are invalid, but it's a little annoying to display all the error messages before the user has even tried to do anything. So let's just show these errors only if the fields have already been touched. So back over here in our HTML, on the ngIf, we will only show this if they are invalid and they've been touched. We'll do it for the Password field too. Okay, let's check that out. Okay, so we're not getting our error messages here. And if I tab out of this field, then it shows up. There we go. That's working better. But still, the original state of the form isn't the greatest. Our form cannot be submitted, but there are no error messages explaining why. So you could get creative and do whatever fits your application the best. But one thing we could do is add a mouseover handler on the Login button and display the error messages when the user mouses over the Login button. That should be easy. What we'd like to do is add mouseenter and mouseleave to our Login button. But Disable buttons don't raise events, so we'll have to wrap this button in a span and add the events to the span like this. Okay, so when the mouseenter event is fired on this span, we will set mouseoverLogin to true. And then on mouseleave, we'll set mouseoverLogin to false. And we'll wrap this button in that span. Okay, now, on our error messages, we can make them only show if the fields are invalid and they're touched or if the user is mousing over the Login button. Okay, so let's add parentheses around this here, and we'll add an or mouseoverLogin. Okay, and the same thing on Password. And then we just need to declare this mouseoverLogin property. So in our component, we'll just declare that right here. There we go. Okay, let's check that out. All right, so we are not getting our error messages. And if we hover over Login, excellent. Now it shows what's required. If I make this valid, now only password is required, and then I can login. Awesome. So that's really cool how easy that is and how much power there is in those few properties that are available to us on the login form for validation. And there's a practice exercise for this clip, so go check that out.

Creating Your First Reactive Form
Okay, this login form that we just created was a template‑driven form, meaning we built our whole form and all its validation in the HTML itself. But there is another way to do it, and either one is completely acceptable depending on your needs. The other option is to use a reactive form, also known as a model‑driven form. Basically, this means you define your fields and your validation in your component, and then wire them up to fields in your HTML template. This requires a little extra code, but it has some advantages, for example, you have the option of building your form and validation more dynamically based on decisions made in your code. And another great benefit is that it makes all of your validation logic unit testable. So let's take a look at how to do this. To demonstrate this, we'll create another simple form. You may remember that in a previous clip we created this profile page that we said we would finish later. Let's go ahead and create a model‑driven form for this page. So over here in our profile component, it's currently using an inline template. Let's just delete that and use a templateURl. So its template will be here, and let's go ahead and create that. Okay, and we'll grab the HTML for that from our GitHub helper repo. So over here in the user folder, there is this profile.component.html. Let's grab that and paste that in here. Okay, and again, this is just HTML, no Angular. Alright, and on our last form, we dove right into our HTML template to start wiring up our form with Angular constructs. This time, we're going to go over to our component and start configuring our form from here, and we're going to want to do this in an OnInit method, so let's implement OnInit. Okay, and importing and implementing OnInit is optional, we could have just created this function, but implementing OnInit does give us a little bit of TypeScript help. Okay, so our form has two inputs, a first name and a last name, so we're going to create a FormControl for each of those like this. Okay, and now we need to add these controls to a form, so we use a FormGroup for that. So we'll create a profileForm property on our component in a minute, and we'll just set that to a new FormGroup, and then we set properties on this for each of the controls like this. Okay, so this has a FirstName and a LastName property on it, and those properties' values are set to these FormControls that we just created. And let's go ahead and create a property for this on our component. Okay, and we want a property on our component for this because the profileForm is going to be accessed from the HTML template. Alright, now let's go ahead and import FormGroup and FormControl. So now we've defined this form, but we need to tell Angular which HTML elements these correspond to. So let's go over to our template, and first we'll bind our form element to the profileForm like this. Okay, so this binds our form to the FormGroup that we created in our component, and then we need to specify for each of our input elements the property on that profileForm that they should be bound to. Okay, and these values, FirstName and LastName, need to match the property values of the FormGroup here. Okay, and it looks like I've misspelled my component.html, so that should be component. Okay, so this form and these inputs are now wired up to their FormControls in the component. And you may remember when we were doing the template‑driven forms that we had to import the Angular FormsModule into our module. Well, model‑driven or reactive forms use a different module called the ReactiveFormsModule, so we need to import that too. Okay, so up here we're going to also import ReactiveFormsModule, and add it is an import here. Okay, so now if we go over and take a look at our app, let's refresh here, and let's log in first. Okay, now if we go look at our profile page, here's our form, and these controls were wired up to their component, but there's one thing missing here. I'm already logged in, and so my first name and last name should already be being displayed in these boxes. And then we also haven't wired up our buttons yet, so let's go take care of that. First, let's pre‑populate these fields with data from my profile. So over here in the component, if we look at our FormControls here, we didn't pass in any parameters when we created our FormControls. The first parameter is the value that you would like pre‑populated in the field. So we can get the current user information from the AuthService, so let's import that and inject it. Okay, now from the AuthService I can get the current users first name and last name and pass them into our FormControls. Okay, so we're creating the first name and last name FormControls, and when they first render, they will have the values of the first and last name of the current user. Okay, so now let's wire up our cancel and save buttons. So let's come over to our HTML, and then we'll add a click handler here, and that will just call a cancel function. Alright, and then over here let's create that cancel function, and that will just navigate to the events page, and we'll have to inject that router. Okay, now our cancel button is wired up. Now let's wire up our save button. That wire‑up actually happens on the form over in our HTML. So we'll use ngsubmit like we did over on the template‑based form, and we'll have it call saveProfile, and we'll pass in the profileForm's value. So this seems pretty similar to the way template‑based forms work. Alright, now let's go create our saveProfile method, and that will take the formValues in. Okay, now we're going to want to call a method on our AuthService to update the current user, and we'll just pass in the values from the form. Okay, but this updateCurrentUser method doesn't exist yet, so let's go create that on our AuthService. Alright, we'll just add that down here, and we passed in the first name and then the last name. Alright, and then we'll just do another fake implementation of this for now. Okay, so this is just going to update the first name and last name of our currentUser property that we've declared up here. Alright, let's go check this out. Okay, so if we refresh our app and login, and then go to our profile page, there you can see that our first name and last name, which are the values that are currently hard‑coded in our AuthService here, are now being displayed in the FirstName and LastName fields. And if I change my name and save it, then you can see my user name changes up here. But when I hit save, it doesn't navigate after it saves, so let's just go update that. So after we save the user, we want to do this same thing. Alright, now if I refresh and login, and then go edit my profile, now when I make this change and save, there, it updates my user and redirects me to to the All Events page. Okay, cool, so that's how you do reactive forms. Now let's take a look at validating reactive forms. And there's a practice exercise for this clip, so go check that out.

Validating Reactive Forms
One of the benefits of using reactive forms is that we can define our validation in our component where it's unit testable, so let's add a bit of validation to our form. First, we'll just make our fields required and validators are just passed in as the second parameter of the form control. So we can just use Validators.required and we'll go ahead and add that both of these. Okay, and we need to import validators from the forms. Okay, so now we have required validators on our two form controls and it is possible to add multiple validators. We'll look at that in the next clip. For now, let's just go make it so that if our say profile method gets called, it won't save the form if it isn't valid. So right here I can say if this.profileForm.valid, then save and navigate. Otherwise, we won't do anything. Okay, so now if we wanted to write a unit test for this, you could see how I could instantiate a new profile component and stub my auth service to return valid or invalid values and then call save profile and validate using a mock whether or not my user gets updated. I could also get access to this profile form property for my tests and directly run tests against it by populating its form controls and then testing the validity of the form. This seems somewhat unnecessary for a trivial form like this, but you can see how in a larger form with a lot of validation it would be nice to test different scenarios. None of this is possible with template‑driven forms. Honestly, with a small form like this one template driven might be better because it's so simple, but for larger forms, model driven may be better for testability reasons. Before we jump over into our HTML, let's add some CSS styles that we're going to use over there, and we're going to do some more interesting styling with this form. So just like we did before, we'll had some styling for an emphasis tag, but let's also add an error class that we can add to our input boxes so whether you can style our input boxes and then make them turn red when they're invalid. Okay, and for this to look good, we need to also style the placeholder text and there isn't a standard CSS selector for this so we have to use a different one for each browser. Okay, now we can utilize this error class for styling our input boxes, so let's go add this to our HTML. Okay, so let's make our input boxes have our error styling if the field is invalid, and the way we designed our CSS selectors, we need to add the error class to the div element if a field is invalid. So we'll use ngClass if the first name is invalid and the first name field has been touched. Okay, and we want to do the same thing for last name. Alright, let's go check that out in our form and see how that styling is working. So I'll refresh this and log in. Okay, now if we make this field invalid and leave it, there we go. So our styling is being applied to our fields. Now we need an error message to display. So the logic for displaying the error message is actually going to be identical to the logic we just coded into ngClass. So let's actually move this logic into our components so that we can reuse it. So let's copy this out of here, and we'll call a method on our controller called validateLastName, and if that returns false, then we want to add the error class. Okay, and then we're going to do the same thing up here for first name. Alright, let's go add that over here. We'll just add that in right here, so validateLastName, and we can get the value of our controls off of this .profileForm, but it will be more direct if we can just get it right off of the controls like this. In order to do that, we need to make our controls available outside of just ngOnInit. So let's set these here, but let's declare them up here, and then down here we just need to say this. and same thing right here. Okay, now down here, we can find out directly from the last name field whether it's valid and touched, and this needs to be an or and we want to say valid here. So we're kind of reversing the logic before where we want to return true if this is valid. So we're returning true if it's valid or if it's untouched. Alright, and then same thing for first name. Okay, so this will return true if it's valid, and then down here, we're nodding it. So we will add the error class if it is not valid. Okay. And now that we have that in place, let's get back to wiring up our error message. So we can just add a couple of emphasis elements, and in our ngIf, we'll just call our new functions. So if the first name is not valid, then display Required, and then the same thing for last name. Okay, let's check that out. So I've got to log in again and go to my profile form. And now if I leave this blank, you can see that it turns red and we get the required message, only it looks like we missed something on the styling for the color of required. Okay, we're missing a colon right here. Let's refresh this and try again. Okay, there we go. Okay, cool. So now we have validation in place for our reactive form.

Using Multiple Validators in Reactive Forms
In this model‑driven form that we just created, we're passing just a single validator to each of our fields. What if we wanted multiple types of validators on a field? Well, that's easy. We just pass in an array of validators to our FormControl. So let's add a pattern validator to our firstName that requires firstName to start with a letter. So we'll just turn this into an array, and we'll also pass in Validators.pattern. And Validators.pattern takes in a parameter. That is the pattern that you want to validate against, so that will just look like this. Okay, so now I have two validators on my firstName field. Okay, so let's go check that out. Let's refresh and log in. And then over here, if I leave this field blank, I'm still getting my required field validation. But if my field starts with a number, it's invalid. So it is showing that it's invalid here, but the problem is my message is still saying Required. It should say something about that it's not matching the required pattern. So we're going to have to have a couple of error messages in our HTML. So right here, let's add another error message, and it will say, Must start with a letter. Okay, but this still isn't quite right. Now both of these heirs will be displayed whenever the First Name field is not valid, regardless of the reason. So I need to add another check on each of these, like this. Okay, so required is set to true when there is a required error. And then we can do the same thing here with pattern. All right, let's go check that out. Let's refresh our app and log in. And then over here, if I delete this, then I get a Required error. And if I make it start with a number, then it says it must start with a letter. Okay, so pretty easy to add multiple types of validation. Okay, so we've shown required validators and pattern validators. We're not going to go through all of the types of validators that are built into Angular. But if you come over to angular.io and go to DOCS and then search for validators, this first result here shows the different types of validators. So there's required, minLength, maxLength, and pattern. These others are for more advanced cases. And then it explains each of them down here. And if you need something beyond these, you can create a custom validator. We'll take a look at that in just a few clips here. And there's a practice exercise for this clip, so go check that out.

Diving Deeper into Template-based Forms
So far, the forms we've created have been really basic, like this one. Let's take a look at a couple more forms that have a little more going on. We'll start by creating a template‑based Create Event form. We can currently view events in our application, but we have no way to create them. We did add this Create Event component, but we haven't created a form for it yet. Let's do that now. If we take a look at this component, the HTML for this is currently inline. So let's delete this and change this to use a template URL, and that will live here. All right, and let's go add that file. Okay, and we'll grab the HTML for this from our helper repo. So under app in the events folder, we have this create‑event‑component.html. And let's just grab all that and paste that in here. Okay, and since we've already gone over the basic form syntax in a prior clip, I've already taken the liberty to wire up the form stuff in this HTML. So you can see our input fields already have ngModel and name attributes, and I've already added required field validation to most of our components and the corresponding validation messages and the error styling, except I haven't added any validation to these address or onlineUrl fields. That's because the validation for the location and onlineUrl fields are a little more complex than we're prepared to handle right now, and that's because we want the user to fill out either all of the location fields or the onlineUrl field, and we can't really do cross field validation without a custom validator. And to do that with template‑based forms, we need to create a directive so that we can add a custom attribute to the fields that we want to validate. We're not really prepared to do that until Joe talks about directives in a later module. So we'll come back to this validation later after we've talked about directives. And so we've added validation to all of our form fields except for these, and notice that we have this imageUrl field that has two validators, a required validator and a pattern validator. So we've added two separate error messages that display appropriately based on which error state we're in. You may remember we did something like this before on the profile form. All right, and then finally, if we take a look at our form element, you can see we've already created a template variable for this form, and I've wired up the ngSubmit event to this saveEvent method. So let's go add that method. Okay, so over here in our component we'll add our saveEvent method here, and we'll just log out the formValues for now. And then we just need some styles for our validation messages. Let's just copy that from our profile component because they'll be the same. So I'll grab this styles array and paste that in here. All right, now, over in our template we have a bunch of ngModel bindings to these properties that don't exist. So we need to declare those in our component. But there are eight or nine of these, and I don't really want to clutter up that component that much. We can avoid that by binding to properties on an object instead. So, for example, for this name binding, we could bind to newEvent.name. So now this is going to bind to the name property of this newEvent object. So let's update that for each of these ngModel bindings. So now these are all binding to the newEvent object, and now all I need to declare over in my component is that newEvent object. So this should work just fine. All right, now we have this form that we can use to demonstrate a few more concepts. Let's take a look at it just to see the basic functionality working. Before we can do that, though, we'll have to add Angular's FormsModule to our app module You may recall doing that before, but that was in our user module, and this component is in our app module. So let's add that. So we'll just import FormsModule and then add it to our module imports here. And actually, in one of our next clips, we're going to add a reactive form to our app module, too. So let's just import that while we're here so we don't have to come back and do that. So we'll add the ReactiveFormsModule here and we'll import that here, too. Okay, let's go take a look at that. So let's refresh this form. Okay, cool. And if we touch these fields, you can see that the required field validators are working, and let's go ahead and fill this form out. Then if I open my console and click Save, you can see that our data is being submitted to our component and then logged out. But we have a small problem here. Our data doesn't exactly match our event model. If we go over and take a look at our event model, you can see that the address, city, and state fields are nested inside this location object. But if we go back and look at the data that's being submitted from our form, you can see the address, city, and country fields are right on the root object, they are not nested inside a location object. And we could deal with it and just map it to the right shape in our save method, but ideally we'd just get this submitted from our form in the shape that we want. Thankfully, Angular lets us do that in both template‑based and reactive forms, and it's really easy. For our template‑based form, we just need to wrap our location fields in an ngModel group, like this. First, I'll just add a div here, and then I just need to add an ngModelGroup attribute and set that to the name of the property that we'd like these fields nested under, which is location. Okay, so we'll just wrap these three fields in that div. Okay, let's save that, and then let's refresh this and put our data back in. Okay, so now if I save my form, take a look at this object, notice that we now have a location object inside our object submitted by our form, and inside that location object, we have our address, city, and country fields. Wow, that was easy. Okay, so that was one major concept that we wanted to demonstrate with this more complex form. And then just for fun, let's add a preview image tag so that the user can see the image when they type in the URL in this imageUrl field. This will just give us an opportunity to demonstrate interacting more with our form in our template. So, down at the bottom of our form here, we have this empty image tag. Let's bind its source property to the value of our imageUrl field. And then we don't really want to try to preview that image until the user has entered a valid URL, so let's not display it until that field is valid. I'm using ngIf here instead of hidden because I don't want my browser to try to set the image source at all until the field is valid. NgIf will prevent the image tag from even being added to the DOM, so the browser won't even try to render it. If I just used hidden, the browser would try to load the image every time the user typed in the imageUrl field, and so it would try to load a bunch of invalid URLs, so ngIf is perfect here. All right, cool. And you can see that we can tap into the validation info and field values wherever we want in the template. So this form is a little bit more complex, and you've seen some interesting things that we can do with a more complex form like this. Let's just go finish wiring up our saveEvent method. Okay, so inside our saveEvent method here, we're going to call the eventService to save our event. And we can just pass formValues straight through, since the shape of it exactly matches our eventModel. And we'll just have to import this eventService. Let's inject that in our constructor. Okay, so that's ready, except that we don't actually have a saveEvent method on our eventService, so let's go over to that, and we'll add one here. Okay, so we're just going to assign event.id of 999 for now. Of course, this really will only allow us to save one new event without having duplicate IDs, but we'll come back and make this more robust later. And then we also need to default the sessions to an empty array. And then we'll just push this onto our events array. And let's fix this typo. Okay, so now we have this saveEvent method on our eventService that will for now just add it to our events array. Okay, and then back over to the Save method on our component. Let's just copy this down here, and after we save, we'll navigate back to the events list. Now, you may remember that we added a route guard on the route for this component that looks at this dirty flag. This will actually prevent us from navigating after we save unless we set Dirty to false. So let's set that. Okay, cool. Now we can add events. Let's just go check that out. Let's refresh this and fill out this form one last time. Okay, now let's save our event. All right, cool. And you can see we got sent back to our Events List page, and we have a new Ng Spectacular event that was created using our new Create Event form that demonstrates a couple more concepts with template‑based forms.

Editing Data with Two-way Bindings
Everything that we've done so far with template‑based forms has been on pages where we are creating data as opposed to editing existing data. For that reason, we've been using the one‑way binding version of ngModel that looks like this. But what if this was an Edit Event page instead of a Create Event page? Let's just demonstrate that temporarily by changing our bindings to point to an event object and prepopulating that object with data. So right now our ngModel bindings are just set to primitives. Let's go ahead and update those to be bound to an event object like this. So we'll use event.name and event.date, etc throughout our form and notice as we do this that the ngModel value and the name value don't have to match. So here, the ngModel is bound to event.date, but the name of this control is just date. So the name is what's used to populate the form values and the ngModel binding is used for binding to properties on the component. Okay, let's just go update the rest of our fields and the location ones will be bound to event.location.address. Okay, we could go take a look at this and everything would actually be working fine. So changing these ngModel bindings didn't change much. But let's go over to our component now and add an ngOnInit. And then I'm just going to create an event object here that I'm going to prepopulate with this data. You can go ahead and pause this here and type in this data if you want to, but we're going to be deleting this in a minute anyhow. Okay, so up here, I need to declare event. Alright, so now we have a populated event property on our component. In a real application, we'd be getting this data from an API call, but this will suffice just to demonstrate this. Okay, but if we go over now and take a look at our app and go to our Create Event page, you can see our data is not being prepopulated here. That's because we're still using the one‑way data binding in our HTML. So everywhere where we have ngModel, we need to change this to a two‑way data binding or the banana‑in‑a‑box syntax like this. So I'm just going to do a search and replace and replace all of those with the banana‑in‑a‑box style. Okay. Now let's go over and take a look at our form. Excellent. Now you can see that that data is being populated. And then if I edit this data, then save it, then you can see over here that the edited data is what got saved. So you can see how the one‑way versus two‑way binding works with ngModel. Okay, this really is a create event form, not an edit event form, so let's undo what we've added here for editing the event. So I'm just going to hit Ctrl+Z and undo all these changes. And then over here, we'll just get rid of our event object and our ngOnInit, but that made for a good exercise to show how to edit data.

Diving Deeper into Reactive Forms
We just took a deeper look into template‑based forms. Let's now take a little deeper look into reactive forms. Right now, our Event Details page is a little boring except for this ridiculously formatted date, which we'll format with pipes in a little while. But eventually, we want to be able to list sessions for each event so that attendees can see what will be taught when they attend the event. So we'd like to list all the sessions here, but first we need a way to create sessions. So let's add a Create Session page that will use reactive forms. If we go take a look at our session model, you can see this is what it looks like. So it has an id, a name, presenter, duration, level, an abstract or a short description, and array of voters for people who upvote the session. Okay, so let's go create a reactive form that we can use to edit this data. We'll put that in the event‑details folder. So we're just going to add a create‑session.component here and create our basic component, and this will use a separate template file. Alright, let's go add that template file. Alright, let's go grab the basic HTML for that from our helper repo. So in app, events, event‑details, we have this create‑session.component.html. Let's grab that and paste that here. Okay, so nothing fancy here. Just the basic HTML to edit our session model. Okay, let's add this component to our barrel. Alright, and then we just need to go add this to our app.module right here and then down here in our declarations. Alright, now let's go add a route for it. We need to import it. Okay, there we go. So this page will live at events/session/new, and we should be able to hit that now. So let's go take a look. So if I go to events/session/new, okay cool, here's our new form. And you can see we have a few text fields plus a dropdown for duration and a dropdown for level and an abstract. And if you're curious about those dropdowns, let's go take a look at the HTML for that. There's really nothing special here. These are just normal select lists with hardcoded options. Now I could have these options defined in my component somewhere, and then I could use ngFor to generate these options, but we're just hardcoding them here. Okay, so let's go over to our component and define our reactive form. So first, let's import the Angular forms items that we need, and then we'll define each of our controls in our OnInit method. So let's create that here. Okay, and then we'll just set up each of our form controls for each of our fields in here, and we'll pass in empty data to each one of them and give them a required validator. Alright, and this is going to look the same for the other fields. So we're going to have name and presenter and duration and a level and an abstract. Alright, so we've added required validators to each of these. Let's also add a maxLength validator to the abstract. Okay, so there's quite a bit of validation here, and it's going to get a little more complex. So you can see how nice it would be to be able to write unit tests to verify all this stuff, something that we can only do if we're using reactive forms. Alright, so now we just need to build a form out of these fields. Okay, so there's our form. And now we need to declare each of these variables. So we'll start with the form, which we always declare as a public property so that it can be accessed in our HTML template. And let's backspace this a little bit. Alright, and we'll declare our form group here. Okay, and then we need to declare each of the fields. Before we do this, let's go take a look at the profile form that we created. So in the profile.component.html, notice that whenever we wanted to access one of the controls, we had to do it through the form like this, profileForm.controls.firstName. Well, we had to do it that way because while we made the form public, the form controls were private, and that's not really necessary. So let's go back to our create‑session.component, and let's actually declare these publicly. Okay, now these will be available to us in the HTML template. So let's go set up our bindings in the template. So first, we bind our form to our FormGroup. And while we're here, let's wire up our ngSubmit, and we'll pass in the form value to a saveSession method. Okay, lets go add that method in the component, and we'll just console‑log the formValues again so that we can prove this is working. Alright, and then back in our template, we need to wire up each of our form fields to their corresponding controls. And we wire up select list exactly the same way we do other components and then the same thing for textareas. Okay, that should do it. Let's go take a look at our form. Okay, let's refresh this and enter a new session. Okay, and if I open my console here and save this, there we go. We can see that our data is being submitted. Okay, and that data shape matches our session model. And let's take advantage of the fact that we have a session model that we can use to validate this. So we're going to eventually pass these formValues into a service that will save the session for us. And really, we could just pass that as is because it matches the shape of our session model. But let's import our ISession interface and map the values over just as a way to sanity check that the shape we're passing in is correct. So we'll import our session model. And then in our saveSession handler, we'll create a new session object and map each of the fields over from the formValues. And you can see that our editor is complaining because this does not yet match the session model. Let's just keep going. Okay, and look at that. It's still complaining because we actually are not adhering to the shape. It's saying that our ID field is missing. Well, we're going to let that be said in our service, so we'll just set it to undefined here. And then if we look at that again, it's still complaining because voters is missing, and this is important and a great example of how the TypeScript validation can help you in your coding. We actually do need to provide an empty voters array. Okay, there we go. Now it's not complaining anymore. And then duration actually is a number, and we want to cast that to a number. TypeScript isn't complaining because the formValues that are passed in our of type any, and any can be applied to any data type. Okay, and you can decide in your apps whether you want to take this extra step of remapping it to an existing model so that you get the type safety. But for now, we're just going to console‑log this out. We're going to come back and save this later, not in this clip. Okay, so we've defined the validation for our form up here, but we still need to make the error messages appear and add our error styling, so let's go do that over here in the HTML. Okay, let's add our error message fields. Okay, notice here that I'm just accessing name directly. I'm not having to say newSessionForm.controls.name like we were doing before. That's because we made these form controls publicly available in our component. And then also notice that I'm using name.dirty here instead of name.touched. The difference between touched and dirty is that if I just put my cursor into a field and then leave that field, it is touched, but not dirty. But if I start typing in a field, then it becomes dirty. I just wanted to demonstrate that dirty option in case you want to use that in your applications. Alright, let's go ahead and add these to the rest of the fields. Okay, and this field has two validators on it, so we need to add the extra piece here and the extra error message. Okay, now we just need to add the classes for our styling. Okay, and I'll add that to each of them. Okay, now let's go add our styles. Okay, and let's actually go copy those styles from another component cause they're going to be the same as the others that we've used. So let's go to our CreateEventComponent and copy these styles. We'll just add them here. Okay, and then we just need to update this here to apply to our select and text area elements. Now just one more thing. Let's just make sure we disable our Submit button when the form is not valid. Alright, so let's refresh our page here. And notice that I do not get any validation if I just touch the fields. But if I make them dirty by typing a space and then invalid, then notice that our validation shows up. And if I create a new session and then open my console and save, there we go. We're getting our data, and it's being mapped to our model. And now we have a fairly substantial model‑based form.

Creating Custom Validators
Okay, we've gotten familiar with using Angular's built‑in validators, but it's not uncommon that we want to create a custom validator to do something beyond what built‑in validators can do. That's easier to do in reactive forms than it is in template‑based forms. So let's add one to our reactive form now. Let's add a restricted words validator that prevents certain words from being used in a field. And then we'll apply that validator to this abstract field. A validator is basically just a function, and that function just returns null if the control is valid or an error object if it's invalid. So here, in our create‑session.component, we'll create a validator function that looks like this. Okay, so this function takes in a FormControl as its parameter. All right, and then this function just returns a basic JavaScript object. Don't let this TypeScript syntax throw you off. This really is just saying that this function will return on object. It doesn't matter what shape the object is. Okay, so our validation function is basically going to check to see if the controls value contains restricted words, something like this. So we'll just hard code it right now to check to see if it includes the word foo. And if it does, then it's invalid because that's a restricted word, and so we'll return an object like this. And if the control is valid, meaning it doesn't include the restricted word, then we will return null. Okay, so I've just hard coded the word foo for now. We'll change this to take in a list of eventually. But this is a simple way to demonstrate what it's doing. So if the controls value contains the word foo, then it is invalid and we return this object. And this error object typically has a key that matches the validator name. And then you can set whatever you want as the value. This will make more sense when you see how this object is used. So in this case, we're going to return the that were found, and right now it's just foo. Okay, we'll come back and make this more intelligent, but let's see how this is working if we add it as a validator to our abstract field. So up here, I'm just going to add it like this. Okay, so you can see better now that the validators array is really just an array of functions that should be run to validate the control. Let's go see how this is working. So let's refresh our new session page, and then notice that I'm still getting my required field validation. And if I type in some text here, we're valid unless that text contains the word foo, so you can see that the field is invalid because the field is turned red. But we're missing an error message. So let's go add an error message for our new validator. So over here I already have two validation messages here. Let's add a third one. And we want this to still display if it's invalid and dirty, but only if it violates the restrictedWords validator. Okay, and then our message will be restricted words found. Okay, so we've started to use our error object that was returned from our validator here. This restrictedWords keyword right here matches this restrictedWords key on our error object. Okay, so we've used the keyword restrictedWords, what about the value foo? We can also access that in our template. So we can actually use that value right here. We'll say restricted words found, and then we'll list the restricted words. Okay, so notice that abstract.errors.restrictedWords is actually that error object. It's the same thing that we're using right here and here. So, really, that errors object contains any validation errors and the values of the properties on the errors object is actually those validation errors. So let's go take a look at this. If I refresh this now and say whatever foo. There, now it says restricted words found, foo. And that foo came from our error object here. Okay, Now we'd like to be able to make it so that we can pass in the restricted words to our validator, like this. So we want to be able to pass in an array of like that, just like we are for that max length validator where we're passing in 400. Okay, there's nothing really Angular specific to do here. We can handle this with just plain JavaScript. Remember that what we actually provide to our array of validators must just be a function. So if we make it so that restrictedWords is a function that we call that returns a function, we can make this work just fine. Okay, so down here, we're going to make this a function that takes in the restrictedWords, and then we're going to have that return a function, like this. So this is just a fat arrow function from ES6 with some TypeScript typing information here. Okay, So now restrictedWords is a function that returns a function, and that function is our validator function. And now we can access these words right here, down inside our inner function. Okay, and this is going to be a little bit more complex, because here we just had a string and now words is an array. So our logic is going to look a little bit more like this. So first we'll check to see if words are passed in, and if not, then we will return null. Which, remember, makes it so this validator passes. So basically, this validator is a no op if you don't pass any words in. Okay, then we will find any restricted words that exist in our controls value. Okay, so this map function is basically looping over all the keywords and checking the controls value to see if it includes that word and then returning that word, or null if it's not found. And then we just need to filter out those nulls. Okay, So now invalidWords contains any invalid words that were found inside the controls value. Okay, and then if any invalid words were found, then we will return the restrictedWords error object. And this time we'll put all of the restricted words in it, so they will be comma separated. And otherwise we'll just return null. Okay, so up here we are using our restrictedWords validator, and we're restricting foo and bar. Let's go check that out. Okay. So I can type anything in here except for foo. Notice it says, Restricted words found foo. And if I had bar, it also finds that. All right, cool. That's all there is to creating custom validators. Now, we could make this a reusable validator by moving it out of here. Let's just do that. So let's move it into our shared folder. So over here we'll create a new file, restricted‑words.validator. All right, let's go grab that out of our component. So we'll take this out of here and move it over here, and then we'll just export this. Okay, and it looks like we'll need to import FormControl. Okay, cool. Now we have a reusable validator. Let's just add this to our barrel. All right, and then we can just import that into our component now. Okay, Cool. So now that's being passed in as an import. We can get rid of the this keyword, and everything should be working just fine. There we go. And we have a reusable custom validator. And there's a practice exercise for this clip, so go check that out.

Summary
In this module, we learned how to use data models to help with type safety, and we learned how to create and validate template‑based and model‑driven forms. We also learned how to use two‑way data bindings to edit existing data, and finally we learned how to create and use custom validators.

Communicating Between Components
Introduction
In this module, we'll get some more practice passing data back and forth between components. Now that our app is built out a little more, this will give us some more real‑world examples to work with. There's not much to introduce here, so let's just jump right into code.

Passing Data into a Child Component
Let's take another look at passing data from one component into another. Right now, our Event Details page is showing basic information about each event, but there's something missing here. Our events have sessions that we're not displaying yet. If we go over to our event.service and look at the event data that's in there, you can see our events have these session arrays. So let's work on getting those displayed. So over here in our event‑details HTML, we want to display those right here right after we show the basic event details information. And so let's add a divider line, and then we'd like to be able to just display our sessions with an element like this. So we'll create a component for this. But how is the SessionListComponent going to get its array of sessions to display? Well, we have that data available to us on the event object that we're already binding to on this page, so we'd like to just pass it into this component. If you remember from earlier, we can just pass data into a child component like this. So this is basically saying I want to bind the session property of this SessionListComponent to the sessions array on this event object, and that event object is in our EventDetailsComponent. Alright, so let's go create our SessionListComponent. Okay, and here's what that will look like. Okay, so there's this session‑list selector that we used in our EventDetailsComponent, and then this will use a separate template file. Alright, now we just need the Component class. And then if we go back and look at our event‑details.component.html, you can see that we are expecting there to be a sessions property on this SessionListComponent. So let's add that, and that will be an input property. Alright, and we'll have to import Input and ISession. Alright, and that's really all there is to this component other than the HTML template, so let's go add that. Alright, and let's go get the HTML for this template from our GitHub helper Repo. So over here, there's this app folder. And then in events and event‑details, there's this session‑list.component.html. Let's grab that and paste that in here. Alright, this is pretty simple. So we just have this ngFor that is going to loop over each of the sessions in the array that was passed into our Input property and then display each one. Okay, so we just need to add this component to our event‑details barrel, and then we just need to add that to our app.module. So we'll import it here and add it as a declaration here. Okay, cool. Let's go check this out. So if we refresh our Event Details page here, alright awesome. Now we have all of our sessions displaying, and they're displaying for all of our different events. So that's another great reminder of how easy it is to pass data from one component into a subcomponent.

Passing Data out of a Child Component
We just saw how to pass data from a parent component into a sub component. But what if a sub component needs to pass data back up to its parent? This is typically done in response to some event on the child component like clicking a button, and this is made possible using output parameters. If you remember, we created a create‑ session.component previously, but it isn't completely wired up, and it's only available in our application by typing in the URL. And when you click Save, it simply logs the session to a console. Let's make it so that we can add sessions right from our event details page. Okay, so on our event details page, let's start by adding a little header above our sessions with an Add Session link. Okay, so this will just add a little sessions header with an Add Session link. And that anchor tag, when you click on it, it's going to execute code in our component. So it has no age ref. But when an anchor tag has no age ref, it won't have the pointer cursor when you hover over it. So let's just add a style for that in our component. So we'll just say anchor tags should have a pointer cursor. Okay, and that link is calling addSession on our component, so let's create that method. Alright, and all this addSession method is really going to do is put us into an addMode. So we're just going to toggle a flag on our component. Alright, and we'll need to define that property. Alright, now we can use that over in our template. So if we're in addMode, we're going to hide our session‑list. Okay, so we'll only show that if we are not in addMode. And then instead of the session‑list when we're in addMode, we will show that create‑session.component. Alright, but that create‑session.component actually still needs a selector, so let's add that. So this is the create‑ session.component that we created earlier. Alright, and then we only want to display this if we are in addMode. Okay, let's go check that out. So let's refresh and go to event details. Okay, so you can see, well, here's our header, and we have this Add Session link here. So if I click on that, then we get our Create Session form. And this is where our output parameters come in. Our sessions need to be added to the current event that we are looking at in the event details page. So when we click Save here, this session that we add needs to be added to this event, and then this event needs to be saved with its new sessions. And so when we click Save on this Create Session form, we just want to pass that session data back to the event details product and let it handle all of that. So over in our create‑session.component, we just need to create an output parameter for our parent component to bind to. So right here, we'll add our @Output property. Okay, and we'll have to import Output. Okay, so we're going to use this @Output property to emit a message back to our parent component when the user clicks Save. So the saveNewSession @Output property is going to be an event emitter, and we'll have to import that too. Okay, so now when we save our session, instead of just console logging it, we will use our saveNewSession event emitter to emit an event. And the data that we will emit is the session itself. Okay, so now we have an output parameter to bind to. Let's go bind it to our event details page. Alright, now we'll just go right here. So, we're going to bind to the saveNewSession event. And when that's fired, we're going to call saveNewSession and pass in the event that is emitted. Okay, so that event that's being passed along is actually our session object. So let's go create our saveNewSession method on our event‑details.component. Okay, and a session is going to be passed into here, and it should conform to the ISession model. Alright, let's go import ISession. Okay, if you remember on our Create Session form, the session ID on this is going to be undefined, so we need to assign a new session ID to this session when it comes in. So we'll get the max session ID off of the sessions on the event and then increment it and assign that to our session ID. Okay, so this is calling Math.max with all of the session IDs from the session's array, so that should return us the maximum session ID. And then we'll just set the ID on our new session. Alright, and then we'll just add this session to the event. Okay, so we're just pushing that onto the session's array. Alright, and then we just need to call updateEvent on our eventService to save this event. Alright, and then remember, we're toggling an addMode for whether or not we are currently adding a session. And so let's toggle that back to false since we're done adding, and that should display the session‑list again. Okay, so now we need to go add that updateEvent method on our eventService. So let's open that up. And we don't want to use this saveEvent because that's for saving new events. We just want to update this existing event, so we will call updateEvent here. Okay, so this will just need to find the existing event in the array and replace it for now. Okay, so our create‑session.component now emits a saveNewSession event, and we are binding to that in our event details. And when that event is emitted, we call saveNewSession on our event‑details.component, which adds the session to the event and then updates it. Let's go check that out. Let's refresh here. Okay, so here is our list of sessions. Now let's add a new session. This will be a 1‑Hour Beginner Level session. Alright, and then when we save that, you can see we exited addMode. And if we come down here, we have my new session on this event. And if we go back to the events list page and come back in, you can see it's still there. So it did save it in memory to this event. Okay, awesome. Now there's just one more output property that we need. We need to honor this Cancel button. So essentially, when we click Cancel in our create session child component, we need to let our event‑details.component know so that it can exit out of addMode. So over in our create‑session.component, we will add another @Output parameter, and we will call that cancelAddSession, and that will also be an event emitter. And then we'll wire up the Cancel button click on this component to emit that event. So over in our HTML, we need to just wire up the click event on our Cancel button, and that will just call cancel. And then back in our component, we'll handle that, and we will just call emit on our cancelAddSession emitter. Okay, and then over in our event‑details.component HTML, we'll just need to bind to that. Okay, so we're binding to that output property on the create‑session.component, and when it's emitted, we will call cancelAddSession on our component. Oh, let's go add a method for that, and all that needs to do is set addMode to false. Alright, let's go check that out. So let's refresh our event details page, and we'll click on Add Session. And now if I hit Cancel, you can see it takes me out of addMode. Okay, great. So that's a great example of how to use output parameters to pass data back to parent components.

Summary
In this module, we took a deeper look into inter‑component communication, including how to communicate with child components and how to communicate back out to parent components. These are important concepts to understand since communicating between components is a common practice. And we're now prepared to take advantage of this in our own applications.

Reusing Components with Content Projection
Introduction
In this module, we're going to cover creating reusable components with content projection. Any component can be reusable. But what makes content projection so powerful is the ability to change the content inside of a component based on the needs of the application. We're going to start off by looking at content projection itself. And once we get a handle on that, we're going to look at how multiple slot content projection works where we can project content into more than one place. Content projection is a feature where you can have a component with some kind of visual wrapper, shown here in orange, but the content within the wrapper is decided by the developer. That lets you take a common wrapper like, say, a dialog box and reuse it with different pieces of content. That way, you don't have to reimplement common functionality. Again, in the case of a dialog box, this would be like the cancel and save buttons or the positioning logic. This is called transclusion in Angular 1. With multiple slot content projection, things work exactly the same as with regular content projection, but this time we have more than one slot into which the variable content can go. Here I show these different slots side by side, but their arrangement could be anything. They could be side by side, on top of each other. or anything really. Also, we're not limited to two slots. It could be three or four or any number of slots, although two is by far the most common after one. We'll see exactly how to do content projection and even multiple slot content projection in the following sections.

Content Projection
Here in our events, if I click on a specific event, we can see a list of the sessions. And I'd like each of these session items to be collapsible, so if I click on this little well here that it would collapse and just show the title of the session and not the entire session. Now, of course, I could just go into the component here and add that functionality so that it can collapse and show just the session. But this sort of functionality is actually a fairly reusable type of functionality, a component that can show a title and a detail and collapse to just the title on the click and then expand to just the title on the click. So let's implement that with a new reusable component. I'm going to go into the session list page and start in the HTML. And here, I'll define how I want this to look. Right now I've got my div with my column of 10 right here and then this div with a class of well. I want to replace this with a new component. So let's write in the HTML ourselves. This will be a collapsible well. That'll be the name of the new component we create. And, of course, we have to tell it what the title is, so we'll bind to a title property, and this we will set equal to the session.name. And because we've done that, we don't need this h4 anymore, so I'm going to remove that. And down here, instead of a close div, we'll have a close collapsible‑well. Now this is what our HTML will look like. Let's now create the component file. I'm going to create that in the common directory since this is a common component that could be used in any area. So in my common directory, I'll create a new file called collapsible‑well. It is going to be a component, so I'll have to import Component. Now just a quick note. Notice that I put a semicolon at the end of the line of code that I typed. I'm more of a semicolon user. Jim's not so much. So you see some inconsistent styles here for a bit. We're going to address that later on in the course. Then we'll create the Component itself. This selector is collapsible‑well. And the template, we'll define inline. We know that it's going to be a div, and that div's going to need a click event to handle when you click to toggle the visibility of the body. So let's go to click event, and we'll just call a method named toggleContent. Then we'll give it the class of well and also pointable. Let's close up that div. And we know that our title was in an h4, so let's put that h4 for here. We'll give it a class of well‑title, and we'll bind to the title property. And finally, we want our content to go here. For now, I'm just going to leave this as a comment. Of course, that comment doesn't actually work because this is HTML, but we'll come back to this in just a second. Now let's create our class, and we know that it has one input property, which is a title and a type string. We need to bring in input as well, and we know we need that toggleContent method. And in this case, we just want to toggle some visibility. So let's create a visible property. And inside of here, we'll set it to the opposite value. And now we've got the basics of our component, but the magic is going to be back up here on line 8. This is where we want our content to be. So we're going to use a special tag, which is the ng‑content tag. This element is what tells Angular whatever content exists in side of my component, which we can see back here in our session list, it's all of this HTML right here, I want you to put it right here and put it inside of it. So we can just close this up, and that's all we need to do in order to get the content projection to work. But of course, we have our toggleContent functionality, and to make that work, we're going to want to toggle the visibility of this element itself. So let's just put an ngIf right here, setting it to visible. And now our functionality will work to toggle that body content. Let's go back and save our SessionListComponent. And of course, we have to add this to the module. So let's go to our module. And down here where we've got the common toastr service, this is probably the place we want to bring in this component as well since it's inside the common directory. I could go in and create another index file, but just for simplicity, I'm going to add its own line. And then, of course, we need to take this and add it to the declarations. So I'll just add it to the end. Now let's save that change, and we can go back out to our website, and let's refresh. And now if we've done things correctly, if we click on one of these session items, we can see that it's collapsing down to just show the title. And there is how we can use content projection to make a reusable component. There's a practice exercise for this clip, so take a moment to do that now.

Multiple Slot Content Projection
Our collapsible‑well is working, but let's now add another piece of functionality. I want to be able to indicate which of the sessions is extremely popular and has a lot of votes. I'd like to do that by adding a little on fire icon next to the title of the session right about here. To implement this, I'll need to use some business logic that shows a flame icon if the session has a certain number of votes. This is obviously specific to a session. If I were to add this kind of logic to the collapsible‑well, it would tie it too closely to this specific implementation and not make it as generic and reusable as I'd like it to be. The problem is that our collapsible‑well currently can only bind to the title, which is a string. Here where we're using the collapsible‑well, I can send in my session name as my title, but I'd like to have a little bit more logic to show up inside of this h4 right here. I don't want just a simple h4 with a simple binding. I want some logic in there. And to implement that inside of my collapsible‑well wouldn't be a good idea. So instead, what I'd like to be able to do is have another area inside of my collapsible‑well, one for the title and one for the body, both areas being able to contain whatever HTML I want. Now this won't work exactly as is because Angular doesn't understand what to do with these title and body sections. But we're going to come back and address that in just a minute. For now, we're going to leave these tags the way they are because they're illustrative and useful to us to understand what we're putting where. So we got our body. Let's talk about how we'd implement the title. And I want the name of the session to show up the same way we've got it bound right here, but I want it here in this section. And then next to the name, I want a little icon that's going to show up, a flame red icon, that will show up if we have at least a certain number of votes. I use the i tag for that with an ngIf that will say we only want this to show up if the session.voters, which is the array of voters, has a length of greater than 3, so if 4 or more people who voted for a session. And we'll use a class of glyphicon and glyphicon‑fire to use the fire icon, and we'll set that to red with a style attribute, and there's our fire icon. Now we can get rid of the title binding because we're no longer getting our title that way. We're now getting it in the section. And again, Angular 2 doesn't understand this title and this body attribute. Obviously, body is a well‑known HTML attribute, so we can't have this as our body. Title, we don't want to use that either. We need to tell Angular 2 that this is the title section, and I want to stick it in a certain place. And this is the body section, and I want to stick it in a certain place. Let's go back to our well component and look at that. Here we've got our ng‑content tag that allows us to stick in whatever content is going to be inside of the collapsible‑well. And then, of course, we're bringing in the titles and input and were binding it right here. So let's change this to work with, instead of a bound title, any HTML that we want. What we need is another ng‑content. We still want it to be inside of an h4 tag, but I'm going to change this class and remove it from the h4 tag and just leave that as wrapper. And instead, inside the h4, I'm using ng‑content. And this is where I want my title to go. I want my title to end up right here and then my body to end up right here. And back to our session‑list.component.html, it's this piece of HTML that I want to show up right here. So we've got to tell Angular 2 that this piece of HTML should show up inside of this ng‑content; whereas, this piece of HTML here should show up inside of this ng‑content. And we could do that by using the optional select attribute with an ng‑content tag. And the select attribute works like any CSS selector. So I can give it a class selector with a dot. I can give it an ID with a hashtag. So I can use the CSS selectors that we're familiar with. So I could go in here and change this title to a div, and let's change that as well, and we'll do the same thing with body. And instead, let's give this div a class of title and this div a class of body. And now, if I set my selector here to .title and add a select attribute to .body, then Angular 2 will match up the correct content with the correct piece of HTML based on the class selectors. Now we used class selectors a lot in the past to do things like this, but there's always the possibility that a class that we put in here could conflict with something that we actually have in a CSS file. So there's another way that we can do this. Instead of giving it a class, let's give it an attribute. Let's give this div an attribute of well‑title, and we'll give this div an attribute of well‑body. Now in order to select that, we change this from .body to the attribute selector, well‑body. And the same thing here, well‑title. I personally like this selector a little bit better than the class selector just for the reasons that I mentioned. It doesn't give us a potential conflict with CSS classes. And I also think it stands out a little bit more, saying that there's something about this div that has to do with being a well body rather than hiding it inside the class, especially if we had a reason to have other class tags in here like pointable or something else. We'd have to put our body class, our selector class, alongside actual style classes, which I really don't like. So this is the method that I recommend. As of right now, the style guide doesn't have any opinion on how you do this. That may change in the future, so you can always refer there for more opinions. But this is what I like is to use an attribute like this. So let's save this HTML here. We'll go back to our component. We can make one further change. This title we don't have to bring in any more is an input. And now if we go back to our HTML and refresh, the session lists look the same. They're still collapsible, but we've now got a little fire icon next to the sessions that have at least four votes. And that's how we can use multiple content projection with Angular 2. There also is a practice exercise for this clip, so you can take a moment to do that now.

Summary
In this module, we saw how to build a very specific kind of reusable component. Reusability is very important when programming, and anything we can do to reduce duplication of code is going to help us out. With content projection, we can create components whose reusable pieces are limited to just the external portions of the component, and the inner pieces could be different based on the needs of the application. This is content projection, and it is an important tool to have in our belt when developing applications with the Angular 2 framework.

Displaying Data with Pipes
Introduction
In this module, we're going to learn all about how to display our data. The focus will be on using pipes to do this, but we'll also see that for some tasks we won't use pipes at all. We'll start out by looking at some of the built‑in pipes available and Angular to format our data the way they want it. We won't look at all the pipes, instead, just a few of the more common ones with a focus on how to use them. It'll be up to you to look at what pipes are available in Angular. After that, we'll look at how to create a custom pipe to get data formatting functionality that isn't already built into Angular. Then we'll look at how to filter data and how to sort data. In Angular 1, we used to do this with filters, in Angular 2, things are different. For those who are familiar with Angular 1, they'll be used to using filters for three different purposes, formatting data, sorting lists of data, and filtering lists of data. The filters in Angular 1 did this job beautifully, and fortunately, there was a problem with two of these three jobs, sorting and filtering. There were potential performance problems. Not everyone saw these issues, but they were lurking and would show up in the right instances. As a result, pipes in Angular 2 don't have all the same functionality as in Angular 1. They still handle formatting, but they aren't used for sorting or filtering lists of data. We use a different mechanism. We'll still cover how to sort and filter data in this section of the course, though, and we'll see how to do that in just a little bit here, but first, we'll look at pipes, they are powerful, useful, and generally very simple.

Using Built-in Pipes
Now there's a few problems on our All Events page that we can fix with pipes. I want to avoid the most obvious one, the problems with formatting dates, for just a second and instead fix an easier one, which is the names of the events. Notice that the names of the events are cased however the data was given to us. I'd like to fix that. I want all events in uppercase. So we can go over to our code and into our event‑thumbnail.component.ts And here we have the event name. We can add a simple pipe of uppercase. This is one of the built‑in pipes in Angular 2, and I'll save that and go back and refresh the page. And now all the names are in complete uppercase. That gives our page a little bit more of a uniform look. And in the details, we've got the same problem. Here, the name is not uppercase, so let's go into the details page. And here you're going to go into the HTML component and add the same uppercase pipe, and we'll refresh. And now the name is all in uppercase. Now we've got the obvious problem, the date. These dates are obviously not the way that we want them formatted. So we're going to go into the Date, and we're going to add a date pipe. We'll just simply add date, save that, and refresh. And we can see that already the date is formatted much nicer than it was before. Now this is the default formatting for the date pipe. We can actually change the formatting using parameters. Parameters on pipes are very simple. You put in a colon, and then you can add the parameter that you want. In the case of the date pipe, the parameter that it takes in is a string. And there are several values for what this string can be. There's some pre built‑in values like short. That's how the short looks. Or just shortDate, which gets rid of the time. And that's what I want to use. You can also mess around with values like y for the year, capital M for the month, d for the day. And you can add in slashes on that if you want, so let's make this change. And we'll see the year, a slash, the month, then the day. We're just going to go back to shortDate. It's a nice, simple format, and we want to make that same change in our thumbnail component. Okay, and our dates are formatted nice. Now there's one more piece of data I want to put a pipe on, and that is the price. Notice that the price looks fine. It's got the dollar sign and then the price. The formatting is just fine. But the problem is that we've hard coded in our dollar sign right there, and I don't want this hard coded in. I want this to be specified. That opens me up later on in case I want to use different units. I can parameterize that, and some events can be in dollars, some events can be in pounds, some can be in euros. So we're going to change this to have a pipe of currency, and we'll get rid of the dollar sign. And, of course, we have to escape that, so we'll get rid of the backslash as well. And we're going to add some parameters to the currency pipe. We want to specify that this is in US dollars, so USD. And here is where we could be reading this from our data. I'm just going to leave this hard coded to USD for now, but it gives us a place that in the future we could use different units. So save that and refresh the page, and we're now back to seeing the dollar signs. And let's make that same change inside of our details page. Change price to currency filter with USD, and get rid of the dollar sign, and save, back to the page and refresh. And we've still got the dollar sign showing, but we're now using a pipe to format the price. And those are some of the more commonly used built‑in pipes in Angular 2. There are homework assignments for this clip, so go ahead and do those now.

Creating a Custom Pipe
Another formatting problem that we've got inside of our application is the duration. Currently, it's just showing a number, and we actually want this to show what the actual duration of the session is. If we look at the Add Session page, we can see that duration is selected and it has one of four options, Half Hour, 1 Hour, Half Day, Full Day, corresponding to 1, 2, 3, or four. So let's fix that. Let's display our durations as their string value, not as their numeric value. Unfortunately, a duration pipe is not built into Angular2. Of course, it's not because this is very business specific, so we're going to have to create one. Go back into our code and underneath the shared folder under Events, we're going to create a new file called duration.pipe.ts. And we're going to import from Angular Core Pipe and PipeTransform. And now we can use the pipe decorator and that just requires one piece of information, which is the name of the pipe and this pipe's name is going to be duration. And now we'll export a class, we'll call it DurationPipe, and that implements PipeTransform, and we're getting an error because it's not implementing the correct piece, which is a transform function, it has to implement a transform function. And this transform function takes in one parameter of value. In our case, we know this is a number, so we're going to type this as number and it returns a string and now string is underlined because we're not returning a string yet. So let's create a switch on the value, and in the case that this is a 1, we're going to return the string Half Hour and we need 3 more cases. And finally, we need a default so we're going to just, in that case, return value.toString, and our pipes have been created, but we can't just go into our session‑list.component and under duration, add the duration pipe. If we do, we'll get an error and the error pops up and it says the pipe duration could not be found. We have to make Angular2 aware of this duration pipe. So we're going to go into our index barrel file and we're going to export * from the new file we created, duration.pipe, and then inside of our app.module, we're going to import this duration pipe, it's from this events/index, so I could just add that here, and then we need to add it to the Declaration section. So I want to go past these components, and add it last. If we go back and refresh our page, we no longer get an error and our duration is now displaying as its string value. So that is how we create a custom pipe, it's very simple. All you have to do is implement a transform function that takes in the input value and returns the output value. There is a homework assignment for this concept, so if you want to do that, go ahead and do it now.

Sorting and Filtering Overview
In this section, we're going to get an overview of how we filter and sort data in Angular 2. There's no built‑in OrderBy or FilterBy pipe in Angular. So in this section, we're going to dig in a little bit so that we can understand why. But in order to do that, we will first need to talk about identity and mutability, which is the opposite of a current hot topic you've probably heard about, immutability. Once we understand those concepts, we will talk about why in Angular we don't use pipes for filtering and sorting. It's helpful to understand that variables that contain primitive data, like numbers, are kept in a specific kind of memory where the variable name and the data are together. I've created a diagram of these different memory slots shown in orange. These are the variables a and b, which we can see the code on the left has assigned each of them to 3. This creates two different variable slots, each containing that value of 3. When I compare them, I get True because 3 is 3, and with primitives we just compare the values. Now if I assign a new variable c to a, it creates a new slot named c that has a 3 in it. When we compare these variables, again, they return True because they contain the same value. But when we change the value of one of them, so let's assign 4 to a, the effect is that the variable slot for a now contains a 4, but c and b still contain 3. A is now different from b and c, and if we compare them, they return False. Object identity, on the other hand, is different. Objects are stored differently in memory. Object variables don't contain data like they do with primitives. They are pointers to the data. Here I've got an a variable and a b variable that each point to an empty object. In this case, just like with primitives, I created two different values, which you can see in the code on the left. The big difference is that when I compare them, the result is False. With objects, JavaScript doesn't just care if the values look identical. They are two different objects, so the comparison returns False. By the way, none of this has to do with either double equals or triple equals. That's only about type conversion, so don't think that any of this is different depending on which comparison you use. So now, if I create a c variable and assign it to a, it behaves differently from primitives. It doesn't create a new empty object. It just points c at the same value as a. And, of course, this will return True if we compare them because a and c are now pointing at the same exact object. Now we can change a. With objects, we change them by mutating the object. So here I'm adding a var1 property to the object that a points at. That changes the actual data. Notice that c still points at this data. So now if we compare a and c, they are still the same object, so they still return a True. Let's back up now. Instead of mutating the object by adding a property, let's assign a to a new object. This then creates a new memory slot with that value and a no longer points at the old slot. It now points to the new slot, and now it's obvious that if we compare a and c again, they're different. C still points to the old object that a used to point to, but a now points to a new and different object. The next concept we need to understand is mutability and how that affects change detection. Mutability is the fact that things like objects can change. With ordering and filtering in Angular, we're obviously talking about lists of data. We order and filter lists. In JavaScript, lists are implemented with arrays, so we'll start talking about arrays. Remember, arrays are just a specific kind of object in JavaScript, so all the rules that we learned about identity with objects applies to arrays as well. Here, I have a simple array with two items in it. These are users, Dave and John. If something happens in our program, Angular needs to know what it should rerender. So it runs through a change detection cycle. Let's say that we delete the John user. Now, Angular wants to know if the array is changed so that it can display the new set of data on the page. You might think it could simply check the length property. I noticed that the length used to be 2, but is now 1. But what if in addition to removing a user, we added an entirely new user. In that case, the length of the array hasn't changed, but the data has. Notice that we didn't change the second user object. We truly deleted it and added a new user. Now imagine this isn't an array with two items, each with only one property, but instead it's thousands of items with dozens of properties each, a typical scenario we'd want to filter and sort. The algorithm to compare the new values in the array to see if it has changed is a very long and complex algorithm and can end up taking a long time to run. This is one of the core performance problems in Angular 1. This is mutability. Objects and arrays in JavaScript are mutable. They can change any time without changing their identity. Now let's complicate the matter with a pipe, which we're trying to use to sort our data. The situation is the same for filtering, but we'll use sorting as our example. Here we have our user array, but we're going to run the data through a theoretical sorting pipe so that the data can display sorted. We run it through a pipe, and the data is now sorted. That's great, but what if we change our source data? Here, we've changed the Dave users name from Dave to Ralph. Now the resulting sorted data is incorrect and out of order. We want the displayed update. Angular needs to know about that change. But remember that to tell if the array has changed, it has to go through each item and each property to see if things have changed. This can be a rather expensive operation. So by default, Angular only runs a pipe when the identity of the source data has changed. Remember that in past sections we were running primitive data through pipes, strings, numbers, and dates. So this works great because comparing an identity is so quick. You can do it hundreds of thousands of times or even millions of times every second and still have plenty of CPU cycles left. But with filtering and sorting, the source data will be objects. So the identity isn't going to change. So the pipe isn't going to be rerun, and therefore, the display isn't going to get updated. There is another option. This is called an impure pipe. Impure pipes run on every cycle of the change detection engine. This is a problem because that means that the sorting or filtering operation you write will now run unnecessarily every time an event happens in your application. Let's say you're listening to the mouse move event. Every time you move the mouse around, your pipe is going to execute and produce the new filtered or sorted view of the data multiple times, possibly hundreds or even thousands of times. Don't forget that the results have to be rerendered to the DOM. This method of executing the filtering or sorting code every time change detection runs is how Angular 1's filters worked. And this is one of the reasons that Angular 1 often had performance problems. So even though Angular 1 let you shoot yourself in the foot this way, in Angular 2, that ability has been hidden. Pipes are no longer recommended as the way to filter and sort your data. Now the recommended way is to filter or sort your data in the component that displays the data. That way, you can update the filtered or sorted list whenever the source data changes, which you will know about since it's your code that has to actually change the data. It also means that instead of a generic filtering or sorting method that has to work for every scenario, you can write this code yourself so that it can be customized to be efficient, and that's what we're going to do in the next sections. We're going to add filtering and sorting to our application, but we're not going to use pipes even though we're in the module about pipes. This functionality is very common, and we need to understand how to do it, but we also need to see how to do it correctly.

Creating a Filtering Display
In this section, we're going to add filtering to some of our data. I want to filter our sessions list. If we look at a list of sample sessions, we can see that each session has a level. This session is an intermediate session. This one's also intermediate. This one's advanced, and this one's advanced, and the last one is a beginner. So let's put four buttons right up here at the top, and the first one will be All. That'll be selected by default. Then we'll have Beginner, Intermediate, and Advanced next to each other, and whichever button you select will filter the sessions list to just the sessions that match that level. So we're going to go to our code, and we're going to start in the event‑details HTML page. Right here is where we're going to put the buttons. We're going to stick them inside of this div here. So let's start out by creating are All button, and then we want to put a binding to set which button is active. So we're going to use the class.active binding. That binds to the active class. So the active class will exist on this element if the following condition is true. Let's pause and keep this unfilled in for the moment, and we'll come back to it. Next, we're going to need a click event, and inside of our click event we're going to set our filter condition. Again, we're going to pause and come back to this in just a minute. And finally we've got the text. Okay, so there's our first button, and this one will be Beginner, this one'll be Intermediate, and the last one is going to be Advanced. Now, let's talk about how we're going to implement this, and that will dictate what we put inside of the class.active, binding and the click binding as well. Let's go into our component, and here we've got the EventDetailsComponent class. This is where we want to implement our code. So what I want to implement is a filter property. I'm going to create a new property on this component, and we'll call this filterBy. This is going to be a string, and I'm going to default it to the value all. I'm just going to use lowercase. It's not going to match the casing of the word in the display. Now this filterBy property starts off with the value of all, but it will switch at a certain point to beginner, intermediate or advanced. And we'll just use lowercased strings for those. Save this and go back into our HTML. And we want our class to be active when the filterBy property equals the value all, or the string all, which is why I put it inside the single quotes here. And the same thing when we click this button, we want to set that filterBy property to the value of all, so we're just going to put that inline. We're just going to set it right there. Now that we know what we want inside of each of these, we can set these for each of the other three buttons, so let's start with the filterBys. This will be Beginner for the click event, Intermediate, and finally, Advanced. And then we'll also set the class binding, again beginner, scroll that down a little bit, intermediate, and advanced last. So let's just go back to our HTML page and take a look at how that looks. Okay, we've got our buttons showing up. The All has the active class applied to it. Notice that there's no gap in between the buttons and this first session. It almost makes it look like tabs. Let's put a little bit of a gap in there. We're going to put in a style. We'll just give it a margin‑bottom of 10 pixels, and let's look at that. All right, that looks okay.

Filtering Data
So now we need to change the data. We need to pass this setting, this property, filterBy property, into the session‑list that we've got, and down here, we've got this session‑list component right here that we're passing in at sessions. So since we're already passing in the sessions, let's also pass in what the active filter is, and we'll let the session‑list itself be responsible for the filtering. We'll just tell it what it should be filtered to. So we're going to create a new property binding, and I'm going to call this filterBy, and we'll set it to our filterBy property. So this right here is this property here, and this is a property on the session‑list component. So let's save that and go into our session‑list component, and we'll create that Input property. We've already got the sessions coming in, so we'll create a new Input property, and this is called filterBy, and that's a string. And so now we're passing the value into this component, but we need to take action on that value, and we need to change what sessions are being showed when this filterBy property itself changes its value. And there's a great way to do that. There is an interface called OnChanges, and if we implement that interface in our class, then what it wants us to do is implement a method called ngOnChanges. This ngOnChanges method is going to be called every time one of the input variables to this component gets a new value. And that's exactly what we want. We want to be able to react whenever our filterBy value changes. Now the ngOnChanges can actually be called before any of the other data is set. So remember again that our sessions are being passed in and we don't want to react and execute any code here in the session‑list in the ngOnChanges event if the sessions haven't been set yet. So we're going to first make a check, and we're going to say if this.sessions, which is just a quick and dirty way of saying if we actually have sessions set. If they're not set, this is going to be an undefined value and therefore it'll be falsy, so this won't pass. But if it is set, then I want to filter my sessions. So I'm just going to call a method on the same class named filterSessions, so this.filterSessions, and I'll just pass in that filterBy setting. Now I don't have to pass in the setting because it's available on the class, but it does make the method itself stateless. So let's implement that method, filterSessions, when passing in our filter value. If the filter value is set to the value of all, a string of all, then we don't want to do any filtering at all. We just want all of the sessions to be visible. Otherwise, we want to filter our sessions to just the sessions that have a matching level. And the reason I chose those strings is because the data is the same way. It has different casing, so we'll have to do with casing, but that way I could filter to just the sessions that have a matching level. So let's talk about filtering our sessions and what that displays like. We go and look at our session‑list.component, and right at the top we've got this ngFor that says for every session of the sessions variable, we've got a div, or essentially a row. So I want this variable, this list of sessions, to be a subset. Now I don't want to actually go in and modify the sessions property itself and give it a subset because then I might lose the entire set of sessions, so I'm going to leave this alone. Instead, let's create a new property, and we'll call it visibleSessions. It will also be an array of ISession, and we'll default it to an empty set. And that is what we're going to bind to and display on our page. So I'll go back into the HTML, and instead of sessions we're now going to be displaying visibleSessions. Save that change. And back here inside of this filterSessions method, that's where we're going to change what the value of the visibleSessions array is. So if the filter is set to all then we want this.visibleSessions to be all of the sessions. Now you might think that we just want to set it equal to this.sessions and just set it equal to that variable, but we don't. We want this to be an entirely unique list, or duplicate. So we want to really clone the array itself, and there's a quick and easy way to do that with the slice method. We're going to just slice it from the very first element, and that creates a complete duplicate of the array with all the same elements. Then in our else clause, we want to set this.visibleSessions to some subset of the sessions array. And there's a nice method on arrays called filter, which creates a brand‑new array, and we'll pass in a little lambda. We're going to take in the actual session, and we're going to return the sessions level. And let's lowercase that, so we're going to go toLocaleLowerCase. And we want to return true if that matches the filter value. And we'll return false if that doesn't match. So anything that matches true, or returns true, is going to be included in the new array. Anything that returns false will not. So therefore, any rows or any sessions that have a level that matches the matching word, beginner, intermediate, or advanced will then be included in the new visible array, or visibleSessions array. And anything that doesn't is not going to be included. So now we've got a brand‑new array that's being copied, and that's what's being displayed. So let's save those changes and go back to our HTML and refresh, and we're defaulting to All. Let's just check and make sure, yes, it is still displaying all five of those sessions. And let's click Beginner, and immediately you can see that only the beginner session is now visible. Let's click Intermediate, and now we're seeing the two intermediate sessions. And Advanced, we've got the two advanced sessions and nothing else. And back to All, and we're now viewing all of our sessions. So there's how we can implement filtering ourselves inside of our component. And notice that the code did take a little bit of thinking through, but it's very efficient code. Nothing changes unless we take the correct action. So no matter what events we're listening to inside of our application, none of this code is getting run unless we take an action that actually applies to filtering sessions, so in other words, clicking one of these buttons. Now we implemented this functionality by adding code to the session‑list.component, and that's the component that's in charge of displaying the sessions. So all of the logic is essentially inside of there. We didn't have to implement that code there. We could've implemented the code in the parent component inside of the event‑details.component. It's really up to us to decide which component is responsible for the filtering. Does the event‑details just pass a filtered list into the session‑list.component? Or does the session‑list.component receive what the filter is and then filter its own view? So is this component a little bit smarter or a little bit dumber? So really, the choice is ours as to where we want to add the logic based on which component we feel like should be responsible for the functionality. There's a couple homework assignments for this section, so go ahead and do those now.

Sorting Data
Now that we've got filtering implemented, let's add sorting functionality. We want to add sorting pretty much the same way we added filtering, with a couple of buttons. I'm going to put a couple of buttons right here to the left of our existing buttons, and one will be for sorting by votes and the other one will be for sorting by the name. Those seem like the two most logical ways that users might want to view sessions is either by name in alphabetical order or by vote to see the highest‑voted sessions first. Now if I'm going to add these buttons, I could already see that I might have a space problem. These buttons here are kind of big and they're taking up a lot of space, so to add two more buttons over to the left as these slide over is going to make this whole thing seem a little bit crowded. So let's make a small visual change. I want to take all of these buttons, and I want to wrap them into a button group. And we'll go with a small group of buttons, so btn‑group‑sm, refresh our change, and that's much more manageable. So let's add the exact same thing, a button group. Again, we want to set the active property, so we're going to bind to class.active. And instead of filtering, we're going to be sorting, so we'll have a sortBy property. And we're going to have two potential value's names, so we just use name, and then that button will be By Name. We also need a click event and in our click event we'll just set our sortBy property, which doesn't exist yet, to the value of name. And we'll need a second button, and this one won't be by name, it'll be by votes. These will be, again, magic values. So we've got those buttons created. Let's go back and look at our visual display and see if it looks okay. Alright, there's just not enough space in between these two groups of buttons, so let's add a little extra space. I'm going to set the right margin to be 20 pixels, and I think I might want to move it a little bit more to the right as well, so I'll set a left margin as well of 20 pixels, and let's see how that looks. Alright, that's fine. Back to our code, now that we've got our sortBy property set, we've got to implement that in the code‑behind. So we just need to set a sortBy property, which is also a string, and we'll default that to votes. And, of course, we have to pass that into our sessionless component, and we'll pass in our sortBy value. And now we can go to our sessionless component and add this new input property, sortBy. So in our ngOnChanges event, after we filter the sessions, let's also sort them. So we'll just check and say, alright, does this.sortBy equal the value name? And if it does, then we're going to sort our sessions by name. So, again, an array has a nice method already on it called sort. And this is a mutating method. It doesn't create a new copy of the array and leave the original array unsorted, it actually sorts the array in place, which is what we want. But you have to pass in a comparison function. So rather than doing that in line, I'm going to create a new comparison function, and I'll name that sortByNameAscending. And then, of course, I want to worry about if the value is not name, which means it must be votes, then we'll do the same thing, calling the sort method, but this time we'll pass in a different function, which we sortByVotesDescending. So that'll be descending sort. Put a semi‑colon there, and we need to implement these two functions. And I'm just going to implement them outside of the components class, because they're just sorting functions, they're stateless functions. They don't actually need to be methods of the class. So our sortByName will take in two parameters, the first session, which is an ISession, and the second session, and it has to compare those two sessions. So if the first session's name is before, alphabetically, the second session's name, then we'll return 1; else if the first session's name is the same as the second session's name, then return 0; and otherwise we're just going to return ‑1, meaning that the second session's name is before the first session's name. This just compares any given two values and tells the array's sorting method how those two values should be in relationship to each other. And our votes sorter is going to be very similar, first session and a second session. And in this case this is a lot simpler. The way that votes work is there's a voters array. So, for example, the session s1 has a voters array, and its length property is the number of votes, so we can actually very easily compare two different sessions' number of votes by subtracting them. And since we wanted ascending sort, we're going to return the s2.voters.length ‑ the s1.voters.length. So if they're the same, if they both have the same number of votes, the second one minus the first one is going to be 0; if the second one has more votes, then it's going to be a positive number; and if it has less votes, it's going to be a negative number; and that's how the sorting functions work. So let's save that, and refresh, and now we're by default sorting by votes. You can see the session that's on fire is first, and that must be the one with the highest number of votes. If we click the name sorting, then we get an alphabetical sorting of these sessions by their name, a's come before b's, and we can go back to votes. And there we go, we've implemented sorting again, just like with filtering. It's just up to us as to where we feel like the functionality belongs. There's a homework assignment for this section, so if you want to, feel free to do that now.

Summary
In this section, we talked about various issues of displaying data. We started out by focusing on pipes. Pipes in Angular allow us to display data formatted in specific ways. This is critical in writing an application. Being able to keep the formatting in the client layer is a great way to avoid unnecessary code converting data to and from a specific display format. After looking at pipes, we talked about sorting and filtering data. With Angular 1, we did that with filters. But now, in order to keep our applications performant, this is something we handle in the component. That puts a little extra coding burden on us, but the payoff is more than worth it.

Understanding Angular's Dependency Injection
Introduction
In this module, we are going to take a look under the hood of the dependency injection system and learn how to take more finely grained control of how it works. We are going to focus on some more advanced pieces of dependency injection. We'll start with a look at dependency injection and how we tell Angular that we want a specific service. Then, we'll look at how we can deal with things that aren't simple services. We can do this using two pieces of Angular, the InjectionToken and the Inject decorator. We'll see how these pieces allow us to register services with the dependency injection system in various ways. While we're looking at that, we'll look at some alternate provider methods so that we can really take control of the dependency injection system for those rare situations where we need fine‑grainrf control.

Using Third Party Global Services - The Problem
One of the things that our application has been missing for a while is use of the toastr service. If you'll remember, the toastr service gives us little notifications that'll pop up in the upper right‑hand corner to let us know in certain actions are taken. There's a really good place where we could be using the toastr service right now, and that is inside of the profile. So once we log in, and I can log in here with anything. The server does not care what I put in for a user name. It all logs into the John Papa account. We've got this profile page, and if we make a change and we click Save, it immediately navigates us back to the events page, and we aren't 100% sure if our change has actually been made. In this case, we changed the first name, so it's obvious because the welcome message has changed, but if I were to change the last name to Smith and click Save, I really wouldn't know, I don't get any feedback that a change has been made. So maybe a better user experience would be, when you click Save instead of navigating away, to give us a little notification using the toastr service that the change was successfully made. So let's go into our code. And what we want here in the profile component is to bring in the ToastrService as a constructor parameter, which will cause it to be injected by the dependency injector. And then we can make use of it down here in the saveProfile form. Instead of navigating away, we will use the ToastrService to give us a success message. Let's open up our ToastrService and take a look at it. That's up here inside of common. This is our ToastrService right now, and there's a problem with this ToastrService, and this is important to understand. So the ToastrService that we've created is actually a service that's available for Angular 2 dependency injection, and what we've done is, we've created a class that wraps the toastr's API. It re‑exposes the same methods, and there's four of them, success, info, warning, and error, which is fine because toastr has a small API. But imagine a big third‑party component like, say, jQuery, which had an extremely large API. We wouldn't want to re implement that. Besides the fact that the toastr object by itself is just fine. It doesn't need a wrapper class. We've had to create this wrapper class so that we can use it with Angular 2, but it doesn't actually need a wrapper class. If we just had a handle to the global toastr object, we'd be fine. Unfortunately, just referencing the global toastr object inside of our code would be problematic. There's a lot of problems that come from using global objects, one of which is that we lose the ability of ES6 modules to do things like tree shaking and other features that come with ES6 modules, and it's just a bad practice. So using globals is not a good idea. We want a new way to access this ToastrService that doesn't involve creating a whole class just to wrap it. Now to make that change, we're going to understand some very specific features of dependency injection.

Angular Dependency Injection Lookup
So let's start by going back to our profile page, going down to the profile.component.ts. Let's look at the constructor and let's talk about this AuthService right here. Now you've learned that if you want to inject something like the AuthService that we wrote, that you have to import the AuthService from its file and then using the constructor, mark it as a parameter and mark the type correctly. This type here is the class. If we were to go into the AuthService, we can see that we're exporting a class AuthService, and this class wrapper, this ES6 class functionality, is just syntactic sugar for a constructor function. So what we're getting out of this is just a function. And inside of our profile component where we inject that, we're marking that parameter with this type. But what we want is an instance of the AuthService. We don't want the class. We don't want the constructor function. We want an instance of that. We want an already created instance of that. And so what we want is for Angular 2 to take the AuthService class, create an instance, and give us that instance. And that's exactly Angular 2 does. When we register the AuthService class, Angular 2 will create an instance of that class and give us that instance whenever we reference it in a constructor function. And that happens inside the app.module. We can see that here in the app.module, we are bringing in the AuthService class right down here. And then we register that under the providers section. What's going on behind the scenes is that Angular is taking this class and creating an instance of it for us to get whenever we inject it. And again, if we go back to our profile component, that's what happens. We're getting the instance that it created. Now the question is raised, how does Angular know that we want the instance of the AuthService? And, let's go back to the app.module, how does it know that we want an instance of the AuthService and not the EventListResolver? How does it know? Well, it's this marking right here, this TypeScript type declaration. Angular 2 is hijacking that declaration and using that as a way to look up the service that we're looking for. So essentially, what it's doing is it's using the class as a key to find the correct object, in this case the instance of the AuthService that's been created, inside of its dependency injection registry. In Angular 1, we used strings as keys. And you'll recognize this syntax if you're familiar with Angular 1. We would call angular.module and pass in our module name, like app, for example, and then we would call the service or factory functions. And the first parameter would be a string, and the second parameter would be a function that returns whatever object we want to be that service in the dependency injector. But the key was this string, myservice, so whenever we wanted an instance of that service, we would have to create a parameter that had that same exact name. So it was a string matchup. And, of course, that came with all the problems of using strings. If you happened to mistype the name, then it wouldn't find your service correctly and wouldn't be able to look it up. But strings were how Angular 1 registered dependencies. In Angular 2, we're using classes or types, that's our key, or in other words, our token. This tells Angular 2 to find the correct object to give to us. So again, what Angular 2 is doing is it's hijacking this type declaration. This serves two purposes now. One purpose is to type it so that in our JavaScript code we get auto complete. If I type in AuthService and a dot, I get this nice IntelliSense that tells me what the methods of the AuthService are, and that's because TypeScript is reading the type declaration right here. In addition, Angular 2 is using that type declaration to look up the correct object inside of its dependency injection registry. So it's using it, again, as a key. And of course, this works just great, because whenever we want to create a service, we create a class. So, for example, when we want to create our AuthService, we're creating a class, export class AuthService. But there's a problem with toastr, and that is the toastr is already an object, is a global object. We didn't create it. We didn't create a toastr class the we can export, and then use as our key inside of our app.module. I can't come up here and import the toastr class and then add it to the providers array. So what I don't want is this class, this wrapper class, but I still need some kind of a key to give to Angular so that it can use it as a key to look up the item in the registry. And we'll fix that problem next.

Using Angular's InjectionToken
So, let's start off by deleting this class. And now, because of that, I don't need an injectable anymore. And what I want out of the service class is to create a key or a token that I can use to register with Angular's dependency injector so that whenever I want an instance of the Toastr class, I can use that key or that token as a way to look it up and find the instance that I want. Now there's actually a way to do this. Angular provides a mechanism for us to create a key or token that we can use in the dependency injector without creating a class, and that is called the InjectionToken. The InjectionToken's job is to simply create a token used for the dependency injection registry in order to find the instance of the service that we want. So I'm going to export let, and then I'm going to use caps. And this is a convention that is often seen with tokens. I'm going to call this TOASTR_TOKEN. And that's going to equal a new InjectionToken. Now the InjectionToken's constructor takes in a type parameter, and that type is the type of the object that is given back for the service. So when we use this token to look up the instance of our ToastrService, this is the type that's given back. We have not created that type yet. We're going to create it in just a second. So I'm going to leave this blank for a moment. Then the constructor takes in a single parameter, which is a string, which is the description. This is just using debugging. It's not particularly important what you put in here other than that it's a string that you might recognize, so I'll just put in toastr. And what this is doing, this is creating a token that I can then use to look up the toastr object inside of the dependency injection registry. I haven't registered it yet. I've just created the token. We're going to register it over in the AppModule in just a second. But now it's important to relay something. Even though I'm passing in a string here, this object right here is not a string. This is an actual JavaScript object. So if we remember back in previous sections when we were talking about identity, if you have objects, two objects that look identical are not the same object. We've created an actual object. And as long as we export this object and use this specific object to look up in the dependency injector, nobody else can accidentally use the same token or key in the dependency registry, so we don't get any conflicts. But if I were to use a string, then nobody else could use that string with their service. And if they accidentally did, we get a conflict. But because this is an object, somebody else could have another injection token that they happen to feed in this same string. And it doesn't matter what they name their object or what they put in as the string because it's going to be a different instance of an object. So they might look the same, but they will definitely be two different instances, so they'll be different in the dependency injection registry. So in our AppModule, when we import, we're going to import a specific object from a specific service. So here, I'm going to import that TOASTR_TOKEN. And it doesn't matter if somebody else were to import another token with the same name, maybe do something like this, but from a different toastr.service, say toastr2.service, and that also exported a TOASTR_TOKEN. We would have to rename that using something like this. And we would be using two completely different InjectionTokens, two different instances of two different objects so we don't have any name collisions. Now that I've got the token, I can register the service with the NgModule. But unfortunately, I've got to go back into the toastr.service, and I've got to pull this declare statement out right here because I have to have the toastr object, this global object, declared in the AppModule where I use it. Remember what this statement is. This is just a little statement using TypeScript to say that there's already a global toastr object so that I can use it inside of my TypeScript and I don't get any errors. I have to pull it out, and I have to move it over to the AppModule. I'm going to put it right here. And right down here, I've got the ToastrService, but this is no longer valid. I've got to create a new dependency injection registration, and I'm going to use that token, and I'm going to say that whenever we want the toastr object, we'll just use our token to find it. That's basically what we're doing with all of our other registrations right here. We're saying, whenever you want the EventRouteActivator instance, use the EventRouteActivator class. We're going to be doing the same thing. And the way that we do it is the exact same way that we did it down here for the canDeactivateCreateEvent provider. Use the longhand provide, and this is going to be the token. And then we tell it we're going to use a value. And the value that we want to use is that global toastr object. And that is now our registration for the toastr object. We're telling Angular's dependency injection that when somebody wants the toastr object, they have to ask for it using the TOASTR_TOKEN. With the registration completed, we can go back to our ToastrService. And remember, we still have an issue here. The InjectionToken needs a type parameter. I could, of course, just say any, and that would be just fine. I'm telling TypeScript that I'm not going to give it any information about the shape of whatever this service is going to return using this token. But it's a pretty simple service, the ToastrService, so I can actually use TypeScript and create an interface for it very simply. I'm just going to paste in this interface that I've already created. It's very straightforward, four methods. Each method has two parameters. The second one is optional. Really easy, simple interface. And now I can set that as the type of the InjectionToken, and I'll clean up a little bit here. And now I can go back into the AppModule. And right up here where we declare the toastr variable, I can actually give it the correct type, that interface. I've got to grab it from this import statement. And now I can use that as the interface. And this isn't going to benefit us right here because we're not actually using this toastr, so we're not doing anything in this file with it other than using it in the registration there on line 50. But later on, when we actually consume this service, we can use that interface to get IntelliSense. Finally, we do need to do a little bit of clean up because we're using the ToastrService in one place in our project. So let's save this change, and let's open up events‑list.component. And you can see that we're using the ToastrService here, so let's delete that line. And we were using this click event, but now we're just routing using a routing component, so we don't even need that click event anymore. So we can delete that, and we can delete the handler for it and get rid of the construction parameter, and we've got our cleanup complete. We'll save that change and close the file down. And in our next clip, we will look at how to get a hold of our new ToastrService.

Using Angular's @Inject Decorator
Now that we have the toastr.service registered, we can use it here in our ProfileComponent. Normally, when we want to inject a service, we do something like this. Let's put these on separate lines. We'd add a new private, and then for the toastr.service we'd call it toastr. And we would just give it a type, for example, Toastr. And that's all we would need to do. But since we're using an injection token, we actually have to use a slightly more complex method to inject this service. So let's go up. I've got to bring in a couple of things. First, I'm going to need the token and the toastr interface. That's going to come out of our toastr.service, the token and the interface. And one other thing that I need is going to be from Angular Core. I'm going to need the Inject object. Inject is a decorator just like @Component that allows us to use a separate token besides the type of the construction parameter. So again here, for the authService, the token is right here, and that's also the TypeScript type. In our case, the TypeScript type is just Toastr, which is our interface, but that is not our injection token. Instead, I'm going to add that decorator @Inject, and it's parameter, as you can see, is a token. And I'm going to use the TOASTR_TOKEN here. And that tells Angular for this toastr variable that we are creating, that is going to be a private member of this class, you're going to get your value by using the TOASTR_TOKEN to look up the service in the dependency injection registry. I'm still giving it type information, but that's simply for the IntelliSense here inside of this file. That's all that's going to do. And now with the service injected, I can go down to the saveProfile. And instead of navigating, we're going to call this.toastr.success and give it a message of Profile Saved, and I'll save that change. And now let's go back to our web page, and we'll go to the All Events and refresh, and we got logged out, so let's log in. And we'll go to the profile, and now let's make a change, and click Save, and there we get our toaster pop‑up telling us that the profile was saved. And, of course, it disappears after its timeout. So that's how you can use the opaque token to register dependencies and avoid difficulties of using things like strings for keys. There is homework for this clip, so you can go ahead and check that out now.

The useClass Provider
In our last section, we talked about the opaque token and using that when registering this provider, the toastr service provider. One of the things that I kind of glossed over that I want to talk about a little bit more in depth is how this syntax using the object is a little bit different than this syntax right here. But the reason for that is that this syntax where we simply pass in a class, this is just shorthand for using the object syntax like this, and we can replicate that with the following. So what we've got here is the same type of syntax. We've got a provide key in this objec. And then instead of useValue that we used because we already had an existing object, we're saying useClass. So again, this is our token is the class itself. And we're saying whenever somebody uses this token to look up something in the dependency injection registry, we could actually use an object created by this class here. So use the EventRouteActivator class to create an object and return that whenever somebody asks for an object using the EventRouteActivator class as the token. So it's longhand. We need to shorten it up by just removing all the syntax and just passing in the class name itself. Now because that longhand works and it actually has two different values, so let's use it on this AuthService, we can actually sort of do some funky things by saying useClass. But instead of passing in the AuthService class, I could pass in something entirely different, like EventService. And now, whenever somebody asks for an AuthService, they're actually going to get an instance of the EventService. Of course, that would be really bad in this case. They don't have the same APIs. You would never want to do something this weird. But you might want to utilize this functionality if you're doing something like you have a very specific kind of implementation of a class, but you have a generic class that you're using. Say, we've got like a logger class, and that's what people are going to ask for, but we actually want to use like a FileLogger specific implementation. Of course, those classes don't exist, so that wouldn't work in our application. But that's an example of where you might want to utilize the longhand syntax. So let's just reset this back to the way that it was. And that's the useClass syntax for registering providers.

The useExisting and useFactory Providers
So now we've looked at the useValue way to provide services and also useClass, which is the longhand for what we normally do with services when registering them as providers. There are actually two more ways to register providers that we're going to talk about in this section. We're not going to look at very concrete examples of these because it's really unlikely you'll ever need to use either of them. But they exist, and so it's good to know about them. One of them is called useExisting, and it looks like this. This is also known as the alias provider, and there's a fairly limited set of scenarios where you'd want to use these. One that comes from the documentation is to minimize an API. So say, for example, you had a Logger service, and that Logger service was a big service that had a very large API. Maybe it had 20 or 30 different methods in it. But in your application, you're only using the most common five. So you create a MinimalLogger service, and what that does is now you're getting the API for the MinimalLogger. And, of course, this has to be a class. This cannot be an interface. The MinimalLogger must be a class, but it's never going to have an instance created of it because whenever somebody asks for a MinimalLogger, they're going to get an instance of the Logger. So this would be the kind of class that has no implementation. You would just create the methods just for the API. But whenever they ask for a MinimalLogger, they get the Logger. But the only methods that they can see in IntelliSense are the three or two or four methods that are on MinimalLogger that you actually want to use. So that's one example. It's really not a common case. Not something you're likely to use, but it is something that exists, and that is this useExisting provider. The last one is useFactory, and this is even more complex. In this case, what you're going to do is you're going to register a class, say your MinimalLogger. Well, let's change this to something simply like Logger. But what you're going to do is you're going to give this useFactory parameter a function that is a factory. And you can actually call the function and pass in some parameters. And what that does is it allows you to parameterize the creation of an object. This is really only used in very complex cases, all of which would be out of the scope of this course. If you need more information, you can check out the official documentation, but that is the basic usage of the useFactory. Again, you're unlikely to run into a situation where you need it. But if you do need to have a very complex way to construct an instance of a class to use as a service, then useFactory is the way to do it. There is a practice exercise for this clip, so you can go ahead and do that now if you wish.

Summary
In this section, we learned how to register other kinds of services with the dependency injection system. We do this using a combination of the InjectionToken and the Inject decorator. We saw how we can use alternate provider methods to register these services. These methods include useClass, which is the longhand form of what we normally do but can be used to enable some advanced scenarios. The useValue is the next most common method we use. This lets us add an existing object to the dependency injection system. Finally, we have useExisting and useFactory. Both of these are for advanced scenarios that we aren't likely to run into in a normal application. The dependency injection system is complex under the hood, but with some basic understanding we can do some common tasks that will help us out in various situations.

Creating Directives and Advanced Components in Angular
Introduction
In this module, we're going to learn how to create directives and deal with advanced components. Our focus will be on learning more about components and how to deal with other scenarios that we haven't seen before and also how to create directives, which we don't create a lot of, but are useful to be able to do. You should feel comfortable with components by now, so we'll push that knowledge seeing some new scenarios. We're going to create a modal component. While we do that, we're going to learn some new things. For example, we'll learn about routing to the same component. In Angular, there are a few things to be aware of when routing from a component to itself, and we'll see how to handle this. We'll learn about DOM manipulation and how to reach down and interact with the raw DOM when necessary. We'll also learn about using the ViewChild decorator and some similar decorators in order to get a handle on the underlying DOM node. We'll also be creating a directive in conjunction with our modal component. We don't often need to create directives, but it does happen often enough that we want to know how to do it. Through this module, we'll really get a handle on components and their counterparts, directives.

Implementing the Session Search
Since this section is about advanced components and directives, we're going to be adding some more interesting functionality to our application. One of the pieces of missing functionality we've got is this search box up here in the navbar. We'd like to implement that in this section. We'll do a few other things as well, but we're going to start by implementing our search box. This searches sessions, so it's not looking for an event, we've got the events list that lets us find an event. What we want to do is find a specific session within an event. Maybe we know that somewhere there's a session about pipes, and we're looking for that specific session, or we just want to look for any session about pipes. So if the user types in pipe, and hits Enter, or clicks the search button, we want to pop up a list of search results. And from that popped‑up list, we'll let the user click on a specific session and navigate to the details for that event. That's the functionality we're going to add, and to implement that, we're going to use Bootstrap's modal dialog, which is actually added into jQuery, which means we've got to have both jQuery and Bootstrap in order to do this functionality. We're simply going to write the Angular2 wrappers around that functionality. That'll let us avoid a lot of the complexities with implementing modal dialog boxes, but it's still going to be a fair amount of work on the Angular2 side. Let's start by hooking up to the event. We're going to go back to our code, and we're going to go into the navbar.component, and down here where the search button is, actually the search form is what we're looking for, we're going to add a new event handler to this form. Forms in Angular2 have a submit event that's actually bound to ngSubmit with with a capital S. That's the event, it's a custom event that exists on the form that's added in by Angular2, and we're going to hook up to that, and what's nice about listening to this event is it doesn't matter if the user hits Enter while in the input box, or if they click the button, it's still going to fire the submit event. And we'll call a method called searchSessions, and we want to pass in the search term that the user is looking for. I'm going to put in a variable called searchTerm that doesn't exist yet. And now let's create that searchTerm, and that's going to be whatever they type into the input box. So in order to do that, we want to hook up our input box with an ngModel, so we're going to use a banana in a box and the ngModel, and that will be hooked up to a search term. We have to give it a name, of course, and now with those in place, let's click Save, and we'll go into the component, and we've got to add those properties to the component. So we need our searchTerm, which is a string, and we'll initialize that to an empty string. And we're also going to need a searchSessions method, which I'll create right here after the constructor, that takes in that searchTerm, remember. And ultimately our search is going to return to us a list of found sessions. So I'm going to need a foundSessions property as well, which will be a collection of ISessions, and let's import the ISession interface. And now, we need to think about implementing our searchSessions method. Obviously we don't want our component itself to be doing our search, we want a service to handle that. So we're going to use the eventService, seems like a natural place to put functionality like this. But that also means that my navbar component needs to have a handle to an event service, so we'll have to import that. And now we can add it to the constructor. And let's add some place we can call it inside of our searchService method, and we want to call a method that will search through the sessions. That method doesn't exist yet, but I know what it's going to look like. I'm just going to call it searchSessions, and it's going to take in that same term. And I'm going to make this return an observable. Since we have our data locally, I could just return the data synchronously, but in the next section, we're going to be adding in HTTP, and in a real application, you probably wouldn't have all your data local, you'd probably be making an HTTP call for something like this, so an observable is fairly appropriate. So we'll subscribe, and we'll probably received back a list of sessions. And once we get back the list of sessions, we'll set our foundSessions variable equal to that returned list of sessions. That's how the call will look. Now we need to go into the eventService and implement this new method. I'll save and open up eventService, and let's just put it right after updateEvent. Remember, it takes in a searchTerm, which we know is a string. Let's lower case that just to make it a little easier, so that no matter what case the user types in, it will be consistent. And we'll need a list of results that'll start out as an empty array, and of course those are ISessions. And we'll initialize that to an empty array. We don't have the ISession, and we don't have the interface brought in, so let's go up and import it. And now to find the correct session, we'll have to look through each of our events, and we'll grab a list of matchingSessions from this event. We do that by calling event.sessions, and we filter that down to a new list where the session.name.LowerCase contains the term we're looking for, so we can just do indexOf term is greater than ‑1. And now, since sessions don't actually contain the eventId that they belong to, I'm going to add in the eventId to the session. That'll be necessary because we're just getting back a list of sessions, and when they click on a session, we need to go to the corresponding event, and therefore we're going to need the eventId. But we're not bringing in the event along with sessions, we're just getting the session itself. So let's add in the eventId by mapping our matching sessions that we've just created, and we're going to specifically map the session to in any, so that we can add in the eventId, and we'll set it to the event.id, and then return that session. And that's an quick and easy way to add the eventId to every session that we've created. And now we're going to take that results array, and we're going to add to it using the concat method this matchingSessions. Now we've got our results and we want to return those back, but remember, we want this method to work when we move to HTML and have the same kind of interface, which is going to be an observable, so we need to return an observable, and there's an easy way to do that. We can use the EventEmitter. So we'll create a new EventEmitter. We pass in a true, which will tell this emitter to deliver its events asynchronously, and we don't have the EventEmitter imported yet, so let's go back up to the very top, and it's in Angular Core, and we'll add in an EventEmitter back down to our code. Once we have the EventEmitter, we're going to set a little time out just to kind of simulate what it would be like if we were actually using a web request. And we'll have the emitter emit those results. And let's time that out for 100 ms, that'll simulate HTTP a little bit, and then we return the emitter. And now that we've written the methods, we want to see if they work, but I don't want to worry about hooking UI quite just yet. So I'm going to go back to my navbar, and I'm just going to log out to the console the sessions once we find them. And we'll remove that later on, but for now, it's a quick and dirty way to find out if we returned the sessions that we're looking for. So let's save this, and we'll go back to the web page for our site, refresh it. And now let's put in some kind of a term, let's look for pipe, and hit Enter, and look at the console, and we've got an array with one item in it, and that item has an abstract, or a name, excuse me, is what we're looking for, of using Angular 4 pipes, and that's what we did in our method. We searched for just the matching term in the name. Now we've got our search implemented, and we can now begin to hook up some UI.

Adding jQuery
Now that we got our search results coming back, we need to display those search results. So we're going to start hooking up the UI. This is going to take a little bit because it's not a trivial matter to hook up this modal dialog and wrap it correctly in Angular 2. As mentioned before, the bootstrap modal dialog is part of bootstrap, but it's actually utilized through jQuery. So we're going to need jQuery, which means that we've got to now have jQuery inside of our application. And jQuery is a third party global, which means we've got to do the same thing we did with toastr. We've got to create a wrapping service for it. So let's start out by creating a wrapping service file. And we want to do pretty much what we did with the toastr wrapper. Let's create a new file here, and I'm going to call that jQuery.service.ts. And I'm going to pretty much copy what we have in the toastr service, except I'm not going to get the interface. jQuery's interface is far too complex for us to recreate. Let's change this. Let's set this type parameter to Object. At least it's slightly better than any. We're going to change the token from TOASTR_TOKEN. We'll call this JQ_TOKEN. And of course, we don't want the string to be toastr. It'll be jQuery. And that's all we're going to do in this file. And now we've got a couple of places inside of this directory that we're exporting. So let's create a barrel file, index.ts, and we'll export from the jQuery service and from toastr and from collapsible‑well. We'll save those changes and go to our app.module file. And we need to do the same things we did with toastr, but while we're in here, let's fix an AOT compilation problem. You may have already fixed this on your own. We'll change this, get rid of the declare, and let toastr equal window toastr. And we'll get the same thing for jQuery, but we won't give it a type, and we'll grab the dollar variable. And up here where we're importing, we're going to import from our new index file. And from there, we can grab the JQ_TOKEN, the TOASTR token, and the Toastr interface, and we can delete that line now. And we can also get the CollapsibleWell from the same place. And now we've successfully got jQuery imported and wrapped, and we'll save our changes. And in the next section, we will start creating our modal.

Creating a Modal Component
With jQuery created, we can now begin creating our modal component. I want to know what that modal component is going to look like first. I'm going to go into the nav, into the HTML. Here is where I'm going to have the definition for my modal from an HTML standpoint. We're going to use content projection as we learned previously. So we'll have some kind of a modal component, and within that, I want to put in the contents and display of the search results. So, let's just look at that first, and we'll come back to our modal tag in a second. We're going to give this a class of list‑group, and for each item, we're going to have an anchor tag that's going to be a list ‑group‑item, and we'll use an ngFor to repeat over our results, and that'll be a session, and that's the foundSessions variable, remember, is getting filled in. And now we also need to link to the specific event, so I'm going to use a router link, and we're going to bind to our events path, and the second part is the Id. And again this would translate to a URL of events/ that sesssion Id, so if it's Id3, would be events/3. And let's close up this tag, and now we want to print out the sessions name, so I'll use just a plain binding, two open curly braces. Notice that it looks like there's only one open curly brace, but the second one is on the line before the very last character, so don't let that confuse you. It's just the wrapping that's making it look different. And then we close up are a tag, close up our div, and then we will close up our modal tag. Now, calling this modal is probably not the best idea for a tag name, it's a very simple little modal component, so why don't we call it simple‑modal, and I'd like to be able to set the title on my modal display; however, that display looks, I'd like there to be a little title up at the top, and I want to set that, so let's add a title attribute, and we'll set it to Matching Sessions. Now one more thing I want to talk about before we begin implementing this component is this URL on the routerLink. Since we're not starting with a leading slash, this would be a relative path, and since our search results are available at any place in the application because they're in the nav, we might already be down in some sub directory, and that wouldn't work out for us, so we'll want to start from the root, and to do that, we're going to need to add a leading slash. So that way, no matter where we're at, it's going to go to the root of our website/events/eventId. Now let's save the changes here, and let's begin implementing this simple modal component. I want this to be in the common directory because it's a component that I might use anywhere in my application. So a new file here, and I'm not hyphenating the simpleModal, I'm using camelCase here. A lot of times, you'll see the recommendation is to use a hyphen, simple‑modal like that. I have a personal preference to not use the hyphens, but either way you want to do it is just fine. And to start off with, of course, we're going to be creating a put component, so let's import Component, and be sure and get the casing right on your import statement. And now let's create our Component. We'll give it a selector, of course, of simple‑modal, and a template, and here in the template, we're going to need a div, and I'll give it an Id because using the Bootstrap modal component, you have to know the Id of the modal itself, and we'll just give it an Id of simple‑modal, and we give it a class of modal, which actually tells Bootstrapping and jQuery that this is a modal, and we want a class of fade, so that when it closes it'll fade out, on a tabindex of ‑1. And inside of that, we have another. div, which has a class of modal‑dialog, this is for styling, and then within that, a div with a class of modal‑content again for styling, and within that, a modal‑header div. And inside the header, I want a close button, so I'm going to create a button of type button, and I give it a class of close, and I'm going to add a data‑dismiss tag to say that I want to dismiss my modal. And then within that, I want a span that shows a little X, so I'm going to use the &times HTML character, and then close my button. And because of the styles, that button will be shifted over to the right. I also want an h4 with the title in it, more styling classes there, and we'll bind to that title property that we set inside of our navbar HTML right there. Close up that div, and we'll add another div for the modal body. And inside of here is where we're going to project our content, so I'll just add in the ng‑content tag, close up this div, and that div, and another, and finally our last closing div. So there's our HTML. Now we've got to style this up a lot, so I'm going to include some styles in this component. I want these styles to apply to this component only, and we're going to add a modal‑body with a height of 250 pixels and an overflow‑y of scroll. The rest of the styles are specified in the Bootstrap CSS file. Now we got the styles for our component, and we can create the Component class itself, and that has one input property, which is the title, which is a string. And let's go up and bring in the input. And that will be all that we need for the modal component itself. We're still not actually calling and opening up the modal component, but we'll do that in the next section. So let's save this, and go into our index file, and add that line, and again, you can see here the recommendation is often shown to use a hyphen to separate words. Here we've done Pascal, so you can make your own decision, do you like the hyphenated better, do you like the Pascal Case better? I myself have a small preference for Pascal Case, but the hyphenated case is starting to grow on me. And with that in the barrel file, we can go into our app.module, and add in our SimpleModalComponent, and with that, we can save our changes, and then we, of course, add it down to our declarations. We're not yet using jQuery, but we will be in our next section. So let's go ahead and add jQuery to our providers list as well, and with that, we'll save our changes.

Fixing Template Parse Errors
Now we still haven't yet completed our functionality. Our modal is still not showing up when we search, we're going to add that the next section, but what we can do is test to make sure that we haven't broken anything. So let's go back to the browser, and we'll open up the console, and we're going to hit refresh, and uh‑oh, we're getting an error, Template parse errors is what's showing. Now you can open this up and start drilling around into the call stack as to what's going on, but it's really not going to lead you to anywhere interesting. This is one of those times where just knowing that template parse errors means that Angular 2 is having trouble parsing one of the templates for one of your components. So let's go back into our code, and the likely place that we've got a temple error would either be in the navbar, where we added in the simple‑modal, or in the simple‑modal component itself. Now we could do a whole bunch of diagnosing this by taking sections of HTML, and deleting them, and then refreshing, and when we do that, we're going to come and find out that we closed our span here incorrectly. Here's the open span tag and the close span tag. And I would diagnose something like this by just deleting a section of HTML, saving, refreshing the browser, and seeing if the error went away, and it would lead me to this line of code. So let's fix that with a close span, let's save, and go back and refresh our browser, and now everything is back to normal again, no more errors.

Creating Directives - The Trigger Directive
We've got our simple modal component created, but now we need to show it when somebody searches. So we need a trigger and a way to open up that modal. The way that you open up that modal in code, let's just go into a random piece of code here, would be with jQuery. In jQuery, you call the jQuery selector. You have some DOM element that you're selecting inside of here, say an ID, and then you call the modal method. And that's essentially how we open up the modal. So we need to call this code when the user searches, so when they click the Search button here. Well, what we don't want to do is go into our navbar and go into this button and add a click event handler to this and say hey, when the click event happens, then let's call that code, you know, we put it into a like onSearch method. And we would call that modal and open it up. That's not what we want to do for one very big reason. That would tightly bind this navbar component to the implementation of opening up a modal. I mean this is really under the hood is having jQuery call its modal method, which is only there because bootstrap is also part of what's getting loaded. So we don't want that. We want to hide these implementation details behind something else. And a great way to do that would be a directive. So instead of this, let's just undo these changes here. We'll go into our HTML, and what we want is on this button, we want to say hey, when you're clicked, you are a trigger for my modal component. So maybe we could give it an attribute like modal‑trigger, and that's an indication to Angular 2 that this button needs to trigger the modal. And if you know Angular 1, you'll know that we can do this with what's called a directive. In Angular 2, it's actually the same name. A component is an element, such as this right here. A directive is an attribute, such as this right here. And with a directive, we can attach new functionality to an existing DOM node. So this button, we want it to have another piece of functionality. We want it to be a trigger for our modal. So we're going to create this directive right now. It's going to be called our modal‑trigger. So let's go into the common directory, and let's create a new file, and we'll call it modalTrigger.directive.ts. And of course, we're going to have to do some importing, and we're going to import first from angular/core. And normally, we would import component. That's what we would normally import here. But we're not creating a component. We are creating a directive. So we're going to import Directive. This is a decorator that Angular provides that lets us create directives. So once I've got that imported, I'll create the directive. We create it very similar to how we create components. Just like a component, it has a selector. But unlike a component, we don't just feed it a simple string. So, for example, with our simple modal, it was simple‑modal. That's not what we want. Our selector is modal‑trigger, but it's an attribute. So we the common CSS selector syntax and wrap it in square brackets indicating that this is an attribute, not an element. And now we're going to expert a class, and we'll call it ModalTriggerDirective. What we want to do is when this directive is created, we want to attach a click event handler to whatever element it's created on. So let's bring in the OnInit interface, and we'll have our directive implement that, and we'll create the ngOnInit method. And inside of here, that's where we're going to call that modal function off of jQuery. So what we'll need here is we'll need jQuery inside of this class. We want to inject it into this class. So let's create a constructor, and we're going to bring in jQuery. In order to do that, of course, we have to import that JQ_TOKEN that we created earlier on, and that's just a sibling file. And in order to inject that, we also need the inject function from angular/core. And then we just call @Inject, passing in the JQ_TOKEN, and we'll create a private variable, the dollar sign, and we'll just assign this to any because the API for jQuery is really rather complex, an empty body for the constructor. And in our ngOnInit, we can now call this.$, which is the jQuery function. And we'll pass in the ID of the modal that we want to open up, which we defined not here. We defined it in our simple modal. It's this ID, just simple‑modal. So we use the #simple‑modal, and we call the modal method, and we have to pass in an empty object because it expects a configuration object. We're not going to give it any actual configuration parameters, so we pass in an empty one. And that will open up the modal, but we're calling this OnInit. We don't want to call this when it inits. But instead, we want to listen to the click event. So what we need to do is get a handle to the element that this directive is on and listen to its click event. So in order to get that element, we need to bring in an ElementRef, which is Angular 2's object, which is a pointer to a specific element. And in our constructor, in addition to jQuery, we also want to inject our element. So I'll do el, and the type is ElementRef. And what this does is it tells Angular when this directive is constructed, I also want to reference to the element that it's on. So again down here in our navbar, this directive is on this button element. So that's ultimately the element that we want. But we don't want the ElementRef because that's kind of a wrapper for the DOM element. We want the actual DOM element. So we're going to create a new property called el, which is an HTML element, which I haven't imported that. This is just a global JavaScript type. And here inside the constructor, I'm going to set this.el equal to the injected el.nativeElement. And maybe my naming is a little bit poor here. This el and this el are kind of confusing. So let's rename this. We'll just call this ref. And unfortunately, our wrapping has brought this curly brace down onto another line, so let's get rid of this blank space. We don't need that. Okay, so we've got the native element now, and we can now add an event listener to it, which we do with this.el. Of course, we're doing this inside of our init because we want this to happen when the directive is initted. And it's just addEventListener. This is just plain old JavaScript in the browser. We're listening to the click event, and that takes a function as a second parameter, which receives an event object. We don't really care about the event object. We just want to call our modal whenever that button is clicked. Now, of course, we need to save our changes here, and in the HTML file, we need to go into the index, and we need to add that new modal‑trigger. And then we need to go into our app.module and bring in that trigger directive and also add it to the list of declarations. Directives go under declarations just like components do. I'll save that, and now we can go back to the browser and refresh the page. And if I type in pipe and click Search, we get our pop‑up, our modal dialog, that shows us what sessions match that search string. If I close this modal and search for something else like Angular, we can see we get a lot more results. So our modal dialog is now working. And if we were to click on one of these sessions, you can see that we've actually navigated to that session. The URL has changed to events/1. But before we finish up, we're still logging the results out to the console here. So let's fix that. Go back to the code and into our navbar component and we'll take out this console.log. And there we go, we've created our directive. There is a practice exercise for this clip, which you can do now.

Binding an ID
Now, even though I knew modal component with its associated trigger directive is now working, we do have a few enhancements that we need to make. So the first enhancement that we're going to handle is the fact that there's a weakness that because we're using an id, and in our trigger, we're saying, hey, open up this modal with this id, we could never have two different modals in the same application. We can only have one modal, which is a weakness, right? This is a generic modal dialog box. We'd like to be able to use it multiple times, but right now we're fixed to just one, because this id is here. So if we place more than one on a given page, we'll have two elements that have the same id, and therefore we're going to have a problem. So let's fix that. Let's make the id customizable. So what I want to be able to do is tell this component what its id is going to be, and I'd like to do it like this. I like to go into the navbar.component, and where I've created the simple modal, in addition to the title, it would be nice to just set its element id. And we'll just call this one search results, but an entirely different modal that we might create, say, maybe on the navbar or maybe somewhere else, it might have an element id of, say, userList, whatever. So here's our property that's set. Since this is a component, this is an input property. Let's go back to our simple modal and we're going to create an input property for the element id. And now we've got that input property and we combined it here in the template. So instead of setting this to simple modal, we'll bind this to element id. Now we've got that set up so that the navbar's template is setting the element id, and the simple modal is using that element id that it's given, but the trigger is still hard‑coded to this value. So we need to tie these two together. Now there isn't an easy way; I can't just globally select for that somehow or somehow inject this into the modal trigger, but what I can do is go back to my template where I am defining the modal trigger, and I could pass in the same id as the value of the attribute, and this is actually really nice. So here I've set the element id to search results, and here the modal trigger, I'm saying, you are the modal trigger for this particular modal dialog box. That's really great, because now in the HTML, it really tells you what's going on. It adds that sort of binding between the two things. So if I have an entirely different modal dialog box down here with a different element id, then somewhere else I have a different trigger set to that the id. I can tell which button triggers which modal. Now when we created this attribute, the element id, we just created an input property. Here, this is a directive and not a component, but we implement it the same way. We go into our modal trigger, and we are going to add an input property. So I've got to bring in input, and the name of this input is the name of the attribute, which is just modal‑trigger. Unfortunately, modal‑trigger isn't going to work as an identifier name, because dashes aren't allowed. So we've got to alias this, and there's an easy way to do that. We take this and we put it inside the input as the parameter, saying, hey, this is the variable that's coming in or this is the attribute value that's coming in, but I want you to assign it to a property named, and we'll call this modal id, which is a string. And now that I've got this modal id. I can use that instead of the hard‑coded string simple‑modal. So instead of concatenating this, let's just do a little bit of fun. We'll turn this into an ES6 interpolation string, and we'll use this.modalId. So now our resulting string is going to a hash tag and then the modal id, and let's save our changes, and in the template. And we can go back to the browser and refresh, and let's search for pipe again, and our modal dialog is still working. We can still use it to navigate to the right session.

Routing to the Same Component
The next feature that we're going to add is to actually fix a bug. Now this is not a bug in the modal dialog component we created. It's the modal dialog that's exposing a bug that has already existed in our event‑details page. Let's look at the bug first. Then we'll talk about why it exists and how we handle it. So I'm going to search again, but I'm not going to put in any search term. I'm just going to click the Search button, which will search all sessions. We can see I've got every session here, so I'm going to click on the first one, which is a session for the Angular Connect event. And you can see the URL is /events/1. Now if I click on the same one, it just stays there. That makes sense because it's still the same event. In fact, all this first set of sessions belongs to the event that has ID of 1. So let's scroll down to the bottom. These sessions down here belong to a different event. So I'm going to click on one of those, and you'll see at the top that the URL has changed. Notice that it's now /events/4. Yet we have not navigated away. We are still looking at Angular Connect. So we are still looking at the event that has an ID of 1. If I were to go up here and just hit Enter and navigate to the fourth event, we can see that it's actually the UN Angular Summit. The event with ID of 1 is Angular Connect. The event with ID of 4 is UN Angular Summit. Yet when we try to navigate away like I just did right now, the URL changes, but the event does not. This is a bug in our event‑details component, and let's talk about what's going on. We'll go look at our code, and we're going to look at the event‑details.component. I'll close these down. Here in events and details, event‑details.component, down here in the OnInit, we set the current event to be equal to the eventService.getEvent, but we're passing in this.route.snapshot and then the parameter ID, so the ID parameter from our route. That's great the first time this component initializes. But when we navigate from /1 to /4, what Angular does not do is reset the entire state of the component and reinitialize it, reconstruct it. No, it stays there. It leaves the same component initialized. Instead, all that happens is that the param for the ID changes. It's taking advantage of the fact that parameters for your route are actually exposed as an observable. Here we're using the snapshot, which is not an observable. We've told it just grab whatever the current route's parameters are, create a snapshot of that, a fixed copy, and we'll use that. But we're not subscribing to any changes. So if that ID parameter changes, we don't know about it. And that's the bug that we've got to fix. That's how Angular 2 does its routing when you're on a parameterized page. So a page that, like our event‑details page that has an ID in the URL, and whatever is displayed changes based on this ID in the URL, if we can navigate from this page to itself to a different ID, then we've got to listen to the route parameter subscription. That's the way we deal with that in Angular 2. Now it didn't matter when we were going from all events to any given event, like 2 is different than 1, because we're navigating from a different component to the event‑details.component. But when we're in the event‑details.component, we navigate to itself just a different URL than the route parameters are changing, and we are notified of that through an observable. So in order to fix this bug, we've got to subscribe to the route parameters. So we're going to completely change how this code works. I'm going to put the code right here so we can refer to what the code used to look like. Instead of setting this.event equal to something, we're going to call this.route.params.forEach, and we're getting a params object, which is of type Params, and we haven't injected that Params type. So let's go up and inject that. That's actually on the router. And the callback function will actually do the setting this.event will be set equal to this.eventService.getEvent. And here we can just call params['id']. But we want to make sure and convert that from a string to a number, so we're going to use our little shorthand conversion, and now we can get rid of this code. And if we save our changes and go back to the browser and refresh, we're now going to get correct functionality. If I go down to a session for a different event and click on it, you can see that we've actually navigated and are displaying the data for the correct event. Now it's important to understand how this works and what's going on. We are not resetting this component. So, therefore, its state is not getting set. Here I'm resetting the event property, but this component actually has more state than just event, for example, the addMode. That's another piece of state. You can see if I go in here and click Add Session, I'm now in the addMode, so addMode is set to true. If I were to search and go to one of the sessions for a different event, I've now navigated to the different event, but I'm still in addMode, which is probably not what I want. So in addition to setting the event, I probably need to reset back to my default addMode, which would be false. So it's very important to understand that whenever you are subscribing to the route parameters and basically using that as navigation to a different page within the same component, you need to keep track of all the different pieces of state that exist in the page. In this case, addMode. It's often easy to tell by just going up here and looking at what properties exist. Normally, your state's going to be in these properties. So the event is a piece of state. AddMode is a piece of state. How we're filtering and sorting, those could also be pieces of state as well. We might want to reset those as well. I'm not going to do that. But, again, that could be something that you might want to reset. So it's important to keep track of all this state and reset it whenever you subscribe to and react to a route parameter change. And, of course, we could be resetting so much state that instead of calling this code, we might create a new method called setState or resetState and put the code into that so it's a little bit more descriptive. So let's save our changes and verify that our fix worked. Refresh. I'll turn on addMode. Go to a different event, and you can see addMode is now off. There we go. We fixed our bug, and we've learned how to deal with routing a component to itself. There's also a practice exercise for this clip. Feel free to go ahead and do that now.

Using the @ViewChild Decorator
In this section, we're going to address the fact that when you open up the modal dialog and click on a session, it doesn't close the dialog down for you. So what we want to do is add a click event handler to this main body of this dialog box here and listen to that and close the modal when that's clicked. So back to our code, and it's right here in this modal.body, that's what we want to listen to. Also, there's a mistake here. This is supposed to be modal‑body, which should also fix some styling issues. We want to listen to this div, and whenever a user clicks on it, we want to close the dialog box. So let's implement a click event listener here, and we'll just call it closeModal. And, of course, we're going to need to pull up that method. And inside of here, ultimately, we're going to call that jQuery method modal, and we'll just pass in the string hide, and that will close down the modal dialog. But we've got to pass in the actual DOM node, the raw DOM node that is the modal, which is going to be, of course, this div right here that has the modal class. So how do we get a handle to that? Well, we could do the same thing that we did in modalTrigger. We could get our ElementRef and just get the nativeElement off of it, and that would be fine. But we're going to look at a different way to get access to that same DOM node. And this is through using a ViewChild. So I'm going to go up to my Angular Core, and I'm going to import ViewChild. And down here, I'm going to call that, it's a decorator, @ViewChild, and you pass into the ViewChild a string that indicates an Angular 2 local ref variable. So you may remember previously that if you want to refer to a specific element, you can put in a ref like this. These refs are available inside of code, so I could, for example, pass it into my closeModal. But it's also available as an indicator for a ViewChild. So if I pass in the string modalcontainer, and I'm going to call this my containerElement, which is an ElementRef, and I need to import that ElementRef type from Angular Core, this object here is going to be initialized with this component to point at this specific DOM node. Again, it's just a wrapper to that DOM node, but it's going to point to it. So it's kind of the same as injecting ElementRef in the constructor, as we did here for modalTrigger. But it's a little bit more versatile because we can put this ref on any node that we want to, and it will just give us a handle to that node. In this case, we just want the wrapping node, so that's fine. It's going to be the same either way. But we're going to implement it using a ViewChild, and that'll show us how those work. So I don't have jQuery yet. I need to import that as well, and I want to create a constructor, @Inject(JQ_TOKEN). And we didn't import Inject, so let's import that. So now we've got jQuery. And, of course, it'll be this. And now we want the raw DOM element that this containerEl wraps. So we call this.containerEl.nativeElement, and we're getting the underlying DOM element that this containerEl points to, which is found by looking up the ref for modalcontainer. So that's another way of accessing a specific DOM node, and it's a much nicer way to get a hold of a specific DOM node rather than getting the parent ElementRef, and then perhaps drilling down through something like getElementsByClassName, for example. So let's save our work, and we'll go back to the browser and refresh. And now if we click on a session, it does close the modal dialog for us. Now in addition to ViewChild, which we're using here, there're a few more variations on this. There's ViewChildren, r‑e‑n, which we didn't import but is one of the options. ViewChildren would be used in case you have a list of elements that all have the same ref. For example, if we had an ngFor that was iterating over a list of items, and we wanted to get a reference to that entire collection, we would use ViewChildren for that. Then if we wanted to access a child that is inside the content that's projected into this component, then we wouldn't use ViewChild, we would use ContentChild. Now the problem with ContentChild is you have to trust that whoever implements the content that's getting projected is going to put in the elements that have the ref on them. So if they don't do that, then your ContentChild is going to be empty. And in the same way that ViewChild has ViewChildren, ContentChild has ContentChildren, and that does the same thing as ViewChildren. If the projected content has a list of refs that you want to get a hold of, then you would use ContentChildren. And so those are ways that you can get access to a specific DOM node without starting at the top and drilling down. And there is a practice exercise for this clip if you want to do that now.

Creating Settings on Components
Now the feature that we've added to our modal where the dialog box is closed if somebody clicks anywhere in the body of that dialog box might be a feature that you don't want in all cases. There may be times where you have a modal dialog box that you don't want it to close when somebody clicks in the body, maybe it's not displaying a list of links anymore, maybe it's just displaying some information, and you want to be able to click a button or something like that and not have the dialog box close. So let's make that a setting. What we want it to look like is inside of our nav HTML where we define the modal, it'd be nice if we could just say closeOnBodyClick=true. And now it's going to close the dialog box if we click on the body, but if we don't include this attribute or set it to anything else, then the dialog box won't get closed when we click on the body. So let's save that and we'll go into our simple modal. We're going to add another input property and that would be closeOnBodyClick, the attribute that we just created, and that's a string. And then all we have to do is go down into our closeModal method and say if this.closeOnBodyClick and let's lowercase that to make it easy, and we'll compare it to the string true, and if it's true, then we will close it, and if it's false, we won't. So let's go back and change this to false, and go to the browser and refresh, and we open up the modal dialog. If we click in the body, it's not going to close it, even though it still does navigate. But if we set this to true and try it again, then it does close the dialog box when they click the body.

Summary
In this module, we created a modal component and an associated directive. We saw how we can create more advanced components and directives and how they can work synergistically in order to create a good developer and user experience.

More Components and Custom Validators
Introduction
In this module, we are going to continue our work with components and also learn how to create custom validators. We'll start by creating a voting component. This component will have a lot of interesting functionality and teach us several things about input properties and also had to deal with a component that has different functionality whether you're logged in or not. After that, we'll create a custom validator. Custom validators are a special kind of directive, so we'll be applying what we learned in the last section about creating directives in order to create this validator. When we're done, we'll have seen a couple more typical scenarios for custom components and directives.

Creating a Voting Component
Our modal dialog box is now complete. We've got a fair amount of functionality with it, it's very stable, it does what we need to do it, and it's quite versatile. So we're going to turn our attention to a new component. We're going to implement the functionality of voting on sessions. Here in the details page for an event, we have a list of sessions. Off to the left, we'd like to put a little voting icon that lets people vote for a session to indicate that they like it. So we're going to go to our code, and we're going to go into session‑list.component inside of events, into the HTML. And we've got this div that is a column of 10 out of 12 sections wide. We're going to add a new one. We're going to add a div with a class of col size medium, we'll just make this one 1, and inside of here, we're going to put our voting component. I'm going to call this component upvote, and this upvote component is going to need three things. We're going to have to tell it, one, how many votes the current session has, two, whether or not the current user is voted, and finally, we need to know when the user actually clicks on the voting component to vote. So we're going to need to listen to a vote event, and we'll call a method toggleVote because we want the user to be able to click to vote, and if they've already voted, they can click again to unvote. And we'll pass in the current session, so that we know which session they're voting for, and that matches this variable here. We've also got to give it a count of the current votes, and we access that from session.voters.length. Then we need to tell it whether or not the user has voted. We'll call a method userHasVoted, passing in the current session, and that will return out whether or not the current user has voted. There's just not a very easy way to determine if the current user has voted, so it's much easier to call a method to determine that, and then we'll close this up. So there's upvote component HTML. Let's go ahead and create that component. So I create a new file, and it will be called upvote.component.ts, and we're going to need a few things from Angular Core. Of course we need component. Since it's got an event that it raises, we're going to need the EventEmitter. We've got two input properties, so we need input, and that event that raises is an output property, so we've got to import output, and now we can create a component, which has a selector of upvote, and it's template will look, something like this. We'll start off with a div, it has a class, we'll put in some styling classes, votingWidgetContainer and pointable, so that it mouses a pointer when we hover over it. And we want to know when they click on this div, so we're going to add a click event, and we're just going to call onClick. And inside of that div, we have another div with a class of well, and we'll add a votingWidget class, and that'll be used for styling. Inside of that, another div with a class of votingButton, and this will be the display, inside of here, we're just going to put a couple of glyphicons, and one if they have voted, which will be the heart icon, so we'll add the ngIf, and if they voted, then the class will be glyphicon, and it'll be the heart. And then again another icon, and this one if they haven't voted. And the class is also glyphicon, and this one is glyphicon‑heart‑empty, and then after the voting button itself, we're going to need to show the count, so I got another div with a class of badge and badge‑inverse. These are Bootstrap classes, and we'll also give it our own custom class, votingCount, we'll close that up, close up our other div, and now we can create our component class. It has to be called UpVoteComponent, and we have those two input properties, count, which is a number, and voted, which is a Boolean. And we have one output event, which is named vote, and that will be a new EventEmitter. And the only other thing we need to do is implement the onClick method, in which case we're going to emit the vote event, and we don't need to give any data, so we'll just pass out an empty object. Alright, our component is implemented. We've actually got to style this up quite a bit in order for this to look decently. So I've already created a bunch of CSS to handle this, and I'm just going to create a styleUrls property, and that'll point to app/events/event‑details/upvote.component.css. And let's create that file, and I'm just going to paste in a bunch of CSS that will style this correctly. You can look through here and copy the CSS that I've pasted in here, or you can just grab this file from the GitHub repo, and that will style your element up correctly. So I'll save that change, and I'll go into the index file and add that new component. We'll go into our module, and import the component, and also add it to the list of components for the module. Of course, I do need to save my changes to the index file. And if we try to run this, it's going to error out because we haven't got into our session‑list and implemented this toggleVote method or this userHasVoted method. Those aren't implemented yet inside of our session‑list, but we'll implement those next.

Adding Voting Functionality
We've got our voting component created. Now let's implement the functionality. So we've got to react to this vote event through this toggleVote method, and we need to implement this userHasVoted method as well. So let's go to our session‑list component, and we'll start off with the toggleVote method. I'm going to put this down here after the onChanges event. That takes in a session, which is a ISession, and in order to toggle the vote, we need to do one of two things, so if the user has already voted, then we need to unvote, and if the user hasn't voted, then we need to vote. So we're just going to ask if the user has voted, which we've got to implement that method anyway, so we can call it userHasVoted, passing in the session. And if they have voted, we're going to undo their vote. Now I don't want implement the functionality here to deal with the data. I'd rather create a service that handled voting functionality. So I'm just going to call that voterService, and I can call deleteVoter. And of course it will need to know the session, and it'll also need to know the user name of the current user. If we go into our event.service, you can see that the data for a given session has a voters array, which is just the user names of users. So we're going to need to know the user name, because when we undo their vote, we need to find it and remove it from this array. And in order to get that, down here in our user folder, we have the auth.service, and the auth.service has a currentUser, and that current user has a userName property. If we go back into our session‑list, we can say this.authService, I'm just going to call it auth.currentUser.userName. And now if they haven't voted, then we have to act differently. We need to vote for them. So in this case, we're going to call voterService.addVoter, and again the same parameters, the session and the userName. And finally, since we're changing the number of votes, if they're sorting by votes, we want update the sort. So we'll say if this.sortBy is votes, then this.VisibleSessions.sort. Now we're going to sortByVotesDescending. Alright, so there's our toggleVote method. The first thing we need to do to make this work is to implement the userHasVoted method, which again belongs to the same component. That takes in a session, which is an ISession. And we could return this.voterService.userHasVoted, passing in the session and the userName. So now we need to bring in the authService and our voterService. The voterService hasn't been created yet. So let's first bring in the authService. So I'll go up here and import from up two directories, users/auth.service. We are in event‑details, which is underneath events, which is a sibling to users, so we had to go up two, and inside of there is the authService. And then we'll need to add that to our constructor and inject it. So let's create a constructor, create the authService, and we'll also need the voterService, but we haven't created that yet, so let's create the voterService, and we're just going to put that in the same directory as event‑details, since this service is unlikely to be used by anybody else. Since it's a service, we want it to be injectable, meaning we want to be able to inject other services into it. So we're going to import Injectable @angular/core, and we'll call that @Injectable decorator, create our class, and it has to have the three methods that we referenced back in our session‑list. component, deleteVoter, addVoter, and userHasVoted. So deleteVoter will be our first one, and that takes it a session, which is an ISession, and a voterName, which is a string. We need to import this ISession type from the model, which is up in shared/event.model. And now to delete a voter, we're going to want to adjust the voters array, so we're going to update that, and we're going to do that by filtering it. We get the voter, which is the name of the voter, and so we're going to filter on if the voter, or their username, does not equal the voter name that was passed in as a parameter. So for whatever element in that array has that voter name, it's going to get filtered out, everything else will be included, so the new array that's created through this filter method will be all of the voters, except for whatever one matched the username. addvoter will be a little bit simpler, same signature, but this time we just do session.voters.push the voterName. And finally, userHasVoted, same signature, and in this case we will return a Boolean variable. And we'll just call the some method, which is a method on an array that will return a Boolean, whether there is or is not at least one element that matches a specific condition, and that condition will be that the voter is the same as the voter name passed in. So if the value of the element of the array, the current element of the array, is the same as this, then we're going to get a true, and therefore this whole method will return true. And it'll keep scanning through until it finds at least one record that returns true, if it gets to the end, and none of them are the same, then it'll return false. So now we've got our three methods implemented. We can go back to our session‑list, and we need to import that voterService. Grab that, and we will inject it into this class. And of course since we just created that service, we need to add it to our index files, so let's save our change here, go to the index file, and add that service, and then go to our module, and we'll import the service, and add it as a provider to the whole module. And now, if we go back to the browser, I'm not going to refresh, I'm going to go to go to the events page, and then refresh, and there's a reason for that, and that is that voting functionality requires a current user. I wasn't logged in, and even if I was, when I refresh, the client loses the knowledge of the currently logged‑in user and you're logged out again. And so the details page will break, and we can see that here, if I click into the details page, notice it's completely broken. So let's go back to events, and I'll log in, and now if we click on an event, the voting functionality is there, and I can click on it, and we go from the empty heart to the filled‑in heart. If we go from 3 to 4, then we get the flame icon next to the session. So there's the basics of the voting service, and in the next section, we'll address this issue about having to be logged in.

Hiding Functionality Before Authentication
Now let's quickly fix the issue that you cannot get to this page if you're not logged in because the voting functionality breaks if there isn't a currently logged‑in user. So we're going to go back to our code, and inside of the session‑list.component way up right here, in the HTML, we've got this upvote component, and this just shows up all the time. So instead of having it show up all the time, let's have it not show up if the user isn't authenticated, and we can do that easily by wrapping this in a div with an ngIf . And remember, we've imported the AuthService into our component. So right from here, I can call auth.IsAauthenticated. Now just a quick side note here, your editor might complain that auth is a private variable. This may or may not give you problems because we're now accessing the auth variable directly in the template. At the time of this recording, that doesn't cause any problems, but in the future, that could change. To be safe, you can go into the component and change the auth variable from private to public, where it's declared in the constructor. Back to what we're doing, we're calling isAuthenticated here. That is a method inside of the auth.service, if we go to the auth.service, we've got this isAuthenticated method that returns true or false based on whether or not the current user is authenticated. So if we wrap our upvote component inside of that div, then if we go back and we refresh the page, we're no longer logged in, you can see that, but the page doesn't break, it just doesn't show the voting widget.

Using @Input Setters
Now we'll make one small change to our voting widget. Right now, it goes from an empty heart to a full heart when you vote. I'd like to change that to go from a white heart to a red heart when you vote. So let's go back into our code and it's here in the voting widget, this upvote component right here that we need to make that change. So here is where we got the glyphicons, whether it's heart or heart empty based on whether they voted or not. I want to change that. I'm just going to use the glyphicon of heart. I'm going to get rid of this heart empty, but I'm going to bind to the color property of style. So really, what I want is I want style to have a color of red if they voted and have a color of white if they haven't. So therefore, I want to be able to set the color property of the style for that icon, and I can do that by binding to style.color and I could set that equal to some value that exists inside of my component. I'll create a new property named iconColor and that way I can set iconColor as a string to either white or red, and I would want to set that based on whether or not they have voted or not voted. Now I could do this by adding an on changes lifecycle handler like we've done in the past. And since it's an input property, every time it gets a new value, I'll see the value and I can react to it. If it's voted, I can change it to red, if it's not voted, I can change it to white. But there is an easier way to do this. We can use a setter on input properties. I'm going to get rid of this icon color, and for this voted property, I'm going to add the word set. And then this now becomes a function which takes in a parameter, which is called val, and that has a body, and I can set this.iconColor equal to val if it's true, then we go to red, and if its false, then we go white. And I do need to create that iconColor property, but this will be public, not private, and I want initialize it here because it gets initialized here on this line. And since the icon is visible all the time, we no longer need this ng if, we can get rid of that, and we could save our changes, go back to the browser, we'll refresh. Of course, we need to log in. And now if we click on the heart, it changes from white to red. And that's how you can use input setters in order to create a derived value from an input property.

Creating a Custom Validator
Before we finish up this module, we're going to create one last directive. Remember in our Create Event form, we have an event location at an online URL. Now, when the user is creating an event, they either need to give the location including all three fields, or give the online URL, and that's what makes the form valid. Right now there's no validation around these fields, so you don't have to fill these in. The other fields are required, but not these ones. So we want to create a custom director that'll validate this. Make sure that they've either filled up all three of these fields, address, city, or country, or they filled out the online URL. This is not something that Angular will handle by default, so we've got to do this ourselves. Let's take a quick look at the HTML for the Create Event form. Here inside of events, it's down in this create‑event.component.html. Close this other stuff up. All right, here is the HTML for our form, and the relevant part is down here. We have this model group called location, and that wraps around the event location, which is the address, the city, and the country. That's this model group here. And then we've got a different form‑group, which is the onlineUrl. Now we need a custom validator that will apply to both of these. Unfortunately, since they're sibling nodes, it's not going to be easy to create this custom validator because it will be put on one of those nodes, probably this node up here, but it will need to access both of these nodes, so this is going to be a fairly business‑specific validator. What we want to do, then, is add the validator to this node as a directive, something like validateLocation. And once we add that validator to this node, then we want it to apply the validation, these custom validation rules we're talking about. Let's go ahead and get started with that by creating our custom validator directive. Since this is fairly business‑specific, I'm not going to put it in a shared folder; instead I'm going to put it right alongside the Create Event page itself, and we'll call this a location‑validator. It's a directive. And so we're going to need to import Directive from angular/core, and now we can create our skeleton directive, and of course we need to give our directive a selector, and it's going to be the attribute validateLocation, which we saw over in our HTML. That's the attribute that we want to use. Save that file. And we're going to add another piece of this directive in a minute, but I'm going to leave this alone for the moment. We're going to export our class. I'm going to call it LocationValidator. Even though it's a directive, I'm not going to add the directive suffix, just the validator suffix. And since it's a validator, it can implement the validator interface, which comes from Angular forms, so let's bring that in. So there's our interface validator. We'll implement that. And that means that this class needs to implement a function called validate, which takes in one parameter, which is a form group. I'm going to call that control, and the type is FormGroup, which we can get from Angular forms as well. And that method returns an object, and that object can have keys, which are strings, and the value of any key can be anything. And inside that function, we need to get a handle on our address, city, and country, and our online URL. And to get that, we'll start with the address, which is a control, so we'll suffix this with control, and that'll equal our control, which is are FormGroup, .controls, and we want the address. I'm accessing the address property through the indexer. Syntax like this, which is really the same as doing it like this, except for because of typescript, it won't see it that way and it will give us this error, so instead we use the indexer syntax. And I really don't like this name control. Let's call this formGroup. All right. And we also need the city, and the country, and finally, the onlineUrl. So, city is next, then country, and finally, the onlineUrl. And in this case, since our validator is on a sibling of the onlineUrl, I'm going to actually go up a level by going to the root, and then I want to get to its controls. Unfortunately, the type of root is just an abstract control, but I actually know that the type is a formGroup of the parent. If we go and look at this model group, its parent is a form which we can access as a formGroup by giving it a type, and now that has a controls property and I can get the onlineUrl. So that's how we go up a level from the node that we're at, which is going to be, again, this node here to get a sibling node. So we have this model group right there and we want this node right here and to get its online URL. You'll remember, even though we are looking at nodes in here, it's really a tree structure of controls that we're dealing with when we're talking about the formGroup and its controls and going up to its root. This is a tree structure of controls. It reflects the DOM tree, but it doesn't include all of the nodes in the DOM tree. Now that we've got all our controls, we want to write a statement that says either the address, city, and country have to be filled in or the onlineUrlControl has to be filled in. So, in that case, we write in our if statement, and then we want two clauses to that, so I'm going to add another set of parentheses. And the first clause is going to be the address, city, and country are filled in, and then the second clause is going to be an or, the onlineUrl control is filled in, so another parentheses for that one. That one's a little bit easier, we'll do that one first. The onlineUrlControl has to exist, and its value has to exist, so it has be filled in. And we'll do the same thing with the other clause, which is address, city, and country. So, addressControl and the addressControl's value has to exist. And the cityControl, cityControl.value, and finally, country, and it has to have a value. So there's our if clause, and if this is true, then we want to just return null. Returning a null tells the validation system that this validator is passing, there's no problem. If it's false, then we want to return an object with validateLocation as a key set to false. And that matches the type that we defined up here, where a key is string and the value could be anything, and we have a value of false, and this key, which is a string. So it's going to return either a null or this object. If it returns this object, the validator is going to be failing and we'll get a validation error. And there's our validation control. It's still missing one very important piece before it'll work as a validator, but I'm going to talk about that in the next section. So instead, let's just add this validator to our dependency injector by going into the index and exporting it. We'll save that and go into the app module, and this will be inside of the events, so find it there. And it's a directive, so I need to add it to the Declaration section. And there we go. We can save our changes on both files. We've got our validator created. Again, it's still not working, we've got more to do, and we'll see that in the next couple sections.

Adding a Validator to Angular's Validators
And we've created our directive. It's a valid directive, and our module knows about it, so it can be used as a directive. In order for that to happen, we've got to add this validator to Angular's list of validators, and that list exists here in Angular forms as NG_VALIDATORS. This is an opaque token. If we were to inspect this variable, it would be an opaque token. What it represents, of course, is a list of every validator that Angular supports. If we want to add a new validator to our application, we need to add it to this service, essentially, this NG_VALIDATORS service, and there's a very special way that we do that, using some syntax that we haven't seen before, and this is how it works. We're going to go down into our directive, and we're going to add a providers key. Now, if you'll remember, in a previous section we talked about dependency injection and how every component has its own dependency injector. We can register services with the dependency injector on a given component, and those services will be available to that component and its children. That works for directives just like it works for components. So this allows us to use this providers key here, just like we do in the app.module file. But what we're going to do is, we're not going to create a new service. Instead, we're going to add this validator, the LocationValidator, to this list of NG_VALIDATORS, which is essentially a service. And we do that by giving an array to providers, and we use the same syntax that we saw before when we were adding new providers using the long form of provide. And then we give it a token, so here we use our NG_VALIDATORS token, and we're going to say useExisting, and that will be our LocationValidator. So again, I'm giving it the same class that I'm creating right here. Now you might look at this and say, wait a second, what you're actually doing is overriding the NG_VALIDATORS with the LocationValidator, so whatever was there is going to be gone and instead, all we have is the LocationValidator so all the built‑in validators would not work anymore. That would be true if I left it exactly like this. Instead, I'm going to add a third key to this object called multi and set it to true. When I do this, what it does is, it tells Angular, hey, this service here, which is a validator, we want to add it to this list of services because we're setting multi to true. This ultimately is a collection of services, and we're adding one more item to that list. I know this sounds a little bit weird, and it's not really important that you understand this from a level that you'll want to do this on your own, because this would be a very unusual case, but for adding your own custom validators, you need to know the syntax so that you can do it yourself. And rather than just showing you the syntax, we're going to explain it a little bit that what this does is it adds another item to this list of services that's underneath the NG_VALIDATORS. Once we've done that, we've now registered our validator with Angular's so that it's available as a validator in a form. And again, even though this is a little bit deep, all you need to know is that this is a list of validators, and we're adding a new one to it by setting multi to true.

Implementing a Multi-field Validator
We've now created our validator directive and added it to Angular's list of validators. Let's save this change. But before we head to the browser, we need to check and possibly fix one item. Here in our creative NHTML way down at the bottom way down here, we need a double‑check that the disabled attribute is being bound to the correct button. Here, you can see that I've bound to the disabled attributes on the Cancel button, but that actually needs to be on the Save button. So that's where you have this disabled binding, we need to move it off the Cancel button and up here to the Save button, and we'll save that change as well, and now we can go back out to the browser and refresh. The validator is going to be running, but it's not going to work correctly quite yet. Let's open the console and just keep that open and let's, I'm just going to use some garbage values in here. And now, since none of these are filled in, this should not allow us to save and we're seeing that's true, so let's fill in just the online URL and we'll go back to our button. It's not valid yet. If we leave, it's still not valid, so let's go in and add an address. And now our button is still not valid. So we've got a problem. Our validator isn't quite working right yet. We need to fix this by giving the validator a little bit more information. Going back into the code, I'm going to go into the HTML, and up here where we created the validator and added it to this div, I'm going to mark this div as a model group. We've already got the ngModelGroup property set, but I'm going to add that to a local ref variable called locationGroup and I set that equal to ngModelGroup, So the syntax is a little bit weird here. Here, we're adding a property called ngModelGroup and setting it to location, and here we're adding a local ref locationGroup and setting it to ngModelGroup. What Angular is doing is taking the model group and adding it to this ref so that we can access it. Let's save that and we'll go back to the browser and refresh, and we'll try this again, give it an address, and now you can see that our button is enabled. If I delete one of these values, the button is disabled, if I put it in, the button is enabled, but what happens if we don't have an address, and instead, we have an online URL. Notice that the button is still not enabled. So our directive still isn't working correctly, and the reason for this is that the directive is on this address, which covers these three fields and not on the online URL, so it has no idea when the online URL's value gets changed and we need to fix that. And there is a fairly simple way to do that. We're going to go down into our input box, and we're going to add an event handler on the change event. So I want a list of the change event, which is fired whenever the value of the input box changes. And what I want to do is take this location group that I've created up here, this ref. Refs are available not only in the node and it's children, but also in sibling nodes. So here, I can refer to that ref and I could access its control property, which has an array of controls. So the location group refers to this div, this model group essentially, and the control would be the model group's control, and that has a controls array, which would be all of the three different input boxes, the address, the city, and the country, and I just want to access one of those three controls. So I'm going to access the address control and I want to tell it to reevaluate its validation and I can do that with the update value and validity method. I just call that right here and what this will do is every time the value of this inputs box changes, it will go to the address control, which is right up here, this input box right here, and tell it re‑run your validation, which will then reevaluate the validation not only for this, but including this validator that we put up here because that applies to this input box, it will re‑validate it and now, if this is valid, then the form will now show as valid or invalid. So if I save that, we go back to the browser, and we refresh our change, again, more garbage data, notice the Save button is disabled, and if I tab out, that fires a change event, and now the Save button is enabled, but if I go back in and remove this and then tab out, the change event fires, the Save button is disabled, but I'm not given any information about what's going on. So let's add a little message that says, hey, you've got to have either the address or the online URL. So our validator is now working correctly, but we just don't have feedback. That's pretty easy to fix. Here, on the address right after the event location, we're just going to add in a little emphasis tag and we'll only show it if the location group, and that's this ref I created up here, let's make it nullable. It's invalid property is set and the locationGroup has been touched. We don't want this to show up if we've never touched any piece of the location group, so again, nullable, and then we'll put it in an error message, save that change, go back to the browser and refresh, and now it tempts us by giving it a value and then remove the value. And now we're getting our error message. You must enter either the full location or an online URL. So there we have it, we've got our error message working. We've got our validator working. It's a very strange and complex validator. We've had to touch a lot of different pieces of the form in order to make this work. There are other ways to skin this cat as well, but this is certainly one that works and it's a way to create a complex validator like this.

Summary
In this module, we created our voting component. This component had to do some interesting things with input properties, and it also had to hide itself when the user wasn't logged in. After that, we saw how to create a custom validator. This validator involves several moving parts, but showed us how we can build validation functionality that isn't already part of the Angular framework.

Communicating with the Server Using HTTP, Observables, and Rx
Introduction
In this module, we are going to learn all about how to communicate with the server using HTTP. In Angular, this means observables and RxJs. We'll start out with an introduction to RxJs. Then, we'll learn how to communicate with the server. In this module, we are going to move all of our data storage from the client to the server. We'll go through the Events Service and the Voter Service and change their functionality to store their data on the server. Along the way, we'll learn a lot about how Angular works with RxJs. Finally, we'll move our authentication to the server and implement the logout feature while we're at it. HTTP communication is key for most web applications, so this is a module that will be critical to learn. It's important to understand the basics of HTTP communication so that we can see where RxJs fixed into the mix. Here's a simple diagram of HTTP. The client sends a request to the server and the server responds. This is an asynchronous communication pattern. The time between the request and response could be several hundred milliseconds or more, so our client continues to process while this is happening. In the old days, we handled this with a simple callback, shown here. We made the request and some kind of callback function handle the response whenever it returned. Then, along came promises. Promises were nice because we could arrange our handling of async operations a bit better. Multiple pieces of code could listen to the result of a single call, and we could avoid nested callback hell. And now we have RxJs and their main feature, observables. Looking at the code here, you can see that the basic handling hasn't changed a whole bunch, but the feature set really has. First, let's clear up the main difference between promises and observables. Promises represent a single value that comes back sometime in the future. Observables, on the other hand, represent 0 or more values that come back either immediately or in the future. Right off the bat, we can see a major difference between the two. Promises are limited to a single value where observables are not, and promises are asynchronous where observables are either synchronous or asynchronous. And there's plenty of other features that observables support that promises do not. Observables are often referred to as a stream of observable data or, in essence, any value that changes over time. Consider, for example, mouse clicks. Each happens at a specific time and has an X and Y coordinate. Observables are excellent for handling data like this, since not only can you observe this data and respond to each mouse click as it happens, you can also manipulate the data stream. Let's say, for example, that I wanted to just react to each X position, not caring about the Y position. I can manipulate the stream so that I'm only dealing with the X position, like so. This is generally done through a map operation where you map an incoming value to a new value. With observables, this is a core activity and very easy. This comes in very handy when dealing with HTTP responses, since the data that comes back is often way more than we want. There'll be status information, headers, et cetera, when really all we want is the returned data. So mapping a response to just the returned data is very natural with observables. Observables have a lot of other features that are very valuable as well. They can be synchronous or asynchronous. They have improved error handling over how promises work. They can be closed independently of returning a value. And they can also deal with time in a way that promises cannot. There's a bunch of advanced operations that they have as well, such as mathematical aggregation, buffering so that you get several results together in batches, or debouncing so that you don't get too many results if they happen too quickly, you can only deal with distinct values, or you can filter the values down to just the ones you want. You can also combine multiple observables into a single observable, and they have a built‑in retry mechanism so that if the first try fails, they can retry again. So now we know that observables are the answer we've all been looking for for every problem we've ever faced while programming. Therefore, we should purge all knowledge of the despicable technology we call promises from our brains, right? Well, not so fast. Remember, in our HTTP communication model where that communication consists of a request and a response? Unless we're using sockets, each HTTP request can only represent a single value, so being able to deal with a stream of data does us no good. Unless we're using sockets, each HTTP request only represents a single returned value. It might have multiple pieces of data inside that single value, but in the end, it's one response that comes back. So being able to deal with a stream of data does us no good. For most purposes, a promise works just fine when doing HTTP communication. Of course, Angular's HTTP library returns observables, so this really doesn't matter, does it? Well, yes, it does, because of one key feature that observables in Angular support. And that is the toPromise conversion function, which will take any observable and convert it to a promise. So if you decide, you can cast any HTTP request down to a promise, and you can even do it after you map the data from the response to extract just the data you want from it. That can make your handling of HTTP requests benefit from the features of observables and the simplicity of promises. Now, that doesn't mean that this is the recommended way to deal with HTTP. It just means that observables aren't necessarily the only way to handle things. You can choose for yourself whether or not to leave all your HTTP communication as observables or convert them to promises. It's up to you. In this course, we'll only use observables so as to get the most familiarity with them. Just don't write off promises in your code. And with that, we'll finish up our introduction to RxJs. There's a practice exercise for this clip if you want to do that now.

Preparing to Store Data on the Server
In this module, we're no longer going to be gathering our data from inside of our application. We're going to be communicating with the server. But in order to do that, we need to have a server to communicate with. Now we have built a small little server specific to this course that looks and acts like a real server, lets us gather data and save data, but it doesn't really have all the features of a real server. Getting into actual server‑side technologies is way beyond the scope of this course. We're just going to be dealing with how the client interacts with the server. Let's start by installing that little server. I'm going to go to a command line, and I'm going to type in npm install ngf‑server, and I'm going to save it to my dependencies with a ‑s. And now that that's installed, we go back to our code, and we're going to open up the package.json file. And now if we look, we've got our ngf‑server installed. We need to run that server, so we're going to need a new command for that. I'm going to name this command server, and that will call node. This is a little node server. And we'll add a parameter to that, which is the location of the server file, which is inside of node_modules/ngf‑server/server.js. And we'll save that change, and back to the command line. We can run that command with npm run server, and that will launch our custom little server that we can talk to to save and request data from. Now, we are still going to be using the CLI to serve up our files. So, we need to tell the CLI's web server that when we make certain requests to certain URLs that it actually needs to talk to our little custom server. This is only for dev mode. We do that with a special proxy file. So I'm going to create a new file, I'm going to name it proxy.conf.json and put that in the root, and inside of here, this is a JSON file, so we start with an object. I'm going to tell the CLI that whenever I make a request to anywhere else starting with api that I actually want it to talk to my own server, which is running on port 8808. So, that's going to be target, and we give it the URL http://localhost:8808. And finally, we're not running an SSL server for this little server, so we can tell it secure false. I'll save that change. And back in my package.json file, whenever I launch the CLI, which I do with the start command, I need to tell it that I want it to use that configuration file for the proxy settings. So I'm going to add on a proxy‑config with a setting of proxy.conf.json, which is the path to that file. Save that change. And now in a different command line, if I was already running the server, I would stop it at this point and restart it and just start it again with npm start. If I'm not running the server at this exact second, we'll just start it back up. And starting it again is now going to run it with that proxy‑config setting. And there we go, our server is running on port 4200, so we go back out to the browser and refresh. And our application is still running correctly. It is using that proxy server, and we'll talk to our actual server, but we aren't doing anything yet, so there isn't any communication going on quite yet. Now, this arrangement is complex enough that I want to spend a minute and just look at a couple of diagrams to explain how this works. This is again only for development. When we're talking about going to production, the arrangement is going to be different. This is how our servers are arranged in development. We're going to be running both the CLI server and our new HTTP server that we installed just a few moments ago. When our browser makes a request for something like /home, or a CSS file, or something else along those lines, anything that the routes file would answer to, pretty much any URL that doesn't start with /api, then the CLI server is going to respond to that request and serve up whatever file is appropriate. If it's a route, it's going to serve up the appropriate index file. If it's an actual file, like a CSS file or an image, it's going to respond with that image. But in the other scenario where we are going to make a request to something like /api/users, again, this is based on the configuration we did in that proxy configuration file, the CLI server is going to see that request and pass it on to our actual HTTP server that we spun up and installed just a moment ago, which is running on localhost 8808. That server is going to respond based on its own internal rules. So, for example, if we ask for /api/users, it's going to send back JSON that lists all of the users. So that response comes back from the server, the CLI server then receives that response and sends it back to the browser. Again, this is only how it works in dev. In production, it's more your typical scenario where your server actually handles all requests, whether they're to /home or to /api/users, and so it's time to start using HTTP. We're going to start that. We're going to be moving all of our data communication to using HTTP. And to start off that process, I've got to make some changes to my app.module file. I'm going to close these files down and open up app.module, and in here I'm going to tell my module, my main module, that I now need to work with HTTP. I am going to import from @angular/common/http, and from there I'm going to import the HttpClientModule. And then down where I create my module, I'm going to add that to the imports, and that has now imported the client module and all of its relevant classes and utilities into this module, so we can now begin using HTTP. Save that change, and in the next section, we'll actually start accessing some of our data over HTTP.

Moving Data Storage to the Server
And we're going to start with our events service. Let's open that up, event.service, and this class right here is providing access to our events. For example, the getEvents method right here. This accesses our events, and if we scroll down, it's this local EVENTS data right here that we're actually accessing. We no longer want to access this local events data; we want to access the events data that is held on our server. We want to access it through that new little web server that we installed. So this class now has to utilize HTTP, We start off by adding the HttpClient, I'll do that with a constructor, and I'm going to create a private variable. I've named it Http and the type is going to be HttpClient. Let's import that, again from the Angular common HTTP library, and we'll start by converting our getEvents method. So we can take all of this code right here and just get rid of it. We like the signature. The signature is good, because it's an Observable of IEvent, but we no longer want to grab it from this local array that's just here in this file. Instead, we want to talk to the server. So we're going to return this.http and the http class, that HttpClient class has a method for every type of HTTP interaction we can do. We're gathering data, so we want to make an HTTP get request, so we will call .get, and that method will make a get request. This is a typed method where we tell it what it's going to be returning out, and it's going to be returning out again that IEvent array, and it takes in a set of parameters. The only parameter that we really need is the URL. So our URL to request the events is just /api/events. Notice how we're starting with /api in our proxy config file. We told our server that any requests that come to a /api/anything are going to actually get forwarded onto that new server that we've got running on port 8808. So we've got to make sure that any URLs that we use start with /api. And correspondingly, that little server is set up so that if any requests come from /api/events if it's a get request, it's going to return a collection of every event that is in the server's dataset. Now at this point I'm getting my data, and it's going to be typed correctly and everything is fine, but what happens if I have an error? I want to handle errors. So I'm going to create a private method called handleError, and that has a type of just T; this is a generic type, and the operation is going to be defaulted to the string operation, and it has a second parameter, which is a result, which is an optional parameter, which will be that same type T that is the type parameter. And from within here, I'm going to return an Observable of T, a function that takes in one parameter error, which is of type any, and that function returns an observable of that same T type, whatever that type is. And that function is going to call console.error. So it's going to report out to the console that there was an error, and we're just going to report out that same error object, and then we're going to return of the result cast as a T. We've also got to import the of operator up here. This is some kind of deep typing with these signatures and stuff using the generic type of T. Really digging in and understanding all of this is a little bit beyond the scope of this course, because this course is not specifically about our RxJS or about TypeScript, but this gives us a nice template for just basic error handling, and anything we want to do to handle the errors we can just do right here. So if you want to just copy and utilize this code as is, but you want to customize it a little bit, you just need to add a little bit more code here where we have the console.error. Maybe you want to log out to a database or to an actual error logging system. Whatever it is, you can customize it there, but this code can pretty much just be copied and pasted. As you get more into RxJS and more into TypeScript, you can learn how to deal with this code and do specific things that might work better for your situation. But for now, this code is going to be a nice template that we could just utilize to handle basic errors. And to utilize the error handling with RxJS, we're going to pipe this get method. So if I type in a period here, we can see the pipe is another method on what's getting returned. So I'm going to put on a new line so we have a little bit more visually clean code, and we'll call pipe, and we're going to call a special RxJS method called catchError. And catchError was going to be imported. We've got to import that from rxjx/operators, and that's a method where we pass in that handleError method that we created. And that method has a type parameter, which we're going to set to IEvent array, because that is the return type of this getEvents method. And then when I call it, the first parameter it wants is an operation, and that's a string, and that's just the name of the method. This is for error reporting purposes. So I'm going to pass in the same getEvents. That's the name of this method. So if this method has an error during the HTTP call, when the error is reported, the word getEvents will get reported out, and I can pass in a default result. So I can pass in just an empty array. And now with that, we're calling the get method, and we're handling any errors with a very basic operation of just logging out to the console. So let's save that change. And now, if we look to see where this getEvents is called from, we're going to find that it's in the event‑list‑resolver, and it's right here. That's where we call getEvents. Notice this map call is just mapping events to itself. We can actually get rid of that. So let's delete that map call, and this is a resolve function. Now we need to note something here. A resolver automatically subscribes to an observable call that it gets. So getEvents, if we go back to our events service, notice the return type is an observable. Angular has built‑in functionality that in a resolver, any observable that it gets, it will subscribe to itself. We don't have to make a subscribe call, but if we were making a getEvents call ourself somewhere else, like just in a component or another service, we would need to subscribe to this observable with a call to .subscribe. The reason we need to do that is with HTTP observables, the HTTP request does not get made until somebody subscribes to that observable. So if nobody ever subscribes, that HTTP call will not happen, and that is a common gotcha that can happen with RxJS, is you create an observable, you return it from a method, and so then when you call that method, you might assume, hey, this observable is going to happen, because it's a call to get on the HttpClient, but that HTTP call will not execute until somebody subscribes to the observable. Again, we don't have to do that here; that's done automatically so I'll delete that code. We'll save that here, and now we can go back out to the browser. The CLI has already refreshed the page for us, but let's go to the Network tab, and let's refresh it again. And we're going to look at just XHR requests. And notice, we've now got this call to /api/events. Let's open this up just a little bit here, and we will zoom in a tad, and look at the response. Let's do the preview. We can actually see that we're getting back event data. This is what the server is returning to us whenever we call /api/events. This is the data that's getting returned, and our client is now grabbing that data, and that's the data that is getting displayed here in our page. It's these five pieces of data. If we had different events coming back from the server, then we would be displaying different data. And now we've created our first HTTP call using RxJS and Angular's HttpClient. There are practice exercises for this clip, if you want to take a moment to those now.

Listening to Resolved Data Changes
We've got getEvents converted to use HTTP. Let's now convert our next method, which is getEvent down here. I don't want the handleError method to be right in the middle. I'm going to move that to the very bottom, so I'm going to cut that out. Go down to the very bottom after searchSessions and put the handleError call there, and now getEvent. The getEvent has a problem because the signature is wrong. Right now it's just returning the IEvent directly rather than an observable. So let's start by changing the signature. The signature will now be an observable of IEvent. And, of course, this code no longer works. Instead, let's go ahead and just copy this code right here. But we don't want to be returning an array of events. It's just a single IEvent. And when we catch the error, we no longer want to give it a default array. But at this point, we're calling to the same endpoint, which is api/events, which is going to just return a list of every event. We only want a single specific event, so we're going to add onto this URL the id of the event, which is the parameter that we receive in, so we can just add on id. And that's going to make a call to /api/events/ and the id number of the event, and we're going to return a single event from that HTTP call. Now we need to go out to where this call is being made, which is in the event‑details. component. And down here in the ngOnInIt is where that's being called, and we can see that we're getting an error. We no longer can handle this code this way. Instead, we need to call the getEvent method, and we need to subscribe to, we talked about this in the last section, this HTTP call will not actually get executed unless we subscribe. So let's subscribe, and we pass in a function. The function is going to take in the value that comes back, which is a single event, which is of type IEvent. And inside that function, we will handle the results of the getEvent call. So, we want to set this.event = event, and, of course, we set addMode defaults here in the ngOnInIt. We probably only want to do that if the call is successful. So let's move this inside of our subscribe call. And that's all we got to do. If we save this change and go back out to the browser, we can click on a specific event, and this is the data for that event that's actually coming from an HTTP call. But we have a problem, and that is that this event details page is actually being guarded by an activation guard. If we look at the event‑route‑ activator.service, this service calls the eventService.getEvent and checks to see if the event actually exists. Now that call no longer works because it's returning out an observable and not an actual event, so this guard is no longer valid. So let's switch this up a little bit. Let's no longer guard the route. Instead, let's create a resolver on this data, and we'll resolve the data before we actually hit the page, and we won't even guard this route anymore. So let's start by deleting this file. I'm going to send this over to the recycling bin, and let's create a new resolver. Down here right next to the events‑list‑resolver, we're going to create another resolver, which will just be our event‑resolver. We'll name it event‑resolver.service.ts, and let's just go into the events‑list‑resolver and copy this code, and we'll use it as a template. Now, of course, we want to change the name. We no longer want to call this the EventListResolver. We're going to call this EventResolver, and we're no longer calling getEvents. We're going to call getEvent instead. But that takes in a parameter, and that parameter is the id that we want. In order to get the id that's being accessed when we have a resolver on a route that has a route parameter, we need to get a hold of the ActivatedRouteSnapshot. So here in our resolve method, we can actually pass in an ActivatedRouteSnapshot. We'll call it route, but the type is ActivatedRouteSnapshot. Notice that's being imported on line 2. And then within the call, we can call that route snapshot. It has a params property, and that params property, we can access the id property of that. We'll use the array access instead of the dot access. And we'll access it like this because the params type doesn't know what the name is. We can name a route parameter anything that we want. We named it id in the route. If we go into the route and we look at the events/:id route, we have named that parameter id. So that creates a property on the params object. We normally would access it as .id because that is the name of the property, but that type doesn't know about it. We could also have named this joe, in which case, we would change this name here to joe. But we did name it far more appropriately id, so we'll keep those two things as just id. So let's save that change, and we need to add this resolver to our index. We'll save that change, and now I need to add that resolver to the module. So let's go into the app.module, and we'll go down to the providers, and we no longer want the EventRouteActivator. This doesn't even exist anymore. If we were to scroll up to the very top, we'll see there's an error because that doesn't exist. So we'll take that out, and instead down here for the EventRouteActivator, we're going to use our EventResolver, and we will import that, and save that change. And finally, back to the routes file, we were using this EventRouteActivator, which no longer exists. We'll cut that out, and we'll change this canActivate to just resolve because we are going to be just doing a resolve instead of an activate guard. And this will be our EventResolver, and we'll import that, and, of course, save that change. And now back to our event‑details.component. This is where we need to get a hold of the event that is now being resolved, and essentially it gets loaded before this component actually gets executed. So we need to get a hold of that data from the resolver, and we have a pattern that's already doing that. In our events‑list.component, we're doing that same exact thing right here in the ngOnInIt. So let's grab that line of code, and inside of this forEach method instead of calling subscribe, we want to set the event equal to the call to the snapshot data. We'll delete that, and it's not called events, it's called event. And we can find that name by going into the routes. And this is where we set the name. We didn't set our name correctly. We just listed the resolver. We actually need to follow the pattern that's given right up here. So we change this array to be an object, and we name it event, and we fix that back into our event‑details.component. We now have an extra closing curly brace. Let's fix this indentation and this extra line. So let's save that page. We'll go back to the browser, no such file or directory event‑route‑activator.service. So we've got a problem. It's in the event‑details/index. It's still referring to the activator service we deleted. So let's go into that event‑details/index file. It's right here. We're still referencing it. We'll cut it out and save, go back to the browser, and there we go. It is selecting the data for that one event and populating our browser. If we check the console and look for any errors, we're not getting any errors. But before we finish up, let's go back, and we're going to clean up one small issue in our code. Here are our event‑details. Notice that we're actually subscribing to the params object. The ActivatedRouteSnapshot has a list of parameters. It also has a list of all the data that's been resolved, so we can simplify our code quite a bit by changing this from params to just be data, and the value that's received we'll just name it data. And now, we access data as a property, not of the snapshot, but of the callback that's being passed into the forEach function. So let's clean up our code a little bit, we'll save that, and there we go. We're now listening to resolved data changes. If we look in our browser, and we are on the Angular Connect event, if we do a search, and scroll down, and do something else, it's routing to the correct event.

Using POST and PUT
We've now converted getEvents and getEvent to use HTTP. Next, we're going to do our saveEvent method. Now saveEvent is going to be different because we need to send data to the server, which means we need to make a post request instead of a get request. So let's come down here to our saveEvent, and we are going to get rid of its implementation. And since we're making a post, let's just check out what post looks like. Call this .http.post and let's look at the parameters. Notice the first three parameters. The first is the URL just like with get, but then we have a body parameter, and then third, an options parameter. Those parameters are all required. The body is the data that were sending up, but the options allows us to do things like set our HTTP headers, which can tell the server what kind of data were sending up, and that's exactly what we need to do here. We need to tell the server that we're setting up Json data. So let's create an options variable and that's going to be an object that has a headers property and that headers property is going to be a new HttpHeaders and let's import that. That just imports from that same common HTTP. And inside of here, we pass it an object where we can specify any headers we need to set. We only need to set one, the Content ‑ Type, and that property is going to be set to the string application/json and that tells the server we are sending up Json data. Now in the post call, we need to set the type of data that's going to be returned by the post, and not in every case do you care what comes back from a post call, but sometimes you do. If we're going to create a new event, we might want to get an updated copy of that event from the server because the server might, for example, set the ID of the event and that actually happens in our case. So we're going to give it a type of IEvent, and inside of our call, we're going to be using the URL of /api, of course, /events, and because it's a post method, the server knows that we're creating an event. Then we need to pass in the body that we're going to send to the server. In our case, we're just going to pass in that event. And finally, we're going to set our options. This is, of course, an observable, and we want to catch any errors. So we'll go up here and grab the catchError method, and we can use the same exact one, except instead of getEvents, we're going to set this to saveEvent and notice we missed something in the last section, getEvents should here be just getEvent. So there is our call to http.post. We want to return that observable, that way, whoever calls the saveEvent method can then subscribe to the observable. Let's save those changes and we'll head over to the CreateEventComponent, and here is where we call the saveEvent method, and right down here where we call saveEvent, this is now an observable that we need to subscribe to, and it does return the event from the server, but we don't really care what's coming back. We just want to know that the call has been successfully made. So once that call returns, we're going to set our dirty flag and navigate our way to events, but we won't actually do anything with any data that's returned from the server. So let's save these changes and we'll go out to the browser, and we are going to create a new event. Let's open another console just so we can watch for any errors, and we'll just make that as small as possible. Go to the CreateEvent page and we'll call this ngAntarctica and that will be held on January 1, 2040, it will start at 9 a.m. The price will be 500. The address is 123 South Pole Circle at the South Pole, country is Antarctica, and we don't really have an image to use. So just use /antarctica.jpg, which is going to return a 404 which is fine. And let's save that event. And here we go. We've got our Antarctica. We didn't get any errors on the console. We did get a 404 out of that image. That's fine, that's not anything we weren't expecting. And if we click into it, we can see the data that it's got. Now before we finish up, we're going to go back into our code and we're going to look at the next method, which is the updateEvent method. Normally, when you update an object using a RESTful server, you would make a put call instead of a post call, but in our application, the only time we're updating an event is when we are adding new sessions to an event. So the server that we've created has actually got a smart endpoint. The /api/events endpoint knows that if you send up an event that actually has an ID, then you want to do an update. If you send up on event that doesn't have an ID, then it knows that you want to create that event. So in our case, we don't actually even need the updateEvent method because the saveEvent will do both things and serve both purposes. We're going to delete this, but we will talk about the format of the put method. If we did need to make a put request, an http.put request, we can change post to put and the signature is actually identical to the post request. It takes the same exact parameters, the URL, the body, and the options. We'll leave ours as a post, but now we need to go into where we call the updateEvent method, and let's save that change first, and we make that updateEvent call inside the event details component and that's right down here is where we call updateEvent. So instead of calling updateEvent, we're going to change this to be saveEvent, and since this is an observable, we need to subscribe to it, but in our case, we don't care about the return data, we're not doing anything about that. We could listen to these, subscribe, and make a callback that sets the addNode to false inside of the callback of the subscribe, but in our case, we're going to be a little bit more optimistic and just leave it there. So we just have an empty call to subscribe. So now we can save that change, and then we'll now be both creating and updating events on our server.

Using QueryString Parameters
The last method that we need to convert is our searchSessions method. Now a nice thing about this conversion is that all of this code here in the searchSessions method is going to go away because the searching itself is going to be done on the server. We just need to make the call. So let's go back up to one of our getEvents here, and we are going to paste in that code and replace the entire set of code in searchSessions. But, of course, you need to make a few changes. What's different about searchSessions is we actually use a query string, which is, thankfully, extremely easy. Let's change our URL, instead of api/events, it's going to be api/sessions/search?search equals, and then we'll append in our search term. And that's how we use a query string in the URL. We do need to change this return type. It's no longer an IEvent, it's actually an array of ISessions. We still want to catch the error, but, again, it's not an IEvent, it's an array of ISessions, and it's not getEvent, it's searchSessions. And we can go up and add in the return type, which is an observable of an ISession array. And we'll save those changes. And since we actually haven't changed the signature, we really don't need to worry about going to wherever it's called and updating that, we're still returning out the same exact thing, which is an observable of an array of ISessions. If we just check out where it's being called, which is in the nav bar, down here in searchSessions we can see that this is exactly right. We're calling searchSessions and we're subscribing to it, and setting the foundSessions equal to the return value. We are logging out the foundSessions. We probably don't need that. We could take that line of code out. We'll save that, and go back to the browser, and it's already refreshed for us, but let's go ahead and search and make sure that our search is still working, and it is. So using query strings is extremely simple in Angular. There's a practice exercise for this clip if you want to do that now.

Using DELETE
We're now finished converting the event.service to use HTTP. If we wanted, we could come in here and delete this whole EVENTS const. I won't bother with it, but you can if you want to. Let's move on to our next service to convert, which is the voter.service. We've got three methods here, deleteVoter, addVoter, and userHasVoted. Let's start off with addVoter because that's going to be a post which we're familiar with already. Let's leave that line in there, but, instead, also add in our post. We're going to need the HTTP service. So let's create a constructor, and we'll bring in a private http of type HttpClient, which we'll get from common/http. And then after the push here on the session.voters, we're going to call this.http.post. Our URL is going to be kind of long, so I'm going to create another variable just for that. I want to do a little bit of string interpolation, so I'll use the backtick. It's going to be /api/events/, and then here we need the event ID, and then I interpolate that in. I don't have it yet, but I'll grab it in a minute. Then sessions, then the session ID. Again, I'll interpolate that in. And then voters, and then the voters name. That's the URL that we need to use. And that's what we're going to post to whenever somebody actually votes for a session. So we can add that URL. We need a body, and in this case, because the URL actually has all the information in it, I'm just going to pass in an empty object as the body. Normally, we would send some data up, but just posting to this URL actually causes the session to be voted to. All the information is in the URL. The final thing we need is the options. Let's create the options. Again, that's an object with a headers property passing in an object that has a Content‑Type property, which we will set to application/json. We need to use the equal sign here, and then we can import the HttpHeaders, and we can pass in the options. We do want to catch any errors, so we'll pipe a call to catchError and import it, and we need another error handler. So let's go back to our event.service. And let's just copy the handleError method here. I'm going to put it after userHasVoted. We'll bring in the observable, and we'll call this.handleError. And the name of the method is addVoter. We're still missing our event ID, so let's add that to the signature. We're going to pass in the eventId. We'll add that first, so number. And, finally, since this addVoter method is going to get called, and we're going to pass in the data, and we don't really care what comes back, I'm just going to make this post method subscribe to itself right here. Instead, we could have returned the observable and let whoever calls it subscribe to it. That way they can get notified when the call gets finished. But I know that in our case, that's not necessary where we call it. It's actually called in a session‑list. And if we look at where it's called right here, we don't really care to be notified when it returns. So we're just going to have itself subscribe. So let's save that change and go back to the session‑list. We need to add the event ID. Now the session‑list doesn't know about the event, which is where we get the event ID. But the session‑list is used on the event‑details page. Right here in the HTML is where we use this session‑list. And this page actually does have the event, which has an ID. So if we just add a property called eventId, and we combine that to the value of the event, which we want to be nullable, and its ID property, to see that change, we have to go back into the session‑list, and we need to add a new input parameter, and that's a number. And now down here where we call addVoter, we can just pass in that eventId. But it's this.eventId. And now we are correctly calling addVoter passing in the proper eventId. Let's save that change, and that finishes up our addVoter method. Let's do deleteVoter now. DeleteVoter's actually going to be easier than addVoter. We still want to update the client side, so we're going to keep that line of code in, but we're going to notify the server that we deleted a voter. So we call this.http.delete. Again, we want the same URL as we used before. So I'm going to grab that URL, paste it in, same URL. And, of course, I want to catch any errors, so we'll add in the pipe. And, finally, I can also make this self‑subscribing because where it's called in the session‑list, which is right here, we don't really care to know when it finishes. So we'll save this change, and we need the event ID. So we're going to add that to this signature as well, and that is eventId, which is a number, and back in here where we call it, we just pass in the same this.eventId. That correctly calls deleteVoter with the correct parameters. And that's how you do a delete. Just like we did with post and put, we simply call a delete method that's on the HTTP object. In the case of delete, all we have to do is give it the URL. So let's just quickly head over to the browser, make sure we haven't broken anything. We're going to log in, and we'll go into this one and vote. We can see the vote is registering. Let's go ahead and look and see the network traffic. I'm going to unregister. And we can see here that we have made a delete call. There's our delete call to that URL that we gave it if we vote. We're also getting a post, and that is how to implement the delete method.

Integrating Authentication with the Server
We're now storing our event data and our voter data on the server. The last type of data that we need to move to the server is our user and authentication data. Up until now, when we log in, we're only logging in on the client. We want the server to also know that we've logged in. So we want to send that authentication to the server. In fact, we want to authenticate on the server. We don't even want to check the username and password on the client. We want to have the server check our username and password. Now different servers are going to deal with authentication differently. And that's beyond the scope of this course. Our server is a simple little node server that uses a library called passport to deal with authentication. But how we interact with the server is going to be fairly similar from one Angular application to the next and from one back end to the next. We're just, in the end, going to be making HTTP calls. So we are going to make those changes by going into our AuthService. And we're going to start by implementing the login method here. It's this loginUser method that we need to implement. Right now, it's just doing sort of a dummy login. No matter what you do, it just sets the current user. It's important to note that we do set the current user. The loginUser method, its main purpose is to set the current user when somebody gets logged in. So we do need to set the this.currentUser property, but we're not going to set it like this. So I'll comment out this code just to remind me that this is the functionality I need. But instead, I'm going to make an HTTP call. Of course we need the HTTP service, we need a constructor, private HTTP object of type HttpClient, and let's import that from angular/common/http. And then in our loginUser method, we will start by calling this.http.post. That's the method I need to call in order to log in. The URL is /api/login. Again, I've designed this server with this URL to log in when somebody makes a POST method to this URL. How I design the server is completely up to me. How you design your own servers are completely up to you. So the URL is likely to be entirely different. The method probably could be a POST for a login, but you might decide to do something different than a POST. That's really up to you and your interpretation of what is the best way to write a server. So don't look at these aspects, like what the URL is and what the method is, and assume that this is absolutely the best way, that every server should be written exactly like this. Again, the details of the server and how you write them are up to you. But you do need to know what the URL is on your server for the endpoint that you're working with, and you need to know the shape of the data you need to send up or the shape of the data coming back so that you can interact with them on the client. Now, in our case, we need to post up some login info. So let's create a loginInfo variable, and that's going to be an object that looks like this. It has a username property, and we'll set that equal to the username that's passed in. And notice something very important here. The property that I'm creating is username, all lowercase. I have to do it exactly that way because of the server that I'm using, which is using passport, is expecting a property that's called username, all lowercase. If I accidentally do username like this, my login is not going to work. So that matters. In the server that you write, it might be like this, it might be something else. It really depends on the server. Then I need to pass the password as well. So we'll create a password property and send in the password. And there's our loginInfo object, which is going to be the body. And of course, we need to create some options. So we'll create an options, and that's an object with the headers property. We'll create an HttpHeaders, which we will bring in from angular/common, passing in an object with a Content‑Type that has been set to application/json. So there's our options in our loginInfo. We pass in the options third. So we're now posting this data. Again remember, we need to set the current user. So when this call from the server returns, I want to set the current user equal to whatever data comes back. But I don't want to do it in the subscribe method because I don't want to subscribe here. I just want make a side effect, and I can do side effects by piping in, calling the pipe method, a special RxJS operator called tap. Tap is a way to tap into the stream and take an action when a piece of data comes through the observable. We're not manipulating the value in any way, so we don't want to do something like map. We want to use the tap method. It lets us just see the value that comes through, and we can take an action if we want based on that value, but we're not manipulating what's going through the observable stream. So let's import tap, and then I'm going to pass into that a callback function, which receives the data item that is going through the observable and will take an action based on that. And in our case, we want to set the current user, which is what this method was doing. So we'll set this.currentUser, and we're just going to take that data object. We're going to grab its user property, and we do want to cast that to an IUser. So we've now set this.currentUser, which indicates a successful login. I can delete this commented code now. Of course, we do want to handle errors because the user might have typed in an incorrect username or password. So in that case, the server is going to return an error. So let's catch errors, and let's import that. Now before we had this complex method to deal with reporting out errors. But in the case of a failed login, we don't want to report that out to the console, and instead we want to change the value in the observable stream. We want to add a false value. So I'm going to create a callback method, and I'm going to return the of function, which I'll import, and I pass in false. What I'm doing is I'm creating an observable of false, and that's what's going to happen if there is an error. So, for example, the server might return of 403 HTTP error, and that's when this method would execute and put a false value into the observable. So let's return out this observable, and I'm going to save that, and let's go into our LoginComponent. And here is where loginUser is called. So now that's an observable. So I'm going to subscribe to that observable, and that passes back some kind of response from the server. I don't really care what the response is so long as it's not the value false. So we'll pass it a callback function that receives a response. And we'll say if the response was false, then we know that our login was invalid, and we'll do something about that. Otherwise, the login was valid, and we can navigate over to events. We'll put our call to navigate right there. And if it's invalid, we need to do something. We need to show a message to the user. We don't have that functionality yet in our application. So let's create a new variable on our LoginComponent called loginInvalid. We'll default that to false, and here we'll set it too true. And now we can show something to the user if their login was invalid. So let's save that and head over to the logincomponent.html. Let's go way down here to the bottom. And after our form, let's add in a br tag and then a div that we will only display if loginInvalid is true. The class will be alert and alert‑danger. And we will give the message Invalid Login Info. Let's save that change, and we'll go over to the browser, and we'll see if this now works. So let's put in something invalid. I'm just going to type in random letters, click Login, and we do get the message Invalid Login Info. I'm going to log in with something valid, and I know that one of my usernames that is valid is John Papa. And the way that the server is implemented, it doesn't actually care what you put in for the password. You just have to have the username correct, and then it returns true. Obviously a real server wouldn't do this. It would actually check the password. But in this case, the server that we wrote doesn't care about that. So I'll click Login, and lo and behold, it logs in, and we have the Welcome John message up here at the top. And there we've implemented login on the server. To sum up, it is very important that you understand how your server operates. I know exactly how this server operates, what data I have to send to it, and what methods and URLs I have to use to get different things to work. You have to understand that about your server, and how you write your server can determine what URLs you're using, what methods you're using, and what the shape of the data going in and out is. That is all beyond the scope of this course is how you make your server. We're just focusing on how we interact with a server that has known URLs, known behavior, known data.

Persisting Authentication Status Across Page Refreshes
We've got authentication happening on the server now, but unfortunately, our client is not persisting login information across paid refreshes. If I refresh, the client thinks I'm no longer logged in, and it wants me to log in again, but the server actually does. The server is tracking that, and on the server, I'm still authenticated. So let's change our client so that it asks the server for the current authentication status whenever the user refreshes the page. Now, there's a lot of different ways to do this, and how you do it may depend somewhat on your server. We're going to go with a simple method for our application. Back in the code, what I need is a way to check the authentication status of the current user. Are they logged in, or are they not? A reasonable place to do that is in our app.component since that's sort of the core of the entire application. Let's open up the app.component, which is events‑app.component.ts, and here, we've got a simple template and no actual code. I've got this title property that isn't being used anymore. Let's delete that, and what I want to do is get a hold of the authentication status for the current user. Anything that I do with authentication should go through that AuthService. That's the logical place to put this type of code. So let's inject the AuthService here in our EventsAppComponent, we'll create a constructor, and we'll inject the AuthService, and of course, import that as well. And now that we have the AuthService, we can check the login status of the current user when the application is initialized, and we'll do that in the init event for this root app.component. So I'll add ngOnInit, and inside of here, I'm going to call this.auth, and now I need a method that checks the authentication status. I don't have one currently on my AuthService, so we're going to create a new one. Let's name this checkAuthenticationStatus, and all that will do is check the current authentication status whenever the application is initialized, which is one of the things that happens when we do a hard refresh on the browser. And let's create this method now in our AuthService, saving that change and going to the AuthService. After isAuthenticated, let's add that checkAuthenticationStatus method, and we need to make another HTTP call, so we'll call this.http. And in this case, I've got an endpoint set up that is at the URL /api/currentIdentity. And this returns no value if the user is not logged in, but if the user is logged in, then it returns their current identity as an object, and that's a get request that that endpoint is set up for. And when that method returns back, I want to check the data that gets returned back and do something if the data is of a certain type. So there's a couple of ways to do this, and this code right here doesn't need to do anything when the call returns. Instead, it's more about setting the current user here. We could just subscribe, and then with the data that comes back, we could determine what to do. Another way to do this is to actually use that same tap method we used previously so that we could taken action that is a side effect. So let's look at both of those implementations. The first one, we'll just subscribe. We get back some data in the subscribe, and we know that it's going to be null if the user is not logged in or an object, a user object, if they are. We can just call if data as an instanceof an Object, then we can set the currentUser, and we set it to that data property, but it does, of course, an IUser. Let's cast it. This is one way to handle this. Another way we can do this is basically the same thing, but using tap. So we pipe, and then called tap, and of course, we need to import tap, and we'll grab all that code we wrote into subscribe, and cut it out, and paste it up here, and close this up. These two methods for dealing with returned data function exactly the same. One benefit of doing it this way where we do it inside of the tap method instead of doing it inside of the subscribe is that later on, if we want to actually return the observable and let the consumers of the checkAuthenticationStatus actually subscribe and take an action based on when the data comes back, we can simply just delete this line and do a return, and of course, go everywhere that checkAuthenticationStatus is called and call subscribe. And that way, they get the same data, they get access to that user data that we have access to here in the tap, but these consumers can actually take an action and deal with the correct data. There isn't really a right or a wrong answer in this case. I just personally like this better because I like how this call looks a lot better than how it looks when we add the subscribe. So I'm going to save that code without the call to subscribe back into this code here, I'm going to take out the return call, and then save this call as well. As is often the case with programming, there are several ways to accomplish something, and it's oftentimes a very subjective call to determine which way it should be done. So let's now go back to the browser and refresh after we go to Events, doesn't make any sense to be on Login if we are authenticated, and notice that we're seeing that we are authenticated, so now the client is getting the authentication setting from the server

Saving User Data to the Server
Another feature of our application is to update the currentUser. We have the ability on the profile page to change the user's first and last name. This method in the auth.service, the updateCurrentUser, implements that functionality. Right now, it's only persisting to the client. We want to persist that change to the server. Again, the server itself is already set up to handle this functionality through a URL of /api/users/, then the current id of the user. And if we do a put to that URL, we will update the user that corresponds to a given id, say 3 or 4. So let's implement that. We do need to set the Content‑Type, and come up here and grab this options and just paste it in down here. Then we can call this.http.put, setting the URL, and we want to include the id of the currentUser. Let's use string interpolation here, and we'll get this.currentUser.id to interpret in the user's id. And the body that we want to send up is going to be the currentUser. We've updated the currentUser here, so the currentUser has now got the correct values. We can just send up this.currentUser. And I know that the endpoint expects an object that looks just like my currentUser looks like on the client, so I don't need to format it in any way. I could just send up the actual currentUser object. And the third parameter, of course, is the options. So we're now issuing our put, but let's look at how this is called. It's called in the profile.component, and it's called right here. And after the currentUser is updated, we call toastr.success to give the user a message that the profile has been saved. I would like this toastr message to happen only once the server returns back and says that the user has been saved. So let's go back into our auth.service, and let's return this observable. And then here in our saveProfile we can call subscribe, and we'll just do an empty return function. Or we can call the toastr.success, and that will let us only show the toastr once the user has been updated on the server. So I'll save my changes here and back to the auth.service; we'll save our changes there as well. And let's go back to the browser and we refresh. Just make sure we have the current code. Let's go over to the profile, and let's change John to Johnny and we'll save. We do get the message that the profile has been saved, but we don't know if it's persisted to the server for sure unless we refresh and see if the values are still the same after cutting a round trip from the server. Now, if you do refresh here on the profile page, you may get an error and the page won't display. That won't happen on other pages, but on this page, if the authentication check takes longer than it takes for the page to start initializing, then the page will throw some errors. That's because the page needs the authentication data before it starts its initialization phase. Of course, we can solve this with a resolver, but I'll leave that as an exercise for you to do on your own. But we now got the server persisting login to the client.

Implementing Logout
There is one more piece of functionality that doesn't even exist yet in our application, and that is giving the user the ability to log out. Right now, there's no logout functionality anywhere in the application. So let's add that. We'll start with our UI first, and it's in our profile component, we're going to add a Logout button. So we'll go to the HTML of the profile.component. And way down here at the bottom after this Cancel button, I want to add a new button for logging out. And I want to change this a little bit. I don't want this to be a default look. I want this to be a warning look. And I'd like it to be visually separate just a little bit, so I'm going to float that to the right. That'll separate it out some from the cancel and save buttons. Of course, we don't want to call cancel. Let's call logout. And finally, the text should be Logout. Save that change and go into the profile.component, and let's implement our logout function. Let's just come right after saveProfile and create logout. And the actual functionality of logging out a user should be inside of the AuthService. So we'll call this.authService.logout. But we want to know when the user has been logged out successfully on the server because then we want to redirect the user to the login page. Keeping them on the profile page doesn't make any sense at all once they've been logged out. So let's make this an observable that we can subscribe to. And once they have successfully logged out, we'll call this.router.navigate, and we will navigate to /user/login, which is the login page. Now, of course, we're getting the red squiggly underneath logout because that function doesn't exist yet in the AuthService. So let's save our change here and go to the AuthService. And we will create a logout function. Now this is going to be an HTTP request. Let's set the Content‑Type to application.json. And remember, we're subscribing to that in the profile.component, so this needs to return an observable. And in our case, I've already got an endpoint set up on the server, which is /api/logout, and you have to POST to that. So we'll call post/api/logout. And a POST need the body, but it doesn't really make any sense to have any data in a body. So we're just going to pass in an empty object and then, finally, our options to set the Content‑Type correctly. Now again, this course is not about server design, about RESTful API endpoints, or anything like that. But you are seeing some choices that we have made when we created the server. For example, to log out, you need to create a POST request to /api/logout, which logs out the current user. We could have made that a PUT or a GET, but in our case, we made it a POST. A POST requires a body, and we're just passing in an empty object. We could have passed the current user across the wire, but we really want the server to just figure out who the current user is and log that person out rather than worrying about like a user ID that we send across the wire. So these are some choices that are made that you might decide how you want this server to look, and it might look a lot different than the server that we've created. It's beyond the scope of this course. It's just important to know that when you are interacting with your server on the client, you need to know what your API endpoints look like, what methods they require, what the URLs are, and what data they accept and return. Finally, to implement logout, we have now logged out the user on the server, but we haven't like them out on the client. To log them out on the client, all we have to do is set the current user equal to the value of undefined, and now the client will know that the user is logged out. So let's save that change, and we'll go back to the browser, and we now see the Logout button. Let's click that. We've been logged out. If we go to Events and even if we refresh, note that we are logged out, and we have to log in if we want to have any logged‑in functionality. We have now finished all the functionality for our application with one small exception. This Events dropdown is actually meant to show a list of every event that exists on the server. But right now it's just hardcoded to show what event. So this is a little bit of homework you could do on your own. You could wire up this dropdown to list every event so that users have quick and easy access to a specific event. We're not going to show you how that's done. We'll leave it up to you. But with what you've learned so far in this course, you certainly have all the tools that you need in order to influence that functionality.

Summary
In this module we learned all about using observable. We did this by moving our data storage to the server, and we even integrated our authentication with the server. Server communication is a key piece of most Angular applications, so learning it is very important to becoming a competent Angular developer.

Unit Testing Your Angular Code
Introduction
In this module, we'll learn how to unit test are Angular code. We'll see how to test services and components. There's quite a few options when testing your Angular code. So in this section of the course, we're going to take a look at each kind of test and see an example of it. But we're not by any means going to exhaustively test our code. That would be well beyond the scope of this course. Let's look at our agenda. We'll start with an introduction to unit testing and some of the concepts that matter when testing JavaScript in Angular. Then we'll look at Karma, the primary tool we use to test our code. After that, we'll see how to write tests for services. Then we'll move on to components and learn how to write isolated test for components. Isolated tests just test the Component class and not its integration with the template. In the next module, we'll look at the counterpart for isolated tests, integration tests. By the time we're done, you'll have a very good understanding of the various ways to test your Angular code. One of the first things we must understand is what is a unit test? A good definition is the one shown here. A unit test is a test of a single unit of code. Of course, the definition of unit is purposely vague. A unit could be whatever you define it to be, but generally it should be as small as possible. Most developers consider unit to be a single class, although a few related classes can often be considered a unit. There are two types of tests we often talk about, unit tests and end‑to‑end tests. It's useful to see the difference between the two. Unit tests have the following attributes. They are fast. Unit tests should run in milliseconds. They involve isolated pieces of code, so only a very small portion of your entire system should be active during any single unit test; whereas, end‑to‑end tests will tend to be slow, usually several orders of magnitude slower than a unit test. An end‑to‑end test will exercise the entire system, so you will need to have your complete system up and running in order to run your end‑to‑end tests. Due to the speed factor, we generally write many unit tests and few end‑to‑end tests. Now in this course, we are not going to go through how to write end‑to‑end tests for our application because for the most part, writing end‑to‑end tests doesn't depend at all on the tools, libraries, or framework that you're using. And there are several great Pluralsight courses already published that discuss how to write end‑to‑end tests. So if you want to learn how to do that, you can check out one of those courses. Let's cover some of the attributes of a good unit test. First, a good unit test should be fast. If it takes a long time to complete a unit test, you won't run it very often, and it will lose its value. A unit test should be cheap to write, meaning even though it might take a while to set up your first unit test for a given unit of code, additional unit tests about that same piece of code should be fairly easy to write. Unit tests should cover a single state change, meaning you've put your system in a given state, you make a change to that state, and then you test that the result was exactly what you expected. If you're making multiple state changes within a single unit test, you're probably doing something wrong. A unit test should assert one thing. That doesn't mean that you only have one line of code for your assertions, but that you're just checking that one specific thing happened. A good unit test doesn't cross process boundaries, so it shouldn't call out to a database or out to an HTTP server or anything like that. Finally, a good unit tests should be reliable. This means that a unit test should never fail due to external conditions, such as timing with other tests, race conditions, or anything like that. It should always pass or fail based on if the code itself is correct or incorrect. When we talk about the structure of a test, there are two terms that we should know. The first is a AAA. This stands for arrange, act, assert. The first part, arrange, is where you create the initial state of the unit test. This could be as simple as constructing a class or as complex as creating starting data and setting 10 different state flags. Then comes the second A, act. This is the part of the test where you change something. Perhaps you call a method on your class. Perhaps you change a variable. In any case, you act on the system and cause the state to change. Finally, comes the last A, assert. In this section of the test, you check that the expected result happens given the initial state and the change in state. The second term is damp. Although some people have created an acronym out of this word, it is more useful to simply consider the meaning of the word damp. You may have heard of the term dry in programming. If you haven't, dry is an acronym which stands for don't repeat yourself. This is the principle that you should never duplicate code. Any code duplication is a problem and should be fixed. Although that is true for the code we write, when it comes to tests, we don't have to be quite so draconian. In fact, we say that our tests don't have to be dry. They can be a little damp. Not wet, we don't want lots of duplication, but a little bit is okay. The reason for this is that a good test should tell a story. We'll see how this affects the amount of duplicate code that we have later on. First, let's look at some code to understand the AAA structure. We're going to write a simple test to test what happens when we add a friend to a user object. So first, we do our arrangement. Here we create a new user and initialize the friends list to an array with a single item, Ralph. Then comes the action. We call the addFriend method, passing in the name John. Finally, the assertions. We check to see that the expected result happened. In this case. The friends list should have two items in it. And that's all there is to it. Notice that the various pieces of the test are easy to identify, and they come in a specific order. This should be true in all your unit tests. Now let's talk about the second term, damp. In this case, we have written a very similar test to the previous one. In fact, the first two lines of code are completely identical to the last test. So we might think hey, let's move those two lines of code into a function and then call the function in our test. This is what we would do with normal code, right? Well, there's a problem with that. In this test, we are adding a new friend, but it's the same friend that Sally already has. So the result is that we still should only have one friend in the list. Without knowing the initial state, we wouldn't understand why we got the specific end state. It's important to know that Ralph was the one friend that was already in the list so that when we try to add him again, nothing changes. This is the story of the test. It makes it readable. It has three parts, the initial state or arrange part, then the state change or act, then the final state or the assert part. In some cases, we can remove some of our duplicate code. For example, the construction of the user object might be moved to a subprocedure, but parts of the test that are important to the story should stay in the test. We'll see more of this later. Another concept that you will need to know is mocking. Mocking is the mechanism of replacing a dependency with a fake piece of code that does less than the original code did in a meaningful way. We do this for a few reasons, speed, ease of testing, or to just avoid code that we don't want to test. Let's assume that we have a test for an order object. This is the code that we're testing. Furthermore, that order object uses an Http object to save changes to the server. Now, of course, in a unit test, we don't actually want to make any HTTP calls. So we need a mock Http object such that when the order object calls the POST method on the Http object, it simply returns immediately. The test can still be run, but we won't be using the real Http object. In this case, we want to mock the Http object. So we replace the Http object with a MockHttp object that has dummy methods just for our test only. This is mocking. Jasmine is the unit testing framework that we will use with Angular. There are several testing frameworks out there, but Jasmine is one of the most popular ones. It's very straightforward. It uses four main functions, the describe function, which is the containing function for a suite of tests. Then there's the beforeEach function, which gives us a place for common setup code. The main function we deal with is the it function. Each one of those creates a separate unit test. And finally is the expect function, which is how we assert that the test passed. In our expect functions, we use what's called matchers. Matchers are what allow us to express what we are expecting. For example, we may expect that a certain value is 3. In that case, we can use the toBe matcher where we specify that we expect the value to be 3. Jasmine includes a lot more matters, such of the toContain and toBeDefined matchers, and we can even at our own. Karma is a command line test runner. It's the tool that actually causes the test to be executed. It's complex in execution, but simple in concept. Karma launches the browser and then causes that browser to run your tests. Karma can render test in multiple browsers based on how you configure it. And when finished, it will report out the results of the test run to you. In this module, we'll be learning about two ways to test your components, isolated unit tests and integrated unit tests. Neither one is inherently superior to the other, and each has benefits and trade‑offs. First, let's look at isolated tests. An isolated test tests the class only. So if you're testing a component, it is not testing the components template, only the code. In an isolated test, you call the constructor of your class or service directly. Isolated tests are simple in comparison to integrated tests. They generally require less code and are quicker to write. Isolated tests are the preferred method for testing services and pipes. Since these parts don't interact with a template, you will usually use an isolated test for them. Isolated tests are also appropriate for components and directives if your priority is to just test the code and not worry about the interaction with the template. By comparison, integrated tests are quite different. They test both the class and the template if you're using a component or directive. In an integrated test, your component or directive or service is actually constructed by the framework, not by you. Integrated tests are more complex and require quite a bit more setup code to get them running. Integrated tests are mostly used for components and directives and not quite so much for services and pipes, although they are occasionally used to test services for various reasons. Finally, there are two types of isolated tests, deep and shallow. Deep tests will test multiple components, like a parent and child component that work together, where a shallow test will only test a single component. We've gone over a lot of concepts in this introduction section, so let's get to the code and actually see how all this works.

Installing Karma
We're going to learn how to run tests in our Angular applications. Before we actually do run a test, though, we're going to take a quick look at our package.json file so that we can see how we actually run tests. Here in the package.json file in this scripts section, we've got this test script that is created by default by the CLI. Notice that the script it actually executes is ng test. So this is npm calling the CLI. This is how we run our unit tests. So if we go out to our command line and run npm test, that is the same thing as if we were to run ng test. Of course, this only works if we have the CLI installed globally. But normally, running npm test is a bit more standard because that way we can adjust the script. Instead of just running ng test, we might do more than just that. And what we type in on the command line doesn't change. It's always npm test. So let's type that in and go ahead and execute it. And that is going to call Karma to actually run all of the unit tests that it finds inside of our source code. So here the tests have run, and we can see this message shows that we have executed 0 out of 0 tests. And it is saying there's an error, but that's because there are no tests to run. The other thing that Karma has done at this point using the default configuration is it has opened up a Chrome window. Let's go ahead and look at the output of that window. This is what the Chrome window looks like. It's using Jasmine, and it gives us this nice little UI that says we've got 0 specs total and 0 failures. So in running tests, we can look at both the command line and at the browser window that's opened up. Normally, we just watch the command line. That tends to give us a little bit better information, although, as you can see, it's a little bit chatty and can put a lot of unnecessary information into the window. But occasionally this becomes useful to us. Now let's actually create for ourselves a test so that we can see what it looks like when there is a test that's running. I'm going to go back to the source code, and we're going to, in the root of our app directory, I'm going to create a new file called test.spec.ts. This file name with the .spec.ts, that is the type of file that Karma will look for. It will run any spec.ts file that it finds inside of our source code directories. So let's write ourselves a little bit of a Jasmine test here. We're going to start with a describe, and we'll give it a description and then a callback function. And within that, we're going to call the it function. And that takes in a description as well, and I'm going to type in should be true. What I'm saying is that I expect that some value should be true. And a callback function again, and then within here, I'm going to expect that true is using the toBe function true. So notice the name of the describe as first tests. Then we have the it function, then should be true. When writing tests, it's good to use very descriptive text inside of these first parameters, so that when we string them together‑‑‑for example, in the first tests, it should be true obviously doesn't need perfect grammar, but it should be a kind of description that tells us what the test is about. And the section of tests that we're in, in this case the describe first tests, it tells us where in our application we're dealing with tests. And then the it block tells us what should be going on. It's always common to start the description within the it block with the word should. So let's save that test. We're going to go back out to our Karma. And notice that it still said 00 and then it finally picked up the test. And now it says 1 of 1 SUCCESS. So Karma is watching the files. It's looking for new files. When it sees new test files, it picks them up and runs them. If you do have any problems with Karma watching when you create new test files, sometimes you have to stop and restart Karma. Just hitting Ctrl+C and then rerunning npm test will let you relaunch Karma in case it doesn't pick up your new test files. Let's go back out to that Karma browser window, and we can see that we have got 1 spec with 0 failures, meaning that there was 1 test and we didn't have any failures. The first tests, should be true, is passing. Let's go back into our code and make this test actually fail. We're going to say false here. We save our change. Go back out to the command line, and now we're getting an error. You can see here it's printing out the entire stack trace, which is a little bit chatty, but right here first tests should be true FAILED. And then it says, Expected to to be false. So we expected a true value, but instead we got a false value, which is exactly what our test is showing. We are expecting a true, but we actually passed in a false. And if we go down to the bottom, we can see that it executed 1 of 1, but 1 failed. And let's look at the browser window, and here we get a little bit more readable and usable UI, where it says we had 1 spec total but 1 failure, and then it shows us the failing test and it's highlighting it in red, and it prints out our stack trace for us. This is really good feedback and helps us track down what is our problem in our tests and deal with it. Now let's go back and fix that test. Let's write one more test. It'll be very similar to this one, should be false instead of true. And this will let us see what it's like when we have more than one test. We're going to expect(false).toBe(false). Save that change, back to the command line. And now we're getting Executed 2 of 2 SUCCESS. Notice this is printing this out twice. This is a very common type of thing, which is why oftentimes the command line is so chatty that it's a little bit difficult to pick out the actual important information in this window. The browser, oftentimes, is a little bit more concise and readable, but sometimes the command line gives us context that the browser doesn't actually show. And here our browser's saying we have 2 specs with 0 failures, and it lists the describe. And then indented underneath it is the tests, and the ones that are passing are showing green. And that's how we run our unit tests using the CLI and Karma.

Unit Testing Services
We're going to write some real tests for our code. So we'll remove this test.spec.ts file and right‑click and select Delete. We're going to add our first real test. We're going to be testing a service, and the service that I want to test is the voter service. That test is here under events, under event‑details. Here's that voter service. So I want to create a new file right next to it called voter.service.spec.ts. Now just like any regular file that we'd use, we're going to start off by importing some stuff. So first I need to import the VoterService itself. Next. I want to import the ISession from the event model. We're going to use that in our test. And finally, I want to import Observable, and that's from rxjs. Then, of course, we start with our outer describe, and I'm writing tests for my VoterService, so I'll just put in the name VoterService in my describe. Now in order to test VoterService, I need to actually create an instance of it. This being an isolated test, we create the instances ourself. Angular isn't creating instances of services for us or components. We're doing that ourselves. And of course, when you want to create a new instance of a class, you do that with code something like this. And it takes in one parameter, which is the HTTP service. So we're going to need to provide it a mock HTTP service. Of course, we don't want to give it a real one because we don't want it making HTTP calls during unit tests. So we're going to need to provide a mock HTTP service. We haven't created that yet. We'll do that just a second. But before we do, notice that we're creating our service here. When we write our tests, let's say we wrote three or four tests, one here, one here, and finally one here. Each of these three tests would use the same instance of the VoterService. So if we had any state issues, maybe we changed some property on the service in our first test. But in the second test, it would start off with the mutated state. We probably don't want that. What we want is a fresh copy of our VoterService. That's why we use beforeEach. When we initialize anything, we do it inside of a beforeEach function. That way we get a fresh copy. Now, of course, we can't even reference this variable because we've defined it inside the beforeEach. So we need to define it outside the beforeEach. And I want to give it a type, of course, of VoterService. And finally, I also need my mockHttp, so I'll define that here. I'm not going to give that a type. Since this is a mock object, it's going to have a different interface than its underlying class. So therefore, trying to give it a type can be problematic. Now we got to create that mockHttp object. I'm going to do that in my beforeEach, and I'm going to use Jasmine here. I'm going to set that equal to jasmine.createSpyObject. And first I give it a name, and then I give it a list of its methods. These are the methods that I want Jasmine's createSpy function to create on this object for me. If I go back into the code that we're actually testing VoterService and look at the HTTP object, we can see that it occurs twice right here where we call delete and right here where we call post. That's the only time that HTTP occurs. So those the only two methods I would need, so I add both of them, delete and post. And that way, this spy object is now going to have a delete method and a post method. They'll be empty methods that don't do anything unless I define their functionality, but they will exist. So when my VoterService calls them, it won't error out. Next, I'm going to create the describe for the function that I'm going to test. And we're just going to test the deleteVoter function. Put in that describe of the name of the method. And now within here, I can write my tests. So my first test is going to test that the deleteVoter function actually removes the voter from list of voters. If we go back to the code, we can see that the first thing that it does is filter out the voter from the list of voters. We want to test that functionality. So that's what our test is going to do. I'm going to write a little sentence here that it should remove the voter from the list of voters. First, we're going to need a session with a list of voters in it. Sessions have a lot of properties, but the only property I care about really is the voters property, which is an array of strings. So I'll add in two, Joe and John. Going back and looking at our code, we can see that it filters out the voter based on the voter name that's given. But it also requires an eventId and a session. Notice that the session itself has two properties that are used, voters here, but also the id properties used here. So we're going to go back. We need to give this session an id property. We'll just give it an id of 6. So our session's created. And that way when we call deleteVoter, we could pass an eventId, we can pass in that session that we created, and we can pass in the voter name. Now I'm getting an error on the session, and that's because the type doesn't match. So I'm just going to forcefully cast this to ISession. That is why I imported ISession up here is so that I could forcefully cast this session, even though it doesn't have all the properties that an ISession should have. And now that I've got my call, I can write my expect statements, but I need to check my code and make sure that not only will this line of code actually execute in my test, but will this line of code execute? What's going on here is when we call delete, passing in this URL, then it chains on this catch call and the subscribe call. Therefore, what was returned from delete needs to be an observable. If it's not, then this line of code is going to error out on me. We can see that if we just save this test, we are getting the error Cannot read property pipe of undefined. Again, in our code, the delete method should be returning an observable of some kind. That's what the http delete call does. But in our test, our mockHttp delete call is just going to be returning an undefined that's the default return value. Fortunately, it's easy to tell these mock objects to return into for value. We can do that by calling mockHttp.delete, and then we can call .and.returnValue. Well that tells the mock object that whenever this delete method is called, this is the value that should be returned. We want an observable. Any observable will do. Let's just create an observable of false. We'll use the of function, and we'll import that. And we'll just return in observable of the value false. And now, if we save our changes and go back to our tests, the test is now passing. But the test is not actually checking that anything is happening. It's just executing code. And since there are no failures, it's reporting that it is successful. But we really need to actually test something. We'll need expectations for that. So first, we will check that the voters array has the right number of elements. And after the delete, that should be one. We started with two, we deleted one, so we expect there to be one afterwards. And let's also double check that the one that's there is the one that we expect to be remaining. So we'll look at the voters array. We'll look at that first element, that index 0. And we'll expect that it is the word john, and we'll save and go back and look at the resulting tests. And it does indeed say that we have executed 1 of 1, and our tests are still successful, even though we are now actually running some expectations. Of course, if we'd gotten this wrong, like we'd look for joe instead of john, but we deleted joe, then our tests are going to tell us that we are failing, and that's the message that we get. So let's fix this and get our tests back to a passing state, and we have finished that unit test. There are practice exercises for this clip if you want to do those right now.

Testing Mock Calls
With our first test up and running, we can now write our second test. This test is going to test the same function, called in the same exact way, but it's going to test the other thing that that function does. In our VoterService, our deleteVoter method actually does two things. First, it removes the given voter from the list of voters for that session, then it calls http.delete. Our other test covers this line of code to make sure that it's working correctly, but we want to know that this piece of functionality is correct. We want to know that we're calling delete correctly. To know if we're calling delete correctly, really what we need to know is that the right URL is being called. So the eventId should be correct, the voterName should be correct, the sessionId should be correct, and it should all be put together in this string in this format. And luckily, since we got Jasmine spies, we can actually test exactly that. Going back to our code, I'm going to say that it should call http.delete with the right URL. So I'm going to copy and paste this code here, but of course, I'm not going to repeat the same expectations. Now, you may be wondering why we're repeating this code, duplicating this code here and here. It's the exact same code. Should we maybe move this up to a before each for the delete voter, or even to a common before each? This is a little bit of a subjective call, but one of the things that a test should do is tell the story of what the test is doing. And part of that is any necessary setup that applies specifically to this test. So in our case, seeing what the session is that we pass in and how that mockHttp returns an observable, that could be useful. So for me, it's okay that these two lines of code are duplicated in these two tests. It makes our test, instead of being DRY, that acronym DRY, Don't Repeat Yourself, we do have a little bit of duplicated code, but tests are often damp, so they're not perfectly dry. They can have a little bit of duplication. And I'm okay with this duplication. So after calling this, I can make my expectation, and I want to expect that mockHttp, its delete method, has been called with a specific parameter. So I can use the toHaveBeenCalledWith method, and I want to check that it was called with a string that matches exactly what it should be. So, in this case, the string is going back to our original code. I can copy this and paste it in and then replace the eventId with the eventId that was passed in, which is that 3 right here. The session id is 6, which is given right here, and finally, the voterName is Joe, which is this parameter here. So I can save this code and go back to our Karma command line, and now we have two tests executing successfully, so our delete function is getting called correctly. Now, what if we have multiple parameters, as in this case down here on this post, especially when we have parameters that are complex like this request options object? Well, we could handle those, too. Let's write a test for the addVoter. I'm going to create a new describe, and I'm not going to test that the add functionality works this push I'm just going to check that the post right here, I'm going to check that that's called correctly. So I'm going to copy and paste this test, except we want to check that it calls POST with the right URL. And in this case, I'd want to start out with not having two voters, just one, and we're going to add a new one, and we call addVoter. The signature is completely identical. We have an eventId, we have a session, and then we have the new voter. And now we want to check that mockHttp.post was called with the parameters that we expect. So again, the URL is exactly the same. Go back over to here and see this URL is formatted exactly the same as the delete voter, api/events, the eventId, sessions, session.id, api/events, eventId, sessions, session.id. Then, voters and voterName, matching up here, but the POST method has the URL, then an empty object. So that's easy, I can just add another parameter, an empty object. And then finally, it also should be called with this options argument. Now, there's a problem. This options argument is created inside of the code here. It creates a new request options. I don't have a handle of that same exact object to make sure that that was the object that was given and passed in as the third parameter. But I can sort of punt on this. Instead of checking that this exact argument was exactly what was created up here, I could just assume that this is correct. This is not a very complex line of code, creating the request options. So I just want to check that at least something was passed in some kind of object. And I can do that by using a helper method on Jasmine, and I call any, and then I pass in the type that I want, and I want it to be any object. And this will just check that that third parameter was an object of some kind, not a specific object, just any object. So let's save those changes and go back to our Karma command line, and we see that we're getting an error. The reason is we told mockHttp's delete to return an observable, but now we want POST to return that observable. Save those changes, and back to our command line. Tests are re‑running, and everything is correct. And that's how you can check that a mock method was called the way you expected. There's a practice exercise for this clip, so now would be a good time to do that.

Testing Components with Isolated Tests
We just saw how to test services, and now we're going to learn how to test components. We're going to start off with the simplest way to test a component, which is an isolated test just like our service tests. In an isolated test, we simply construct the class for the component, like we did with a service, inject mock services that it requires, and then exercise the Components class. This works just great for testing functionality that the component has, although it does miss out on testing the interaction between the component and its template. What we're going to do is test our ngOnChanges function. There's a lot in this component that we could test. We're just going to stick with the simple stuff. Now just a quick note. If you do have a filter parameter on this ngOnChanges method, go ahead and remove it. It's not necessary. It's not used at all in the method, so just go ahead and remove it. This ngOnChanges does quite a bit. It filter sessions, and it sorts sessions. So there's a couple of good pieces of functionality that we can test, and it will be a good place for us to start and see how to do isolated tests with components. So, of course, I've got to create my spec file, and I'll name that session‑list.component.spec.ts. And, as always, we need to start with our imports, and we'll import our session‑list component itself. And I'm going to need that ISession interface again from the event model. Then we'll move onto our outer describe, and we're testing the SessionListComponent. Just like the service that we tested before, we've got to construct our component ourselves, so we'll creative variable for that. And the SessionListComponent requires two services, the AuthService and the voterService. So let's define some mock services for both of those. And finally, our beforeEach where we'll create the component, and we've got to pass in the mockAuthService and the mockVoterService. And now we can move on to the actual tests. We're testing the ngOnChanges event, so there's that describe. And our first test will be to test that the filter works correctly. The setup we'll need to do is to initialize a few variables in our component. Going back to our component, we can see that it's got four different input parameters, sessions, filterBy, sortBy, and eventId. So let's set those four variables. Now I'm going to need an array of sessions here. And since we have to filter and sort, I'm going to need both the name and the level. Filtering is done by level. Sorting is done by name if we use just the name sort. So we'll add in those two properties for each session, name and a level. And we don't want just one session in our list, we want a few, so I'm going to copy and paste this. We'll change the level on one of them and change the names so that they're each a unique name. Now we're still getting an error, and this is because the type mismatch. So we just need to cast this to an array of ISession. Okay, and now we need to set the filterBy input property, and we'll filter to intermediate. So in our test, we're going to check that we've only got these two sessions after the filtering is done and not this session. We do need to set the sortBy input property. Otherwise, the algorithm will throw an error and then the eventId. This isn't actually used in the test. Nowhere in the ngOnChanges is the eventId used, but we'll set it just to be complete. And now we can take the action that this test needs to take, which is to call the onChanges function. When this components actually running in production, the onChanges event happens automatically, but here in the test, we've got to call it ourself. And now we can set our expectations. So what should happen given these sessions and this filter here to the component? Well, the filterSessions ultimately sets the visibleSessions property. The sessions themselves remains unchanged. It's the visibleSessions that gets changed. So I'll go back and set an expectation that our visibleSessions length is 2. And, of course, we could write more expectations to make sure that the beginner session isn't one of the two sessions. We won't do that. This expectation will be good enough. So we'll save our changes and go back to our command line, and all four of our tests are executing successfully. So there's our first isolated component test. While we're at it, let's write a test to check that sorting works correctly. We're just going to copy and paste this test, change that to sort, and I want to set the filter to all so that nothing gets filtered out. We are sorting by name. And so what should we check in our expect statement down here to make sure that the sort is happening correctly? Well, these three names, session 1, session 2, and session 3 are very easy to put in alphabetical order. So let's mess up the order in the initial version and then check that the order is correct in the resulting version. So let's change session 3 to be the second one and session 2 to be the last one, and now we can set an expectation that our component.visibleSessions the last element, and we'll ask for its name. It should be session 3. If these are sorted correctly, then the third element, which is the element at index 2 should be session 3 and not session 2, which is what is in the sessions array. So let's save that and go back to our command line, and we are getting five tests succeeding. So there we have a couple of simple, isolated component tests. These are great for checking functionality like this. But, of course, there is some functionality that they can't test that we need integrated tests for, and we'll see that in the next section.

Summary
In this section, we learned how to use Karma and Jasmine to test our Angular code. We saw how to test services, and how to mock dependencies, and then we learned about isolated component tests. In the next module, we'll build on this and learn how to write integrated tests for our components, so that we can test their templates, as well as their code.

Testing Angular Components with Integrated Tests
Introduction
In this module, we will learn how to go beyond isolated unit tests and instead test both our component and its associated template using integrated tests. Integrated component tests are the only thing we're going to cover, but there's plenty to learn here. We'll start by looking at how to set up our integrated tests. It takes quite a bit of work to get our system set up to run these kinds of tests. After that, we'll see how to actually test a component and it's template. Then we'll look more into mocking services. And then we'll take a look at the difference between deep integrated tests and shallow integrated tests. In this section, as we cover integrated tests, you're going to see that they are much more complex to set up than isolated tests. There's good reason for that. When doing an integrated component test, we're not just testing the class of our component. We're testing it in a very close approximation of running in our live application in the browser. This is accomplished with a very important utility called the TestBed. Unlike isolated tests where we construct our component ourselves, in an integrated test, the Angular framework will construct our component for us using the TestBed. It will also integrate the template for the component and wire everything up. The other thing it does is construct a module for us to be used in the test run. This is required for the component to operate in a realistic environment. You'll see all this in the code that we write in this module. As we do this and you see how complex this can get, you may wonder, why do this at all? Aren't isolated tests good enough? Well, in many cases, they can be. Testing simple bindings can often not be worth the effort. But there's certainly cases where we get templates that are so complex that testing them with a unit test is very valuable. Also, remember that the test will fix the functionality in place. That way, as we fix bugs or add new functionality, we can be sure that we don't accidentally break any of our template bindings. This is both good and bad since it may make it more difficult to change our code, but can also make it more difficult to introduce bugs. You'll have to decide for yourself how valuable this is for your project and indeed for each component

Setting up for Integrated Tests
We've seen so far how to write isolated tests for a component. Now we're going to learn how to write integrated tests for a component. Integrated tests are a lot more complex than isolated tests and require a lot more setup. And for a given component, you may find that you need to write one type of test or another, and you can certainly write both different kind of tests within the same test file. But in order to keep things clear and separate, I'm going to rename our existing component tests for the session‑list.component and call it session‑list.component.isolated.spec.ts, and then create a new file for a session‑list.component.integrated.spec.ts. And I'm only doing this for the purposes of this demonstration. In general, I wouldn't recommend this method. Now let's start off by looking at what we're going to test in our session lists. Let's open up the session‑list, the HTML, and this is really the power of an integrated test, is the ability to test the template and test that template in the context of the component, working with the component. So if we look at our template, what's the simplest thing we might want to test? Well, right down here on line 10. We have the name of the session, and just being able to display the name of the session correctly is a good first test to check that we can test our template effectively. So I'm going to start with a describe SessionListComponent, and within that SessionListComponent, I want to check that our initial display is okay, so it'll be our first section. I'm going to put an inner describe in there. And within here, we're going to write our first test, but before we even get there, we've got to do the setup for the component to work in integrated mode. In isolated tests we just created an instance of the component ourselves. We did that manually. In integrated mode we're actually going to have Angular creating and running sort of a little mini version of Angular and running our component inside of this smaller, tighter version of the Angular framework itself. And we have to do that ourselves. We do that in our beforeEach function. So we're going to create a beforeEach, and inside of here, I'm going to create some setup code. Now, if you ever use the CLI to create a new component, it creates a template, sort of a blank, empty test that already has some code in it. And if you look at that versus what I'm going to write, you'll see a lot of similarities, but a little bit of differences. Here inside of the beforeEach, the first thing I want to do is, I want to look at my SessionListComponent, and let's look and see what services it uses. On line 17 we see the constructor. It uses an AuthService and a VoterService, so I know that I'm going to need a mockAuthService and a mockVoterService. So let's just start by creating our variables. Going to create a mockAuthService and mockVoterService, and now I need to create the pieces that are going to represent the component itself that Angular's going to create for us. When Angular creates a component using an integrated test, it creates what's called a ComponentFixture. So I'm going to create a variable called fixture, and the fixture is sort of a wrapper around the actual component instance. And the type of a fixture that Angular that creates for us, this fixture variable it's going to create is actually a type of ComponentFixture, and that comes, you can see, from @angular/core/testing up there at the top, and that takes a type parameter, which is the component itself, so that's a SessionListComponent. And in addition to the fixture, we usually want a handle to the component as well, so I'm going to create a component variable, and that's going to be of type SessionListComponent, the component we're testing. And then Angular also lets us work with the template, and it gives us two ways to work with the template. It gives us a native element way, so I'm going to create an element variable, and that is of type HTMLElement, which doesn't have to be imported because that's a global type. And it also gives us a dubug element, and that is of type DubugElement, which also comes from angular/core. And those are the various variables that I'm going to need, handles I'm going to need to the various pieces that Angular's is going to create for us. And now we can actually begin doing something. So when we want Angular to create our component for us, we use what's called the TestBed. And that TestBed comes from that same @angular/core/testing. You can see it imported up at the top. And in the TestBed we call the Method configureTestingModule. and this method actually creates a testing module, so this is an Angular module. It creates one specifically for this test, and this is a mini module. If you think of the app module, this is a tiny version of that that is only going to contain the components that we're trying to test. So that's a method call. It takes in an object that is the same specification that we would put into our app module. So if we look at our app module and the pieces that it has, a testing module that we configure can have the same pieces. For example, it could have imports and providers and such. We're testing a component so we're going to need a declaration section, and that's an array just like it is when we create the app module, and so we'll put it in our SessionListComponent. And we also need a providers because the SessionListComponent uses two different services, and so we need to specify those two services. And we've learned how to do this, how to create services that aren't exactly what Angular would normally provide because we don't want the real VoterService or the real AuthService; we want our own mock versions of those. So we're going to use that longhand provide. And for the AuthService, we're going to say use value, and that will be the mockAuthService. And we need the same thing for the VoterService. So come down here, change this to mockVoterService and change this to VoterService there, and import that as well. So now we've configured the testing module. Once we configure the testing module, we can go ahead and have Angular create our component for us. So I'm going to scroll down a bit here, and on the next line after the configureTestingModule, I'm going to ask Angular to create the component. And what it gives back, as I mentioned before, is a fixture. So I'm going to take that fixture variable and assign it equal to TestBed.create component and pass in my type, my component type. And so, the configureTestingModule creates a module that can create the session list, and then when I call createComponent, it actually creates a SessionListComponent. It's a very stateful way of doing things, and that's just how the TestBed works. Now that we have the fixture, we can get a handle to the component by saying fixture.componentInstance, and that's going to be our component. And we can get a handle to the dubug element I was telling you about that gives us a way to work with the template, and we do that by calling fixture.dubugElement. And then, finally, the native element, the HTML element, is fixture.nativeElement. And that gives us handles to all the different pieces that we need in order to work with a component and actually write a test around it. In the next part, we're going to actually begin writing our test.

Testing Components with Deep Integrated Tests
With this setup done, whenever this test fixture executes and calls the beforeEach, it's actually going to create a little testing module and create our SessionListComponent for us. So this would actually execute something right now, but we haven't written a test yet. So let's go down into our describe, and we're going to write our first test. And we're going to call this first test should have the correct title, since that was the simplest thing we determined we could do, testing the display. And again, we're just going to be looking inside of the template. We're going to be looking for that session.name here on line 10 that's inside the div that has an attribute of well‑title. Now in order to write the test, we're going to need to make sure that our component is acting like a real component. And in the case of the SessionListComponent, it has a lot of inputs, you can see here between lines 11 and 14, that are pieces of data that it needs. It needs the list of sessions, it needs to know how it's filtered, how it's sorted, it needs to know what its eventId is, and it also needs the visibleSessions. And the visibleSessions aren't actually set up until the ngOnChanges lifecycle event is fired there on line 19. So we've got a lot of setup here in order to get this component to act like a real component. We have to set all these pieces of data. They're normally set by the parent component; we have to set these manually. So let's start by setting the sessions. Look on line 28. We have a handle to our component. So if I call component. and get my IntelliSense, you can see right here is sessions. So we have the sessions property, and we can just set it directly, very similar to how we did in an isolated test. So let's take that sessions property, and we're going to set it equal to an array. And we're only going to put one item in the array because even though our SessionListComponent renders a list of sessions, we just want to check that it's going to be able to render out one of them correctly. So we're going to put one item into our list of sessions. But that item inside the list really needs to be very complete, so there's a lot of properties that a session has so I'm just going to fill those in. It needs a name, and it needs an id. I'm give it an id of 3, a presenter, it needs a duration, which is a number. It needs a level, it needs an abstract, which I'll just put in the text abstract, and then finally, it needs a list of voters, so I'll put it on a new line here, and we're going to give it two voters, john and bob. And finally, we have a correct‑looking session that our SessionListComponent can render out inside of this list. Next, we still have to set the filterBy, so we're going to set that just to all, so there's no filtering going on. If we go back to our component reference, again, what we need to put in here filterBy, sortBy, eventId, so component.sortBy, we'll set its name. Again, this won't really matter since we're only rendering out one at the moment, and component.eventId. Set that equal to 4. And now we've got almost all the pieces of the component set except for the visibleSessions. That's what's actually getting rendered out. If we go to the template, we can see up here on line 1, it's let session of visibleSessions, and initially the visibleSessions is empty. That's how the component starts off, is the visibleSessions is an empty list. It's when the onChange event fires that we actually set up the sessions. Unfortunately, because we're manually setting these properties, we're not using a parent component that's injecting the properties through the input property. The onChanges lifecycle event isn't going to fire for us. Therefore, in our tests we've actually got to call this manually. So let's just scroll down a little bit, and we're going to call component.ngOnChanges. So we have to call that lifecycle event or method manually ourselves. Once we've done that, we have all the data, but the template hasn't been updated. The template gets updated, and its values are updated according to the bindings that are set in the template. So, for example, what we're really interested in, again, is that session.name there on line 10. That's a binding, and bindings aren't updated until change detection runs. But thankfully, we can call change detection ourselves manually in a test. So that's on the fixture itself. And I'm going to call detectChanges, and that will actually run the change detection, fire off, and update all the bindings in the template. As we write one of these integrated tests, we have the arrange section, the act section, and the assert section. In this case, the act is really kind of that change detection, because that's what updates the bindings. And so that's why I gave it a little bit of a space in between that and where we kind of set up the component. So on lines 37 to 44 we arranged our component or our test, and on line 46 we took our action, which was to run change detection, which of course, also updates the bindings. So let's save this, and then we'll head over to the Karma window and see what we're getting for a result. All right, we're getting an error, and it's saying that the pipe 'duration' could not be found. If we go over to our template and look, we're going to see that there's a duration pipe here on line 15, but built into Angular is not a duration pipe. This a custom pipe. So in order for this template to even work, we need the duration pipe. Well, how do we get the duration pipe working in our application? We include it in the app module. So we're going to do this in our testing module. We're going to have to come to the testing module and add the DurationPipe. So I'll do that and let Visual Studio Code auto‑import that for me, save that change and go back to Karma, and now we're getting an entirely different error. Now we're getting isAuthenticated property doesn't exist on some undefined object. So yet another error that we've got to figure out what's not set up correctly with our test. So in the next section, we're going to walk through how to figure out issues with our tests and pieces that are missing and how to work through that until the test executes correctly with these more complex integrated tests.

Creating Mock Services
We're going to look at how to work through the problems that we have in a test until we get the test working. And this is a really important skill because a lot of times with these integrated tests, you're going to think you have them set up right, you're going to go to execute the test, you're going to get some problem that's going to tell you, hey, this isn't done right and that isn't done right. So this is a really important part of dealing with integrated tests. So the first thing we've got to do here is diagnose what's going wrong. Cannot read property 'isAuthenticated' of undefined, so something's undefined that has an authenticated property or method. And if we go back to our code and look around, we can see probably in our session‑list here isAuthenticated. And yep, here on line 3, auth.isAuthenticated. So our AuthService needs to have an isAuthenticated method, but it's actually telling us that it's even undefined, which probably means that we didn't create our mock services correctly. And lo and behold, when we look at our code we can see that on lines 11 and 12 we create and define the variables, but never in the beforeEach do we initialize them to an empty value. So we're going to need to do that inside of our beforeEach. Very first we want to do is create mockAuthService and just set it equal to an empty object. And we're just going to do that for now with the AuthService and the VoterService. And again, it's important to note here there's a reason why we do this in the beforeEach and not do the same work here outside of the beforeEach. This makes sure that those are initialized to their fresh, pristine values before each test. Every piece of initialization should be in the beforeEach, never outside of the beforeEach when we define our variables. With those two set to be an object, we can save, go back to Karma, and look and see if we've got another issue. Yep, we've got another issue, auth.isAuthenticated, is not a function. We could've anticipated this one because we know that in the template we actually get isAuthenticated called, and that's going to happen in these integrated tests without us executing any code. As Angular puts the component and the template together and compiles them, it's going to run through these methods in the template. This actually happens when we call change detection through that detectChanges method. That's the moment when this sort of stuff will be called. So we've got to have these methods. That's isAuthenticated, and right now I'm just going to create an empty method that returns true. And we'll save that and go back to Karma and see if we've got passing tests, and we don't. Now we cannot read property userName of undefined. So the next question is, where is that userName coming from? If we look for userName, we can't find it in the template. That's okay. Let's look at our component. And here we go. We've got userName is on the currentUser property on the AuthService. So back to our spec. We need to take this AuthService, and it needs a currentUser, and that needs to be an object that has a userName property, which I'll just set to the string Joe, because it doesn't really matcher at the moment. We'll save and go back, and now we have this.voterService.userHasVoted is not a function. So you can see my process here is, I'm slowly working through what the errors are and fixing them. Now, we could take another approach here. What we could do is just go to our code and start, say, inside of the component and walk through the component line by line and see what each of the services that we're using, what they each have and what's being called. So, for example, auth. If I just highlight auth, we can see all the places where it's used. We have currentUser being used, and that seems like it's about it. But let's look at our VoterService. We can see, oh, VoterService has calls to deleteVoter, addVoter, and userHasVoted, so we could just work this way and make these signatures be correct for our mock objects. So this is a really common place we're going to have these issues is, our mocks are not set up correctly. So that's the other approach to take. But in our case, based on what we're actually doing, not all this code is going to get called. For example, we're not calling toggleVote. So deleteVoter and addVoter methods are not actually going to get called. In that case, we don't necessarily need to have implemented the deleteVoter and addVoter methods on our mock objects. So let's just fix the one issue that we've got right now, which is voterService.userHasVoted is not a function. And again, when you implement these mock methods, you want to have some idea of what they should do when you create these mock methods. So in this case, again, I'm just going to return true. It's a very simple way to implement this method. And I'll save that and go back to Karma, and let's see what we're getting. And now we're actually getting all passing tests. You can see down at the bottom, the HTML that's showing up, that's the way that Karma works is, whatever HTML is part of the temple will actually be visible, which is totally okay. It's the gray area that has the tests that tells us what's going on. And so we now have a passing test. Unfortunately, if we go back to our test and scroll down into it, we may feel a sense of accomplishment now that the test is passing. But if we look at the test past line 50, we actually have no expect statements, and that's sort of a problem. In fact, if we head over to the command line, we can see that we're getting a warning, Specs 'SessionListComponent initial display should have the correct title' has no expectations. So it's actually telling us, hey, you've got an issue, you have no expectations. And that's not a good test. A test that doesn't test anything isn't a useful test. So let's go ahead and add an expectation. And the intention of our test was to have the correct title, so what we need to do is look at our HTML and figure out how to get to the actual title and the text of the title. So, again, the title's here in line 10. Session.name is where we bind in the name. I guess we said title. Maybe we should say session should have the correct name, might be a better name for our test here. We want that session.name there on line 10, and if we look, we can see it's inside of a div that has an attribute of, well‑title. Well, there's a lot of divs on the page, so just grabbing any random div isn't going to be easy. What we want is that specific div. And thankfully, there's a nice way through CSS selectors to grab the one div that has the well‑title attribute on it. So let's come down here and write our expect, and we're going to say expect. And now what we need to do is dig into that DOM. We actually have to work in the DOM. And we already talked about this a little bit before, Angular gives us the debugEl and the element as a way to get into the DOM. So we're going to use the element property. We're going to say, element.querySelector. And if you are familiar with the DOM API, you'll recognize querySelector. Again, this is just the raw DOM API. So this is the same querySelector that you would use if you were using plain JavaScript with plain HTML. So for our querySelector, we're going to give it a CSS selector, and we want the attribute well‑title. We want an element that has an attribute of well‑title on it, of which there is only one inside of the HTML for our component. There's only one of those attributes, which is going to be the one div. And there's only one session being rendered, so there's only one copy of all this HTML. If we were rendering out multiple sessions, we would have multiple divs with the attribute of well‑title. But in our case, we're only rendering one session so we only have one matching div. Once we have the matching div, inside of the DOM API there is the textContent property, and that actually gets all the inner text of the DOM node that we're dealing with and creates text out of it and gives it to us as a big long string. And then, now that we have that string, we can say we want to make sure that it contains our title, so we can use the toContain matcher that's inside of Jasmine, and then we just feed that in some text. In that case, what is the name of our session? We can see that on line 42 the name of our session is Session 1. Now I'm not using the toBe or toEqual matcher because inside of that HTML DOM element, there's also an i tag, and that could have other things in it, and there might be other elements that might have other text. So it's really common when writing these tests to use the textContent property and the toContain matcher. So let's save that and go back to Karma, and our test is still passing. So there we go. We've written our first basic test and finally worked through the problems, and we have a passing test that checks that the title of the session is correct. I always recommend to make your tests fail to make sure that they are truly working and you're not just getting a passing test no matter what you do. So I changed that one to a value that should fail. It is failing, which makes me confident that my test is working for the right reason.

Using DebugElement
We've got our first passing test, and our expectation, our assert on this test, was using the element property, which was actually the nativeElement property of the fixture. And as I mentioned before, this is a raw DOM API accessor to the template of the component. Now Angular gives us two methods that we can use to work with the template of a component while it's running inside an integrated test and to access that template and get inside of it and deal with it. One of those is that nativeElement. We see that there on line 34. But on line 33, we also see that we have a debugElement. The debugElement and the nativeElement are very similar to each other, but the debugElement is a wrapper that Angular has created around the raw DOM API, and it has a slightly different API to it than the DOM API. It's fairly similar, but it has some differences. But it also has some advantages because it is Angular‑aware. Now in a test like this, it really doesn't make too much difference. But let's look at how to use that debugElement instead of the nativeElement to do the same exact thing that we're doing here, which is very common to do. So instead of element, I'm going to call debugEl. And the debugEl has a query property on it, or a method actually, a query method. And it's very similar to querySelector. If you remember your DOM API, we have querySelector and querySelectorAll. Well, the debugElement has a query method and a queryAll method as well. They're very analogous to querySelector and querySelectorAll. It has a lot more APIs to it, a lot more methods and properties. You can go to the official documentation and look around if you're really curious about all of its capabilities, but we're just going to do the basic stuff here. We're going to call that query method, and the query method takes in one of a couple of things. It doesn't, by itself, like querySelector, allow you to do a css selector because it has a couple of options. You have to tell it how you're going to query. So in this case, we want to query by css. We're going to use the By object, and it has a css method within it. So you can see we've got the red squiggly line because By has not been imported. So I'm going to go ahead and import this. You can see I've got a couple of options. The first one is protractor. The second one is the angular/platform‑browser. So that's the one I'm going to select, and that imports that By object. And then inside the css, we use the exact same selector. So I'm just going to copy that and paste it in there rather than typing it in by hand. And that's going to give me a handle to that DOM element. And after that query has been run, I can then know that I have a handle to the debugElement wrapper around that same node that we were selecting in the previous line of code. And once I have it, I still just want to get down to the raw text that's underneath. And the easiest way to do that is to drill down from the debugElement to the nativeElement. And so every debugElement has a nativeElement property that goes from this debug wrapper down to the native DOM API element, and then that has the textContent. Now in a lot of other scenarios, you won't dig down to the nativeElement. Instead, the debugElement itself will have what you need, for example if you want to simulate a button click or if you want to ask if the element has a certain class. There are other ways to do that rather than drilling into the native DOM API. But when you want to just get the text contents within a DOM element, the nativeElement's textContent property is really the most convenient method. And now, in this case, we're going to just going to do the same thing. We're going to call our toContain and feed in the Session 1. And we'll save that, go back to Karma, and our test is still passing. And now we could comment out this code or even remove it because we're doing the same thing, but with the debugElement. And of course, our test is still passing. So these two methods together, the nativeElement and the debugElement, are analogous ways to work through and get pieces of the DOM, get handles of various pieces of your template, and then check things such as has the binding completed correctly, has this text been inserted correctly or not? And they each work a little bit differently, and you can always go from the debugElement down to the nativeElement. But you can't go from the nativeElement to the debugElement. So it's nice to view those two things as analogous trees of the DOM. But the debugElement is a wrapper around the nativeElement.

Testing Components with Shallow Integrated Tests
Okay, we've got our integration test written. We've looked at the various ways that we have to implement expect statements and to work inside of the DOM. But now we're going to look at the difference between a deep integration test and a shallow integration test. And we're going to start by actually looking at the console output of our tests. Looking at the console output, notice that we're getting these warnings and errors and they do say error even though the test suite is executing correctly. We're getting collapsible‑well is not a known element and upvote is not a known element. And if we go back to our code and look inside of our HTML, we can see, yes, on line 4, we use an upvote child component, and on line 8, we use a collapsible‑well child component. These are custom components that we created ourselves. And because our test, the test module, only has the SessionListComponent, this module has no idea what a CollapsibleWellComponent is there an UpvoteComponent. It knows about the DurationPipe, but it doesn't know about those other two components. And therefore, we're getting these errors that, hey, these are custom elements. I know they're not standard HTML elements, so maybe they're custom components, and this is a problem. And Angular is letting us know that this is an issue. Well, we can solve those problems fairly straightforward by just bringing in those components. So we're going to bring in our CollapsibleWellComponent and our UpvoteComponent. So we bring those two in and save and go back to just the command line. And now our tests have passed, and we're not getting any errors anymore. No warnings that we can't bind to those properties we don't know about, the Upvote or the CollapsibleComponents. But this is potentially an issue. If we go back and look at our tests, we're now bringing in two more components, and we're not really here to test those components. These tests are just around the SessionListComponent. So bringing in these other components, the CollapsibleWell and the UpvoteComponent, maybe they do a lot of work. Maybe they create a far more complex environment for us to test. And what if they themselves included child components, which also included child components? We might end up with 10 or 15 components in order to make this test pass and not give us any errors. And that could be a problem. We might create such a large test that it's too complex for us to manage and maintain, and that's kind of the point of unit testing is to isolate pieces of code and then test those pieces of code. So what we've created here is a deep integration test, utilizing the CollapsibleComponent and the UpvoteComponent, which are children of the SessionListComponent has created for us a deep integration test. A shallow integration test, on the other hand, only tests a single component and not its children. And we saw that we had a shallow integration test when we just didn't include these two components. Let's comment those out and go back to the command line, and now we have a shallow integration test, but we're getting these errors. We might not like having these errors, so there are ways to work around this. There are two main methods to work around having these errors, but still maintaining a shallow integration test where we only test a component and not its children. The first one is for us to create mock simple versions of these components, and that's actually very possible and not very difficult. We can just come up here at the very top, and we can do @Component selector upvote and then create a class, MockUpvoteComponent. And we can use that inside of our module instead of the real UpvoteComponent because it has the right selector. Now unfortunately, inside of our HTML where we use UpvoteComponent, we can look at the signature and see that we bind to the vote event and the count property and the voted property. So we would really need to go back into our MockUpvoteComponent and add in two inputs and one output to really match the API. So it is a little bit of work, but we can do it this way. And sometimes this is nice because it allows us to determine if the component that we're testing is interacting correctly with its child component and setting the proper data in at the right time because we can actually talk to the child component and ask it questions, but it's a more complex method. The simpler method is to use what's called the NO_ERRORS_SCHEMA. So you probably have never before dealt with a schema inside of your module. I'm going to remove these other two lines of code here. But modules, in addition to declarations, providers, and imports, also have a schemas property. And this is, again, an array, and you can pass in different HTML schemas to use. By default, Angular uses a schema that tells you if it encounters an element that is not a standard HTML element, but also not an element that it knows about, in our case CollapsibleWell and Upvote. But we can tell it to use a different schema that ignores these issues, and that would be the NO_ERRORS_SCHEMA. So I'll bring that in, and it gets auto imported for me, and I'll save that. And now when we execute our test again, we're getting a passing test and no errors because we're using the NO_ERRORS_SCHEMA. So that's the second way we can create shallow integration tests and deal with child components. But the difference in this method is that we're actually ignoring the child components rather than dealing with them through either using a deep integration test or creating mock components specifically to simulate those children. Now finally, a note here about what we've done. Notice we've finally written our test, and it took us 59 lines of code just to check the title of the session in the session list. So that's actually a lot of code. And if we look at the setup, just the setup was 40 lines of code. That's a lot of code and a lot of complexity to test, and we're only beginning to dig into testing the SessioListComponent. If we look at the actual template, we can see there's a lot of properties, a lot of data that's being displayed, that we could test and make sure it's being displayed correctly. And then we might look at interaction. What happens if we hover over something or click on something? Does our SessionListComponent actually work? So these are all things to keep in mind when you write integration tests that they are very complex in comparison to isolated tests and they take a lot of setup. They do allow you to test your template, but it is very easy to end up either writing very large, overly complex integration tests or to end up writing a lot of integration tests to test your template. So definitely things you should be aware of when you decide how you're going to create your integration tests.

Summary
In this module, we saw how to test both the class and the template of a component using an integrated test. Integrated tests require a lot more setup than isolated tests, but they're the best way to test your components working with their template. We saw two types of integrated tests in this module, deep tests and shallow ones. Deep tests let us test both the component and any component it uses in its template, plus directives and pipes. A shallow test favors just testing a single component in isolation. Both of these types of tests are useful depending on the situation.

Taking an Angular App to Production
Introduction
In this module, we are going to learn how to take our Angular app to production. This is a critical final piece of this course, to take everything that we've done and be able to put it someplace that our users can actually get to the application and benefit from it. The topic of going to production covers quite a few different things. First, we're going to look at linting. Linting is a common task that we'll want to do to our code as we're building our code and certainly before we take it to production. So we're going to look at how to use linting with Visual Studio Code, which is by far the most popular editor for Angular, and how to do it just for the command line so that it works no matter what editor we're using. After that, we're going to talk about how to actually create a build using the CLI. We're going to look at build flags and the ahead‑of‑time compiler. Then we'll look at actually deploying the build that we've created to a production environment. And finally, we're going to talk about optimistic module downloading, which is an important part of tuning our applications for production use.

Linting Overview
In this section, we're going to take a brief overview as to what is linting. First, let's define the word linting. Linting is essentially finding the lint in your code or the little tiny bits that don't necessarily cause major problems, but might cause small problems or might build up into bigger problems. Now that's a nice little definition, but let's actually really dig into what is linting. Linting is pointing out and fixing potential problems in your code. Mostly, it's coding style changes. Rarely is it going to be something serious because most editors will point the serious issues out to you. In the case of JavaScript, because there's so many ways to construct your JavaScript, there's actually a lot of value in linting. For example, it might point out to you missing semicolons. JavaScript often works without the semicolons, but there are a few places where not having the semicolons can get you into trouble. It'll point out double versus single quotes if you're using them inconsistently. Linting lets you pick a standard and decide that we are only going to use double quotes in this project or single quotes. It'll point out lines of code that are far too long, and it'll find a ton more issues that are very similar to things like that. Lots of small, even somewhat nitpicky issues. So let's look at linting in action. We've got a little bit of code here that declares a variable and then logs out to the console. If we were to run this through a modern JavaScript linter like ESLint, we would find a few problems. For example, this var could actually be a const. The x is never reassigned or changed to another value, so we could set this as a const. That would be slightly safer than declaring it as variable. Next, we've got a mix of double quotes and single quotes, and most linters default to using single quotes. Of course, we could configure that, and then it would point out that the single quotes that we use later on in that same line are the problem. And finally, we've got a missing semicolon right here. So this is what a linter would point out to us. Now some linters will just put out the problems. Some linters allow us to actually automatically fix the problems, depending on the linter and the settings that we give it. Now, of course, you might look at linting and feel like it's not really very important. It's just pointing out code style problems, and who cares about that? But there are a few benefits of linting that you should consider if you're not already doing it. First, it generates consistency across your team. Second, you can actually catch some potential errors. Third, it has automatic error fixing, which really handles a lot of these issues for you. And finally, you can set up CI or commit hooks so that linting is actually automatically done to your code or commits are rejected if they don't pass linting. There are a few other things you should be aware of when talking about linting with Angular. First off, there is a difference between linting JavaScript and linting TypeScript. TypeScript is a superset of JavaScript, so that means that there are more things going on in TypeScript than a typical JavaScript linter is going to know about. Finally, a lot of people complain about linting because there are so many choices to make. There are so many things you can do to your linter to say do support this, don't support this, point out to me when this happens, but not when this happens, etc. There's been a recent push to use more opinionated tools than your typical linting tools, and one that has arisen and become very popular is called Prettier. You can use Prettier with TypeScript and with your Angular code. We're not going to talk about Prettier specifically in this course. But everything that we say about linting applies to Prettier, other than the fact that Prettier handles all the fixes for you automatically, and it has very few things that you can configure. But otherwise, the process is basically the same.

Installing TSLint in VSCode
We learned a little bit about linting and the purpose of it. So now let's go ahead and install a linter. We're going to install ESLint, which is a very popular linter. It's not the only one that's out there. It's not the only option. But it is a popular and fairly general purpose linter. Now before I install it, you may notice that TSLint has already been part of our project. TSLint was a very popular linter, but was deprecated awhile ago. So this is going to be very common that you're going to encounter TSLint dealing with Angular projects if they were already existing projects and not new projects. But we're going to learn ESLint in this course. So to install ESLint, it's very simple. We're going to do npm install eslint, and that's going to install the current version of ESLint into our project. And we've got ESLint installed now, and now we need to initialize ESLint here inside of our project. ESLint needs a config file in order to have its settings, and you're going to want to config file anyway because you're probably going to want to customize whether or not it triggers on this problem or that problem or what. So you're going to need to initialize ESLint, and we do that with the ESLint's command line. And since we've installed it, we can use the npx command. If you're not familiar with npx, it's a little bit like npm, but it lets you run installed packages that you have. There's a lot more to it, but that's beyond the scope of this course. So we're going to use npx eslint and then ‑‑init. And now that's going to ask us a series of questions. And what questions it asks us may vary from version to version of ESLint. But just choosing the most obvious or default choices when you answer these questions is going to be the easiest. So we're just going to check syntax and find problems. We're using JavaScript modules, not CommonJS. We're not using any of those frameworks, so I'm going to select none. Since I'm using the Bash shell on a Windows machine, you can see my choice has moved, but it did choose none. We do use TypeScript, so I'm going to choose Yes on that. And our code runs in the browser, so we'll select browser. And then for the format, JavaScript is fine. YAML is okay. I don't prefer YAML myself. JSON is fine. I'm going to do JSON and choose that. And then would you like to install now the dependencies? Yes. So it's going to go ahead and install all of our dependencies that ESLint has in order to run. And after it's done doing that initialization, ESLint is now ready to go.

Using TSLint with VSCode
We've installed ESLint, so let's go ahead and execute it and look at the results. In order to execute it again, I'm going to use that npx command, npx eslint. And now I tell it what files I want to lint. So I could give it the path to a specific file. Or if I just give it a period, it's just going to lint everything in the current directory and all of its subdirectories. And, of course, that's going to be linting a whole bunch of stuff, so probably more appropriate would be to just lint the src/app directory and all of its subdirectories. So let's go ahead and execute that. And it's gone ahead and produced a whole bunch of output for us as it's gone through and linted our code. You'll notice that it linted very fast. If you run this on your local box, you'll find out that ESLint is very quick to go through and find these problems. Notice that a lot of the things that it's getting. As we look at the screen, it's telling us that we have missing return types on functions. Personally, that's not something I'm too worried about, but a lot of other issues like that. Let's look through and go find, for example, our voter service. So you can see that our voter service itself is giving us five different errors. The first three are missing return types on functions on lines 12, 21, 31. So let's head over to our code and open up that voter service. And looking here at line 12, we have our deleteVoter method, and it doesn't have a return type specified. In this case, it doesn't return anything, so we're going to specify that we return void. On addVoter, same thing, no return value. And finally, on userHasVoted, it returns the result of some, which is a boolean, so we'll mark it is boolean. Let's just make those three fixes, save that, back to the command line. Scrolling all the way down to the bottom, we can see a summary. We have 99 problems, total; 25 of those are errors, 74 warnings, and it knows that 23 errors are fixable with the fixed option. But let's go ahead and just rerun this now that we've changed a couple of those and see what the result is. Okay, we fixed 3 issues and therefore our 99 problems has gone down to 96. So let's go ahead and rerun this eslint, except this time we're going to give it the ‑‑fix command. And that should go through and try to auto fix everything that can be fixed. So we'll hit that. And notice that it's gone down to 73. So it's actually fixed a lot of the errors that were being put out. Now you may or may not want to do that, but that is a possibility. One thing that you can be with the ESLint is just have it go through and try to auto fix issues in your code. And that is how to run a ESLint on the command line.

Linting from the Command Line
Now that we've learned how to run a ESLint from the command line, one of the things you might want to do is have it running inside of Visual Studio Code. And that's actually really quite simple and a nice thing to have if we are going to use ESLint is while we're coding to have ESLint itself tell us what errors it's finding. So I'm going to open up our extensions, and I'm going to search for ESLint. And you can see it's found ESLint right there, and I'm just going to click to install. And once that's installed, I can close that down. And now if I hit Ctrl+Shift+P and look at the ESLint commands that are available, we can see one of these is Manage Library Execution. So I'm going to select that. And this little dialog pops up and asks me where I want to actually run ESLint. So I'm going to click Allow Everywhere. And at this point, ESLint is going to be running and looking at the code that I'm actually working with and running against the code window that I'm actually in. So we can see right here in this voter service, we've actually got ESLint giving us a couple of suggestions with these yellow squiggly underlines. So here, if I hover over it, it actually tells me what it's found. Operation is declared, but its value is never read. And then on error, it doesn't like the any type. It wants us to specify a different type. With all these problems that it finds, if you just hover up over this quick fix and select that, it gives you a bunch of options. I can use the unknown type instead or the never type. Or on this one if I click Quick Fix, it can prefix operation with an underscore or disable some of my ESLint rules instead. So there's a lot of options that are available. Let's look at some things that have good, simple, straightforward fixes. So let's say we were coding along, and we needed a new variable. So we said var x = hello. And if we look at this errors that's producing, unexpected var, let or const instead. So ESLint is telling us, hey, var is not a good way to code. You should be using let, or you should you be using const. So let's hit Ctrl+period, and we get this Fix this no‑var problem. So I'm going to select that first option. You can see it switched that over to let. So now let's look at this next error that's coming up. Now we're getting the issue of, hey, this is an unused reference. Let's hover over that so you can see that. X is declared, but its value is never read or used. It's also never reassigned to use const. So there's a lot of problems with this particular line of code. So again, I can hit dot period, and one of the options is to remove. So I can click that, and it just removes the line of code, which is really nice. If you're coding along, it's not too unlikely to occasionally have a variable that you no longer need or use any more in your code. And ESLint will point that out for you and help you to remove that. Such are some of the features of ESLint, and definitely using the plugin for your editor is a really good idea. It makes your coding a lot easier and shows you these issues as you're typing them up. And of course, ESLint is also very configurable. You can go in and specify the rules that you want it to have. So if you're going to be using ESLint, I highly recommend you get comfortable with it and learn to configure it and customize it.

Going to Production - Overview
In this clip, we're going to take a brief look at an overview of what it means to take an Angular project to production. Taking an Angular project to production centers around one tool, which is the CLI's build command. We have to build our application in order to take it to production, and that's very easy to do with the CLI's build command, ng build. Let's talk about the ng build command and all the things that it does. From a high level, what ng build does is produce a deliverable code package. Just like lots of other languages and technologies, with JavaScript, we've reached a point where we've got lots of JavaScript files in a nice, deliverable code package, and make optimizations for them as well so that execution, while in production, is both fast and takes a minimum amount of resources. So let's look at what those production optimizations are. First, it turns development mode off. Development mode is simply a little setting in Angular that double checks that you aren't doing anything strange with change detection. For more information, you can check out the official documentation. Next, ng build will bundle up your code. We'll look exactly at what that means in a second. It also will minify your code; we'll look at that as well. It tree shakes your code; we'll also look at that. It will do dead code elimination, which is related to tree shaking. Next is asset inlining. This is a process where small assets such a CSS files and images are actually bundled up together and inlined into your JavaScript code so that they require fewer requests and have less overhead, and therefore your application is again a little bit more performant. And one of the major jobs of the ng build command is to execute the ahead‑of‑time compiler. With newer versions of Angular, this is actually happening even when we're running in development mode, but it's an important step, and we'll actually look at what happens when we run the ahead‑of‑time compiler later on in this course. So let's start by looking at minification. What exactly is minification? Well, we start here with an example piece of source code, a little orderService class that has a couple of methods. Notice that there's lots of whitespace. A minifier will actually take this code and remove all things that don't matter for the JavaScript compiler, such as the browser, to actually process and understand the JavaScript correctly. So what we actually can do is turn that code on the left into the code on the right. We've gotten rid of whitespace; we've smushed it all together. It's a lot less readable to a human, but to a computer, this is just fine. There are even some aggressive settings you can turn on with a minifier that will do things like rename your parameters to shorter names, and rename identifiers and other similar issues. But of course, that's way beyond the scope of this course. It's just important to understand what minification is and that the ng build command actually minifies your code. Next we have bundling. This is another step that will optimize applications for production. In development, we deal with separate JavaScript files. We might have one for the order service, one for the order component, and one for the line item component. Of course, this is just for programmers. Computers don't need all these files to be separate, so bundling is a process of taking all these JavaScript files and sticking them all together in one big file so that we have less requests going over the wire and less overhead as we deliver our code down to the browser. Finally, we're going to look a tree shaking. This is one of the more recent additions to code optimization for production in the JavaScript world. The basic concept is to remove code that isn't ever called in your system. So imagine a system where you've got a service called the UserService and has two methods, getUsers and getUser. Now further imagine that in your system, this service is only used in one place, and only the getUsers method called. The getUser method is never called anywhere. You wrote it, but you never used it. Well, there's no reason for that method to even exist on the class anymore. For all intents and purposes, you can remove it, but say that you think that sometime in the future it may get used, or perhaps it's in a library that's used by multiple applications, and other applications use that method. So you can't just delete the code, but when you deploy to production, it would be nice if that code didn't even make it into the production bundle. That's tree shaking. Tree shaking can actually remove methods and properties that are never called. Now I also mentioned dead code elimination in a previous slide. Tree shaking and dead code elimination are two aspects of the same task: trying to only get the code that's actually used into your output bundle. The difference between the two techniques is a little bit academic and not really worth worrying about, but suffice it to say that the CLI is doing its best job going through and trying to get rid of any unused code so that your delivery bundle is a small as it possibly can be.

Angular's Ahead of Time Compiler
Now before we create our first production build, we're going to talk about Angular's compiler. This is conceptual stuff that you don't have to understand in order to work with Angular, but it is nice to know about. As a simple definition, the compiler is a process that runs during Angular's build that handles turning templates into JavaScript code and checks to make sure that the components that use those templates aren't doing anything that would cause problems in production. There's a lot of benefits to the compiler. First off, it makes rendering faster. The compiler turns your templates into optimized JavaScript functions. Doing that during build time means that there's one more process that's not happening during runtime, which means that rendering out your templates and rendering out your UI to your user is going to be faster. Second, it produces a smaller download because the parts of Angular that need to go down to the browser are reduced. Third, it will detect template errors. There are some things you could be doing in your template that could cause problems, and the compiler will detect those. Finally, it's better on security. The compiler actually plugs some security holes, the details of which are beyond the scope of this course, but it does improve the security of your applications. The biggest job of the compiler is compiling templates. When Angular runs in the browser, a big piece of what goes on is the template. Ultimately, the code that you write needs to show something in the browser so that the user has some interaction. That means manipulating the DOM. We author templates in HTML to let Angular know what needs to be done. We use bindings, advanced directives, and components in our HTML templates. But this HTML is useless as it is. It has to be turned into JavaScript instructions so that the browser can actually manipulate the DOM and render something to the user. That process is done by the Angular Compiler, which takes the HTML from your templates and turns it into the JavaScript instructions that manipulate the DOM. This is the main job of the compiler.

Creating your First Build
Let's learn how to build our code for deployment. Now we're going to do a non‑production build. We're just going to do a default build. You might call this a development build. But it's still a build of our code. Later on, we'll look at how to do a production build and the differences between the two types of builds. But for now, we're just going to do a regular build. So here on the command line, I'm going to use the CLI command ng build. And if I didn't have the Angular CLI installed globally, I could do npx ng build as well. So I'll go ahead and execute that, and that's going to build the code. And this is going to take just a few moments, so we'll skip forward through this. And with that build finished, let's head over to our code. Let's see what was actually created. So I'm going to open up inside of our explorer. I'm going to look inside this dist folder. And notice, there's now a new subdirectory, ng‑fundamentals. It creates a subdirectory that's the same name as the project. And inside of that, we've got a bunch of files. And altogether this creates a deployable build for our project. So we have an assets file that has everything that was inside of our assets folder, in this case just images. We have our favicon, our fonts. The main HTML file, the index.html, we'll come and look at that in depth here in just a second. Then you can see a set of JavaScript files with maps and finally a scripts file, the CSS styles, and a few more JavaScript files. And all together, this is our entire project. One thing to note is that we have the main JavaScript file, but also we've got our user‑module down here as well. So there are different packages for the two because our user module is lazy loaded. Now let's just look really quickly inside of our index.html file and see what's inside of here. It's pretty straightforward and simple, other than we have all these script files, so it includes first the runtime. And then it has the polyfills, and then it has our scripts and then the vendor bundle. When we get all the way to the end, we find the main bundle right there, but you won't find that user module. The main bundle is our main module, but the user bundle is missing because that's going to be downloaded separately and not initially when the page is rendered. And this package here, this entire subdirectory, the ng‑fundamental subdirectory and all these contents, this is what we would use and deploy up on a production server. Again, this is a development build. It's not quite optimized as much as it could be. The production builder is going to be more optimized, but it also won't include like your map files and things like that. So in this case, it's sometimes nice to deploy just this version up maybe to staging and testing. And then your production build, you deploy that to your production environment.

Basic Deployment
Now before we look at a demo of actually serving up our built directory, that dist directory, let's talk about what the process is when we're going to do a deployment of our project to a production or staging server. The deployment process is really very simple. We just take the results of that dist directory, all the contents of it, and we copy that up to a target server. And on that target where we copy it to is going to be some kind of a web server that's pointed at our dist directory. And when somebody requests a file, it will serve up the files, whether it's the index.html for the default route. Or if it's one of the images, it'll serve up the image. And of course, it doesn't need to be a physical server. This could be the cloud. This could be the same machine. In fact, when we do this, we'll be using the same machine and the same directory. But the point is, once we run ng build, we just copy that directory to wherever it needs to go.

Demo: Serving up a Build
Let's actually run our built directory through a Web server so that the server is being run from that built directory, from that dist directory, and that's what's getting served up, and those are the files that are coming down to the browser and not what's getting served up through the CLI's development Web server. To do that, all we have to do is have that Web server running that we built in order to just run the API. Because when Jim and I built that Web server, we also built it to serve up the dist directory for regular files, if they exist, but only on that port. So this a little bit complex. Let me explain it. First, we need to start up that server, npm run server. Of course, this is only if it's not already running, and when we launch that, we can see that it's listening on port 8808. And with that running, we're going to go out to a browser, and instead of going to local host port 4200, we're actually going to go to port 8808. And notice that our site has come up on port 8808, the normal regular site. This is our application, just as we have built it. If we go around and look around, all the data is going to be the same. This is exactly what would happen in a production scenario. We simply take our dist directory and we move it to a target server. And then we have a Web server that's pointed at that directory. And when a browser hits that Web server, it just serves up that index.html file from the dist directory. We didn't take the step of physically taking that directory and moving it somewhere else, because the Web server that we've got running on port 8801 is already looking at the existing dist directory where it's at. But that is how we would do this in production. Now let's compare what this is doing to what the CLI is doing. I'm going to go back to a different command window, and I'm going to launch the CLI's dev server with npm start, which ultimately just runs ng serve with our correct proxy settings. I'm going to wait for that to finish spinning up, and we'll head over to the browser and open up a new tab, but on port 4200. And, again, we see our application running, same exact application. Now, let's just look at the difference in what is delivered between our CLI driven version of our application and the one that is served up from the distribution directory. So I'm going to open up the console and go to the Network tab. And I'm going to refresh this page so we can see exactly what is being delivered when we load the application. So looking down on the bottom, you can see that we've got 17 requests and almost 14 MB transferred. Now, don't pay attention to these numbers. They're going to change as Angular itself changes, the Angular team is constantly tuning how the CLI works and what it's delivering. But let's just get an idea here, in this case, in this scenario, for this version of the CLI, we're transferring about 14 MB. Now let's go to our build version and see the difference. And before I refresh, I want to go back into the console. Oftentimes what'll happen when we start our application with CLI is if it sees that dist directory, it'll actually clear it out and delete it. So I want to rebuild the project again, using that ng build command, just to make sure that we are dealing with a fresh copy of the build. And once that's done, back into the browser, open up the console. We're on the Network tab, we're going to refresh, and notice how we only have 16 requests and 5 MB transferred. Again, this isn't even completely optimized because we aren't using the prod flag. But you can see that already what gets created inside of the dist directory when we build is a fair amount smaller than what is delivered using the CLI when we're in development.

Build Flags
Now we ran the build using ng build without any flags, but there's actually quite a few flags that the build supports. There's something like 15 or 20 flags that are actually supported. There's really only a few that are going to matter in most cases. So we're not going to go through every flag. We're just going to cover a couple of the more important ones. The first flag I want to talk about is the ‑‑prod flag. This tells the build to run in production mode, and this actually sets a whole bunch of other flags to specific values. Now since we usually use the CLI as our server, we don't often need to build in dev mode. Most of the time, we build in production mode. But it is important to understand that there are the two flags and the default is dev mode. If we want to produce our most optimized, most performant package, we'll use the ‑‑prod flag, and we'll see that in the next section.

The Effects of Prod Mode
Now, we ran our build initially without any flags, just ng build, which produces the build in dev mode. We're going to run it again, but in production mode. We can do it this way with ng build ‑‑prod. Of course, if we do npm run build, our packaged out JSON file is set to do the same exact thing, to run ng build with ‑‑prod. So either command we run, we're going to produce a production build. I'll execute that now. And depending on your machine, this may take quite a bit more time than your dev build takes. Now, it's important to see that we actually have a lot of information that's being printed out when we run our build. Looking here, we can actually see the file sizes produced in our bundles, 127 KB, 700 KB, 61, 125, 1.4. This output can help us tune our build as we change various settings inside of our project or split it up into different lazy‑loaded bundles, which we will also see a little bit about that later on. But let's just go back to our browser now and see what the effect of that build is. Again, I'm going to open up the console, I'm going to go to the Network tab, and I'm going to refresh this. Before I do this, remember that using the CLI dev server, we're producing about 14 MB. Using a dev mode, we're getting about 5 MB is the size. And now, with the production mode build, we're getting it down to almost exactly 1 MB. So you can see that the tuning involved in doing a production build is actually pretty significant in comparison to the other two builds. And of course, these numbers aren't going to be what your numbers are. The CLI is constantly being tuned. The Angular team is constantly working on adjusting these and optimizing these file sizes. So likely, over time, you'll see even better results than we're seeing here.

Optimistic Bundle Downloading
The final thing we want to look at is loading strategies for our lazy‑loaded modules. This doesn't directly correspond to making a build, but it really does affect the performance of our application. Not the size of the downloads, but the perceived performance. So our application has a lazy‑loaded module. It's the user module. If we go into our code, remember that our user module is a separate module. The route path is actually a lazy loaded path, and we do have a user module, which is this module right here. We can tell Angular how to load that module. The default way is to load the module on demand. So let's go back. We're just using the CLI's dev server. We're not running our production build anymore or our dev build. I'm going to open up the console and on the Network tab. I'm going to refresh the whole website, and I've loaded a bunch of bundles and other files. I'm going to clear all those out. Now I'm going to click on the Login button, and notice that I immediately download this user.module.chunk. That is our user module. It hasn't been downloaded yet. Now If I go back to all events and go to Login, it's not downloading it again. It got downloaded once, and that's it. That is loading on demand. Let's change our loading strategy to actually prefetch as soon as possible. I'm going to open up the app.module. And inside of here, inside of the forRoot call, I'm going to add a second parameter, and that's an object. And I'm going to give that object one property, and the property is preloadingStrategy. I'm going to give that property the value of PreloadAllModules, and that automatically imported the PreloadAllModules value from the Angular RouterModule. Save that change and go back to the browser, and we go to the All Events. I'm going to refresh the page. And notice that even though I'm on All Events, if I scroll down, I can see that the user module has been downloaded. Before we had to click on the Login page to get this module to download, but now it's getting downloaded automatically. That is the PreloadingAllModules strategy. Angular does allow you to create your own preloading strategies so you can have some that are really optimized for your application. But if you do have some lazy‑loaded modules that are very large, in this case the module is very small, only 30 KB. But you easily could have a much larger module, and so prefetching that module when the browser is available to do so will improve the perceived performance of your application. So this is another important strategy when going to production when trying to tune the performance of the application is to preload modules when you can and also to make your initial module as small as possible.

Summary
In this module, we looked at a lot of different topics related to taking our code to production. We looked at linting and how that works versus Prettier. We talked about the less opinionated linting and the more opinionated tool, Prettier, and similar tools like that, and we talked about how linting can help us with our code quality. Then we looked at deployment. We saw the deployment with Angular is fairly simple because our builds are just a folder that we could just copy to wherever our server actually reads from. We finished up with looking at optimistic bundle downloading, a nice performance technique that improves the perceived performance of our application, which is a great thing to improve our user's experience. Through this module, we learned how to take our code to production. Finally, on behalf of myself, Jim Cooper, I want to thank you for watching our course. We hope you got out of it as much education and enjoyment as we did.